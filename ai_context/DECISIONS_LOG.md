# SimpleTrade 决策日志

## 2024-04-11 17:50: 使用vnpy最新版本
**决策**: 使用vnpy的最新版本（4.0.0+）而非原计划的2.3.0版本
**原因**:
- 最新版本包含更多功能和改进
- 采用了更现代化的插件架构
- 更好的社区支持和维护
**替代方案**: 使用原计划的2.3.0版本
**影响**: 可能需要适应新版本的API变化，但长期来看将获得更好的功能和支持

## 2024-04-11 17:50: 使用conda环境
**决策**: 使用conda环境来管理项目依赖，所有应用安装必须使用conda安装，并且始终使用当前项目的simpletrade conda环境，不创建新的环境
**原因**:
- 更好地处理二进制依赖，特别是TA-Lib等C库
- 提供隔离的环境，避免依赖冲突
- 更容易在不同平台上复现环境
- 使用conda安装可以避免pip安装时的各种兼容性问题
- 使用同一个conda环境可以确保在不同IDE和工作环境中的一致性
**替代方案**: 使用pip、virtualenv或系统Python环境，或为不同工作环境创建多个conda环境
**影响**: 开发环境设置、依赖管理、项目可移植性、安装流程标准化、跨IDE工作流程

## 2023-10-15 13:00: AI协作方式优化
**决策**: 采用结构化项目状态文件方法管理AI协作
**原因**:
- 减少每次会话需要重复说明的上下文信息
- 保持项目信息的一致性和完整性
- 便于追踪项目进展和决策历史
**替代方案**: 每次会话手动提供上下文、使用外部工具管理项目状态
**影响**: 开发效率、AI协作质量、知识管理

## 2023-10-15 10:15: 项目名称选择
**决策**: 项目名称确定为"SimpleTrade"
**原因**:
- 名称简洁明了，直接传达了平台的核心价值 - 简单易用的交易体验
- 易于记忆和传播
- 具有国际化潜力
**替代方案**: QuantEdge, TradeMatrix, AlgoWealth等其他名称选项
**影响**: 品牌定位、用户感知、营销策略

## 2023-10-15 10:30: vnpy使用方式
**决策**: 直接使用vnpy源码而非作为依赖安装
**原因**:
- 提供最大的灵活性和控制力
- vnpy核心源码相对简单，易于理解和维护
- 可以深度定制功能，满足特定需求
**替代方案**: 作为依赖安装vnpy，通过扩展实现功能
**影响**: 开发方式、维护成本、功能实现方式

## 2023-10-15 11:00: 前端实现方式
**决策**: 采用微信小程序和消息交互作为主要前端
**原因**:
- 用户可以随时随地通过微信访问系统
- 利用用户已有的使用习惯，降低学习成本
- 消息驱动的交互模式简单直观
**替代方案**: 传统Web界面、桌面应用
**影响**: 用户体验、开发复杂度、功能实现方式

## 2023-10-15 11:30: 项目文档结构
**决策**: 创建全面的项目文档体系，包括执行计划、功能需求、技术规格等
**原因**:
- 确保项目需求和技术路线清晰
- 为开发团队和AI助手提供明确的指导
- 便于项目管理和进度追踪
**替代方案**: 简化文档，直接进入开发阶段
**影响**: 开发质量、团队协作、项目可维护性

## 2023-10-15 14:15: 数据存储方案
**决策**: 使用轻量级数据存储方案(SQLite + 文件存储)
**原因**:
- 适合个人项目和单服务器环境
- 减少资源需求和维护成本
- 简化部署和配置
**替代方案**: 使用MongoDB + Redis + 时序数据库等更复杂的方案
**影响**: 系统性能、可扩展性、维护复杂度

## 2023-10-15 14:40: 项目结构独立化
**决策**: 创建独立的SimpleTrade项目结构，不再依赖于vnpy源码环境
**原因**:
- 清晰的项目边界和职责划分
- 便于管理和版本控制
- 符合标准Python项目结构
**替代方案**: 继续在vnpy源码环境中开发
**影响**: 项目组织、开发流程、代码管理

## 2023-10-15 15:20: vnpy源码集成方式
**决策**: 采用Git子模块方式集成vnpy源码
**原因**:
- 独立版本控制，便于跟踪上游更新
- 可以直接访问和修改vnpy源码，实现深度定制
- 项目结构清晰，便于管理和维护
- 灵活的更新策略，可以选择性更新
**替代方案**: 直接复制源码、作为依赖安装、Fork + Pull方式
**影响**: 项目结构、开发流程、维护方式

## 2023-10-15 15:25: vnpy核心组件扩展策略
**决策**: 通过继承和扩展vnpy的核心组件，而非重写
**原因**:
- 保持与vnpy原有功能的兼容性
- 减少代码冗余和维护成本
- 便于跟随vnpy更新
**替代方案**: 完全重写核心组件、使用组合而非继承
**影响**: 代码结构、功能实现、维护复杂度
