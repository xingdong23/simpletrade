# 项目上下文
*目录: /Users/chengzheng/workspace/trade/simpletrade*
图例: ✅=包含的文件/目录, ❌=排除/过滤

## 项目树
```
. ✅
├── __MACOSX ❌
│ ├── simpletrade ❌
│ │ ├── .cursor ❌
│ │ ├── .git ❌
│ │ ├── .idea ❌
│ │ ├── ai_context ❌
│ │ │ ├── archive ❌
│ │ │ │ ├── SESSION_SUMMARIES ❌
│ │ │ ├── modules ❌
│ │ │ │ ├── data_import ❌
│ │ │ │ ├── strategy ❌
│ │ │ ├── REFERENCE ❌
│ │ ├── data ❌
│ │ ├── docker_scripts ❌
│ │ ├── docs ❌
│ │ ├── examples ❌
│ │ ├── mysql-init ❌
│ │ ├── notebooks ❌
│ │ ├── scripts ❌
│ │ ├── simpletrade ❌
│ │ │ ├── __pycache__ ❌
│ │ │ ├── api ❌
│ │ │ │ ├── __pycache__ ❌
│ │ │ │ ├── routers ❌
│ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ │ ├── wechat ❌
│ │ │ │ ├── schemas ❌
│ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ ├── wechat ❌
│ │ │ │ │ ├── __pycache__ ❌
│ │ │ ├── apps ❌
│ │ │ │ ├── __pycache__ ❌
│ │ │ │ ├── st_analysis ❌
│ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ │ ├── api ❌
│ │ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ │ ├── commands ❌
│ │ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ ├── st_backtest ❌
│ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ │ ├── ui ❌
│ │ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ ├── st_datamanager ❌
│ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ │ ├── api ❌
│ │ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ │ ├── commands ❌
│ │ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ │ ├── importers ❌
│ │ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ ├── st_message ❌
│ │ │ │ │ ├── __pycache__ ❌
│ │ │ │ ├── st_trader ❌
│ │ │ │ │ ├── __pycache__ ❌
│ │ │ ├── config ❌
│ │ │ │ ├── __pycache__ ❌
│ │ │ ├── core ❌
│ │ │ │ ├── __pycache__ ❌
│ │ │ ├── models ❌
│ │ │ │ ├── __pycache__ ❌
│ │ │ ├── services ❌
│ │ │ │ ├── __pycache__ ❌
│ │ │ ├── strategies ❌
│ │ │ │ ├── __pycache__ ❌
│ │ │ ├── vendors ❌
│ │ │ │ ├── vnpy_tiger ❌
│ │ │ │ │ ├── vnpy_tiger ❌
│ │ │ │ │ ├── vnpy_tiger.egg-info ❌
│ │ ├── simpletrade.egg-info ❌
│ │ ├── src ❌
│ │ │ ├── components ❌
│ │ ├── test_data ❌
│ │ │ ├── qlib_data ❌
│ │ ├── tests ❌
│ │ ├── ui ❌
│ │ │ ├── ai_analysis ❌
│ │ │ ├── backtest ❌
│ │ │ ├── common ❌
│ │ │ ├── dashboard ❌
│ │ │ ├── data ❌
│ │ │ ├── js ❌
│ │ │ ├── models ❌
│ │ │ ├── strategies ❌
│ │ │ ├── trading ❌
│ │ ├── web-frontend ❌
│ │ │ ├── public ❌
│ │ │ ├── src ❌
│ │ │ │ ├── api ❌
│ │ │ │ ├── components ❌
│ │ │ │ ├── router ❌
│ │ │ │ ├── store ❌
│ │ │ │ ├── views ❌
│ │ │ │ │ ├── analysis ❌
│ │ │ │ │ ├── data ❌
│ │ │ │ │ ├── strategy ❌
│ │ │ │ │ ├── trading ❌
│ │ │ ├── web-frontend ❌
│ │ │ │ ├── src ❌
└── simpletrade ✅
  ├── .cursor ❌
  ├── .git ❌
  ├── .idea ❌
  ├── ai_context ✅
  │ ├── archive ✅
  │ │ ├── SESSION_SUMMARIES ✅
  │ │ │ ├── README.md ✅ (88L, 1,319C) [~0.19%]
  │ ├── modules ❌
  │ │ ├── data_import ❌
  │ │ ├── strategy ❌
  │ ├── REFERENCE ✅
  │ │ ├── README.md ✅ (66L, 1,098C) [~0.16%]
  │ └── README.md ✅ (175L, 2,475C) [~0.35%]
  ├── configs ❌
  ├── data ❌
  │ ├── csv ❌
  ├── docker_scripts ✅
  │ ├── backup_data.sh ✅ (29L, 516C) [~0.07%]
  │ ├── check_system.sh ✅ (39L, 513C) [~0.07%]
  │ ├── run_api.py ✅ (119L, 4,239C) [~0.61%]
  │ ├── run_backtest.sh ✅ (34L, 629C) [~0.09%]
  │ └── start_jupyter.sh ✅ (5L, 153C) [~0.02%]
  ├── docs ❌
  ├── examples ✅
  │ ├── api_example.py ✅ (39L, 760C) [~0.11%]
  │ └── data_management_example.py ✅ (107L, 2,671C) [~0.38%]
  ├── logs ❌
  ├── mysql-init ✅
  │ └── 01-init.sql ✅ (26L, 895C) [~0.13%]
  ├── notebooks ✅
  │ ├── README.md ✅ (171L, 3,834C) [~0.55%]
  │ └── 数据分析示例.ipynb ✅ (580L, 16,587C) [~2.37%]
  ├── scripts ✅
  │ ├── __init__.py ✅ (6L, 49C) [~0.01%]
  │ ├── download_tiger_data.py ✅ (140L, 3,405C) [~0.49%]
  │ ├── import_csv_to_database.py ✅ (119L, 3,355C) [~0.48%]
  │ ├── import_csv_to_sqlite.py ✅ (143L, 3,859C) [~0.55%]
  │ ├── import_qlib_to_csv.py ✅ (233L, 6,444C) [~0.92%]
  │ ├── import_qlib_to_database.py ✅ (81L, 2,326C) [~0.33%]
  │ ├── import_qlib_to_database_direct.py ✅ (228L, 6,344C) [~0.91%]
  │ ├── import_qlib_via_api.py ✅ (66L, 1,655C) [~0.24%]
  │ ├── init_database.py ✅ (182L, 7,115C) [~1.02%]
  │ ├── load_env.py ✅ (39L, 1,093C) [~0.16%]
  │ ├── setup_mysql.sh ✅ (45L, 1,163C) [~0.17%]
  │ ├── simple_api_test.py ✅ (25L, 443C) [~0.06%]
  │ ├── start_simple_web.py ✅ (173L, 4,987C) [~0.71%]
  │ ├── start_web_frontend.py ✅ (303L, 9,909C) [~1.42%]
  │ ├── subscribe_tiger_data.py ✅ (138L, 3,494C) [~0.50%]
  │ ├── test_api_server.py ✅ (139L, 3,863C) [~0.55%]
  │ └── upload_qlib_data_via_api.py ✅ (90L, 2,394C) [~0.34%]
  ├── simpletrade ✅
  │ ├── __pycache__ ❌
  │ ├── api ✅
  │ │ ├── __pycache__ ❌
  │ │ ├── routers ✅
  │ │ │ ├── __pycache__ ❌
  │ │ │ ├── wechat ✅
  │ │ │ │ ├── auth.py ✅ (186L, 6,652C) [~0.95%]
  │ │ │ │ └── data.py ✅ (163L, 6,202C) [~0.89%]
  │ │ │ ├── __init__.py ✅ (5L, 32C) [~0.00%]
  │ │ │ ├── analysis.py ✅ (307L, 11,207C) [~1.60%]
  │ │ │ ├── data.py ✅ (173L, 4,765C) [~0.68%]
  │ │ │ ├── misc.py ✅ (33L, 1,013C) [~0.15%]
  │ │ │ └── strategies.py ✅ (351L, 12,675C) [~1.81%]
  │ │ ├── schemas ✅
  │ │ │ ├── __pycache__ ❌
  │ │ │ ├── __init__.py ✅ (5L, 37C) [~0.01%]
  │ │ │ ├── backtest.py ✅ (97L, 3,637C) [~0.52%]
  │ │ │ ├── common.py ✅ (65L, 1,805C) [~0.26%]
  │ │ │ └── strategy.py ✅ (102L, 2,412C) [~0.35%]
  │ │ ├── wechat ✅
  │ │ │ ├── __pycache__ ❌
  │ │ │ ├── __init__.py ✅ (9L, 133C) [~0.02%]
  │ │ │ ├── auth.py ✅ (166L, 5,097C) [~0.73%]
  │ │ │ └── data.py ✅ (227L, 6,813C) [~0.98%]
  │ │ ├── __init__.py ✅ (2L, 29C) [~0.00%]
  │ │ ├── deps.py ✅ (25L, 697C) [~0.10%]
  │ │ ├── main.py ✅ (126L, 3,346C) [~0.48%]
  │ ├── apps ✅
  │ │ ├── __pycache__ ❌
  │ │ ├── st_analysis ✅
  │ │ │ ├── __pycache__ ❌
  │ │ │ ├── api ✅
  │ │ │ │ ├── __pycache__ ❌
  │ │ │ │ ├── __init__.py ✅ (8L, 77C) [~0.01%]
  │ │ │ │ └── routes.py ✅ (141L, 3,994C) [~0.57%]
  │ │ │ ├── commands ✅
  │ │ │ │ ├── __pycache__ ❌
  │ │ │ │ ├── __init__.py ✅ (8L, 118C) [~0.02%]
  │ │ │ │ └── processor.py ✅ (188L, 5,987C) [~0.86%]
  │ │ │ ├── __init__.py ✅ (23L, 434C) [~0.06%]
  │ │ │ └── engine.py ✅ (228L, 7,641C) [~1.09%]
  │ │ ├── st_backtest ✅
  │ │ │ ├── __pycache__ ❌
  │ │ │ ├── ui ✅
  │ │ │ │ ├── __pycache__ ❌
  │ │ │ │ └── __init__.py ✅ (13L, 202C) [~0.03%]
  │ │ │ ├── __init__.py ✅ (24L, 486C) [~0.07%]
  │ │ │ ├── engine.py ✅ (248L, 7,214C) [~1.03%]
  │ │ │ └── service.py ✅ (464L, 16,524C) [~2.37%]
  │ │ ├── st_datamanager ✅
  │ │ │ ├── __pycache__ ❌
  │ │ │ ├── api ✅
  │ │ │ │ ├── __pycache__ ❌
  │ │ │ │ ├── __init__.py ✅ (8L, 86C) [~0.01%]
  │ │ │ │ └── routes.py ✅ (488L, 16,154C) [~2.31%]
  │ │ │ ├── commands ✅
  │ │ │ │ ├── __pycache__ ❌
  │ │ │ │ ├── __init__.py ✅ (8L, 99C) [~0.01%]
  │ │ │ │ └── processor.py ✅ (345L, 11,333C) [~1.62%]
  │ │ │ ├── importers ✅
  │ │ │ │ ├── __pycache__ ❌
  │ │ │ │ ├── __init__.py ✅ (19L, 324C) [~0.05%]
  │ │ │ │ ├── base_importer.py ✅ (70L, 1,732C) [~0.25%]
  │ │ │ │ ├── importer_factory.py ✅ (56L, 1,495C) [~0.21%]
  │ │ │ │ └── qlib_importer.py ✅ (428L, 18,258C) [~2.61%]
  │ │ │ ├── __init__.py ✅ (24L, 488C) [~0.07%]
  │ │ │ └── engine.py ✅ (477L, 15,842C) [~2.27%]
  │ │ ├── st_message ✅
  │ │ │ ├── __pycache__ ❌
  │ │ │ ├── __init__.py ✅ (28L, 591C) [~0.08%]
  │ │ │ ├── base.py ✅ (70L, 1,466C) [~0.21%]
  │ │ │ ├── engine.py ✅ (61L, 1,688C) [~0.24%]
  │ │ │ └── test.py ✅ (36L, 644C) [~0.09%]
  │ │ ├── st_trader ✅
  │ │ │ ├── __pycache__ ❌
  │ │ │ ├── __init__.py ✅ (24L, 460C) [~0.07%]
  │ │ │ ├── engine.py ✅ (102L, 2,564C) [~0.37%]
  │ │ │ └── widget.py ✅ (44L, 896C) [~0.13%]
  │ │ ├── __init__.py ✅ (6L, 47C) [~0.01%]
  │ │ └── README.md ✅ (190L, 4,377C) [~0.63%]
  │ ├── config ✅
  │ │ ├── __pycache__ ❌
  │ │ ├── database.py ✅ (56L, 1,288C) [~0.18%]
  │ │ ├── README.md ✅ (192L, 4,296C) [~0.62%]
  │ │ └── settings.py ✅ (103L, 3,807C) [~0.55%]
  │ ├── core ✅
  │ │ ├── __pycache__ ❌
  │ │ ├── __init__.py ✅ (6L, 50C) [~0.01%]
  │ │ ├── app.py ✅ (88L, 2,366C) [~0.34%]
  │ │ ├── config.py ✅ (244L, 7,427C) [~1.06%]
  │ │ ├── database.py ✅ (64L, 1,359C) [~0.19%]
  │ │ ├── engine.py ✅ (173L, 5,162C) [~0.74%]
  │ │ ├── initialization.py ✅ (216L, 10,008C) [~1.43%]
  │ │ ├── logging.py ✅ (148L, 4,023C) [~0.58%]
  │ │ ├── README.md ✅ (225L, 4,460C) [~0.64%]
  │ │ └── server.py ✅ (143L, 3,707C) [~0.53%]
  │ ├── models ✅
  │ │ ├── __pycache__ ❌
  │ │ ├── __init__.py ✅ (2L, 30C) [~0.00%]
  │ │ └── database.py ✅ (148L, 5,751C) [~0.82%]
  │ ├── services ✅
  │ │ ├── __pycache__ ❌
  │ │ ├── data_sync_service.py ✅ (730L, 31,570C) [~4.52%]
  │ │ ├── monitor_service.py ✅ (312L, 9,763C) [~1.40%]
  │ │ ├── README.md ✅ (242L, 4,344C) [~0.62%]
  │ │ └── strategy_service.py ✅ (496L, 16,926C) [~2.42%]
  │ ├── strategies ✅
  │ │ ├── __pycache__ ❌
  │ │ ├── __init__.py ✅ (196L, 5,268C) [~0.75%]
  │ │ └── DoubleMaStrategy.py ✅ (127L, 2,866C) [~0.41%]
  │ ├── vendors ✅
  │ │ ├── vnpy_tiger ✅
  │ │ │ ├── vnpy_tiger ✅
  │ │ │ │ ├── __pycache__ ❌
  │ │ │ │ ├── __init__.py ✅ (2L, 40C) [~0.01%]
  │ │ │ │ └── tiger_gateway.py ✅ (506L, 16,265C) [~2.33%]
  │ │ │ ├── vnpy_tiger.egg-info ✅
  │ │ │ │ ├── dependency_links.txt ✅ (2L, 1C) [~0.00%]
  │ │ │ │ ├── PKG-INFO ✅ (33L, 1,160C) [~0.17%]
  │ │ │ │ ├── requires.txt ✅ (3L, 15C) [~0.00%]
  │ │ │ │ ├── SOURCES.txt ✅ (9L, 238C) [~0.03%]
  │ │ │ │ └── top_level.txt ✅ (2L, 11C) [~0.00%]
  │ │ │ ├── __init__.py ✅ (0L, 0C) [~0.00%]
  │ │ │ ├── README.md ✅ (60L, 882C) [~0.13%]
  │ │ │ ├── requirements.txt ✅ (3L, 15C) [~0.00%]
  │ │ │ └── setup.py ✅ (34L, 1,196C) [~0.17%]
  │ │ └── __init__.py ✅ (0L, 0C) [~0.00%]
  │ ├── __init__.py ✅ (9L, 112C) [~0.02%]
  │ └── main.py ✅ (219L, 6,639C) [~0.95%]
  ├── simpletrade.egg-info ✅
  │ ├── dependency_links.txt ✅ (2L, 1C) [~0.00%]
  │ ├── PKG-INFO ✅ (14L, 288C) [~0.04%]
  │ ├── requires.txt ✅ (8L, 57C) [~0.01%]
  │ ├── SOURCES.txt ✅ (64L, 2,131C) [~0.31%]
  │ └── top_level.txt ✅ (3L, 20C) [~0.00%]
  ├── src ✅
  │ ├── components ✅
  │ │ └── MainLayout.vue ✅ (24L, 454C) [~0.06%]
  ├── test_data ❌
  │ ├── qlib_data ❌
  ├── tests ❌
  ├── ui ✅
  │ ├── ai_analysis ❌
  │ ├── analysis ❌
  │ ├── backtest ✅
  │ │ ├── .gitkeep ✅ (2L, 1C) [~0.00%]
  │ ├── common ✅
  │ │ ├── .gitkeep ✅ (2L, 1C) [~0.00%]
  │ ├── dashboard ✅
  │ │ ├── .gitkeep ✅ (2L, 1C) [~0.00%]
  │ ├── data ✅
  │ │ ├── .gitkeep ✅ (2L, 1C) [~0.00%]
  │ ├── js ✅
  │ │ └── load_sidebar.js ✅ (58L, 2,909C) [~0.42%]
  │ ├── models ❌
  │ ├── strategies ✅
  │ │ ├── .gitkeep ✅ (2L, 1C) [~0.00%]
  │ ├── trading ✅
  │ │ ├── .gitkeep ✅ (2L, 1C) [~0.00%]
  │ ├── wireframes ❌
  ├── web-frontend ✅
  │ ├── public ❌
  │ ├── src ✅
  │ │ ├── api ✅
  │ │ │ ├── analysis.js ✅ (24L, 404C) [~0.06%]
  │ │ │ ├── data.js ✅ (108L, 2,414C) [~0.35%]
  │ │ │ └── strategies.js ✅ (79L, 2,072C) [~0.30%]
  │ │ ├── components ✅
  │ │ │ ├── Breadcrumb.vue ✅ (70L, 1,509C) [~0.22%]
  │ │ │ ├── MainLayout.vue ✅ (128L, 3,524C) [~0.50%]
  │ │ │ └── Sidebar.vue ✅ (120L, 2,902C) [~0.42%]
  │ │ ├── router ✅
  │ │ │ └── index.js ✅ (53L, 1,349C) [~0.19%]
  │ │ ├── store ✅
  │ │ │ └── index.js ✅ (91L, 2,691C) [~0.39%]
  │ │ ├── views ✅
  │ │ │ ├── analysis ✅
  │ │ │ │ └── Charts.vue ✅ (173L, 4,869C) [~0.70%]
  │ │ │ ├── data ✅
  │ │ │ │ ├── Export.vue ✅ (208L, 6,550C) [~0.94%]
  │ │ │ │ └── Import.vue ✅ (156L, 4,478C) [~0.64%]
  │ │ │ ├── strategy ✅
  │ │ │ │ ├── Create.vue ✅ (202L, 7,501C) [~1.07%]
  │ │ │ │ └── Index.vue ✅ (209L, 6,526C) [~0.93%]
  │ │ │ ├── trading ✅
  │ │ │ │ ├── Index.vue ✅ (391L, 13,014C) [~1.86%]
  │ │ │ │ ├── Orders.vue ✅ (367L, 11,387C) [~1.63%]
  │ │ │ │ └── Positions.vue ✅ (398L, 12,198C) [~1.75%]
  │ │ │ ├── AIAnalysisView.vue ✅ (521L, 20,524C) [~2.94%]
  │ │ │ ├── CreateFromTemplateView.vue ✅ (187L, 5,366C) [~0.77%]
  │ │ │ ├── StrategyCenterView.vue ✅ (1,216L, 51,148C) [~7.32%]
  │ │ │ ├── StrategyDetailView.vue ✅ (181L, 5,904C) [~0.85%]
  │ │ │ ├── TradingCenterView.vue ✅ (325L, 11,959C) [~1.71%]
  │ │ │ └── UserCenterView.vue ✅ (429L, 16,597C) [~2.38%]
  │ │ ├── App.vue ✅ (51L, 778C) [~0.11%]
  │ │ └── main.js ✅ (19L, 381C) [~0.05%]
  │ ├── web-frontend ❌
  │ │ ├── src ❌
  │ │ │ ├── components ❌
  │ ├── babel.config.js ✅ (8L, 140C) [~0.02%]
  │ ├── README.md ✅ (65L, 875C) [~0.13%]
  │ └── vue.config.js ✅ (19L, 431C) [~0.06%]
  ├── .cursorignore ✅ (2L, 82C) [~0.01%]
  ├── .env.example ✅ (22L, 443C) [~0.06%]
  ├── .gitmodules ✅ (8L, 192C) [~0.03%]
  ├── docker-compose.yml ✅ (96L, 2,422C) [~0.35%]
  ├── docker-entrypoint.sh ✅ (17L, 310C) [~0.04%]
  ├── Dockerfile ✅ (138L, 3,848C) [~0.55%]
  ├── Dockerfile.arm64 ✅ (118L, 4,228C) [~0.61%]
  ├── Dockerfile.cn ✅ (217L, 7,937C) [~1.14%]
  ├── Dockerfile.debian11 ✅ (150L, 4,861C) [~0.70%]
  ├── Dockerfile.ubuntu ✅ (153L, 4,799C) [~0.69%]
  ├── one_click_start.sh ✅ (190L, 3,970C) [~0.57%]
  ├── README.md ✅ (335L, 6,294C) [~0.90%]
  ├── requirements.txt ✅ (26L, 331C) [~0.05%]
  ├── setup.py ✅ (28L, 475C) [~0.07%]
  ├── setup_env.sh ✅ (43L, 917C) [~0.13%]
  ├── start_docker.sh ✅ (154L, 4,700C) [~0.67%]
  ├── start_docker_arm64.sh ✅ (175L, 3,987C) [~0.57%]
  ├── start_docker_cn.sh ✅ (128L, 2,915C) [~0.42%]
  ├── start_docker_debian11.sh ✅ (127L, 3,024C) [~0.43%]
  ├── start_docker_ubuntu.sh ✅ (127L, 2,995C) [~0.43%]
```

**摘要统计（包含的项目）:**
*   文件: 170
*   行数: 22,529
*   字符数: 698,492 (~682.1 kB)

---

## 选定的文件内容

### `/simpletrade/README.md`
*(统计信息: 335 行, 6294 字符 [~0.90%])*
```markdown
# SimpleTrade

简单易用的个人量化交易平台，采用微信小程序/消息交互作为前端，支持策略交易、AI分析和实时监控等功能。

## 项目概述

SimpleTrade是一个为个人投资者设计的量化交易平台，旨在让普通个人用户也能轻松使用量化交易技术。项目直接使用vnpy源码作为基础，通过插件架构扩展功能。

## 主要特点

- 简单易用的交易界面
- 微信小程序和消息交互作为主要前端
- 策略管理与回测功能
- AI分析和决策支持
- 实时监控和通知
- 支持多种交易接口，包括IB和老虎证券

## 技术栈

- 后端: Python, vnpy框架 (标准库安装), FastAPI
- API: FastAPI
- 数据库: MySQL (主数据库), SQLite (本地测试)
- 前端: Vue 2.x, Element UI, ECharts, 微信小程序
- AI: Scikit-learn, PyTorch, OpenAI API
- **特殊组件**: 自定义 `vnpy_tiger` (存放于 `vendors/` 目录)

## 项目结构

```
simpletrade/
├── ai_context/            # AI协作上下文
├── docs/                  # 项目文档
├── examples/              # 示例代码
├── scripts/               # 脚本工具
├── simpletrade/           # 主要代码包
│   ├── api/               # API接口
│   │   ├── server.py      # API服务器
│   │   └── wechat/        # 微信小程序API
│   ├── apps/              # 应用模块
│   │   └── st_datamanager/ # 数据管理应用
│   ├── core/              # 核心功能
│   │   ├── data/          # 数据管理
│   │   ├── message/       # 消息处理
│   │   └── analysis/      # 数据分析
│   └── main.py            # 主程序入口
├── test_data/             # 测试数据目录
├── tests/                 # 测试代码
├── ui/                    # UI设计文件
├── vendors/               # 自定义/非pip安装的组件
│   └── vnpy_tiger/        # 自定义的老虎证券Gateway
├── web-frontend/          # Web前端
├── setup.py               # 包安装配置
└── README.md              # 项目说明
```

## 安装与配置

### 1. 克隆仓库

```bash
git clone https://github.com/yourusername/simpletrade.git
cd simpletrade
```

### 2. 创建Conda环境

```bash
conda create -n simpletrade python=3.10
conda activate simpletrade
```

### 3. 安装依赖

**重要**: 本项目采用混合依赖管理：
- vnpy 核心及官方插件通过 `pip` 安装。
- 自定义的 `vnpy_tiger` 网关位于 `vendors/vnpy_tiger` 目录，需要单独安装其依赖。

```bash
# 激活环境
conda activate simpletrade

# 推荐使用 pip 安装 vnpy 及其插件
# pip install vnpy vnpy_ctp vnpy_ib vnpy_tiger vnpy_datamanager vnpy_sqlite
# 安装 vnpy 核心及常用官方插件
pip install vnpy vnpy_ctp vnpy_ib vnpy_datamanager vnpy_sqlite # 注意：移除了 vnpy_tiger

# 安装 simpletrade 自身 (如果需要，或者在开发中使用)
# pip install -e .

# 安装其他项目依赖 (例如 FastAPI, Uvicorn)
pip install fastapi uvicorn[standard] pydantic[email]

# 安装 vnpy_tiger 的依赖 (主要是 tigeropen)
# 确保 tigeropen 已安装
pip install tigeropen
# 如果 vnpy_tiger 有 requirements.txt, 也可以安装它:
# pip install -r vendors/vnpy_tiger/requirements.txt

# 安装可能需要的额外依赖 (例如 TA-Lib)
# conda install -c conda-forge ta-lib # (示例，根据需要安装)

# 安装数据库相关依赖
pip install sqlalchemy pymysql
```

### 4. 设置数据库

#### MySQL 数据库设置

```bash
# 确保已安装 MySQL 并启动服务

# 运行数据库初始化脚本
bash scripts/setup_mysql.sh

# 或者手动创建数据库并初始化
# 1. 创建数据库
mysql -uroot -pCz159csa -e "CREATE DATABASE IF NOT EXISTS simpletrade DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

# 2. 初始化数据库表和示例数据
python scripts/init_database.py
```

数据库配置参数可以在 `simpletrade/config/settings.py` 文件中修改，或者通过环境变量设置。

#### 环境变量配置

项目提供了一个环境变量配置示例文件 `.env.example`，可以复制为 `.env` 并根据需要修改：

```bash
# 复制环境变量配置示例文件
cp .env.example .env

# 编辑环境变量配置文件
vim .env  # 或使用其他编辑器
```

#### 数据库配置参数

- `SIMPLETRADE_DB_USER`: 数据库用户名（默认："root"）
- `SIMPLETRADE_DB_PASSWORD`: 数据库密码（默认："Cz159csa"）
- `SIMPLETRADE_DB_HOST`: 数据库主机（默认："localhost"）
- `SIMPLETRADE_DB_PORT`: 数据库端口（默认："3306"）
- `SIMPLETRADE_DB_NAME`: 数据库名称（默认："simpletrade"）
- `SIMPLETRADE_DB_POOL_SIZE`: 连接池大小（默认：5）
- `SIMPLETRADE_DB_MAX_OVERFLOW`: 最大溢出连接数（默认：10）
- `SIMPLETRADE_DB_POOL_RECYCLE`: 连接回收时间（默认：3600秒）
- `SIMPLETRADE_DB_ECHO`: 是否显示SQL语句（默认：False）

#### API配置参数

- `SIMPLETRADE_API_HOST`: API服务器主机（默认："0.0.0.0"）
- `SIMPLETRADE_API_PORT`: API服务器端口（默认：8003）
- `SIMPLETRADE_API_DEBUG`: 是否启用调试模式（默认：True）

### 5. 运行示例

```bash
# 运行数据管理示例
python examples/data_management_example.py

# 运行API服务示例
python examples/api_example.py
```

### 6. 运行测试

```bash
# 安装pytest
pip install pytest

# 运行单元测试
pytest tests/unit

# 运行集成测试
pytest tests/integration
```

## 运行项目

确保您已按照"安装与配置"部分设置好环境。SimpleTrade 提供两种运行方式：使用 Docker 运行和本地开发模式运行。

### 方式一：使用 Docker 运行（推荐）

使用 Docker 运行是最简单的方式，可以一键启动所有服务，包括 MySQL 数据库、API 服务和前端服务。

#### 1. 启动所有服务

```bash
# 确保已安装 Docker 和 Docker Compose

# 给脚本添加执行权限
chmod +x start_docker.sh

# 运行启动脚本
./start_docker.sh
```

这个脚本会：
- 检查并创建 `.env` 文件（如果不存在）
- 构建并启动所有 Docker 容器
- 初始化 MySQL 数据库并添加示例数据

启动后，可以访问：
- API 文档：`http://localhost:8003/docs`
- 前端页面：`http://localhost:8080`
- MySQL 数据库：`localhost:3306`（用户名：root，密码：Cz159csa）

#### 2. 查看服务日志

```bash
# 查看所有服务的日志
docker-compose logs

# 查看特定服务的日志
docker-compose logs mysql  # MySQL 数据库日志
docker-compose logs api    # API 服务日志
docker-compose logs frontend  # 前端服务日志
```

#### 3. 停止服务

```bash
# 停止所有服务
docker-compose down
```

#### 4. 重置数据库

如果需要重置数据库，可以删除数据库卷：

```bash
# 停止所有服务
docker-compose down

# 删除数据库卷
docker volume rm simpletrade_mysql-data

# 重新启动服务
./start_docker.sh
```

更多关于 Docker 的信息，请参考 [Docker 开发指南](docs/docker_development_guide.md) 和 [MySQL 与 Docker 集成指南](docs/mysql_docker_guide.md)。

### 方式二：本地开发模式

如果您希望在本地进行开发，可以分别启动后端和前端服务。

#### 1. 启动后端 API 服务

在项目根目录下的**系统终端**中执行以下命令：

```bash
# 激活 Conda 环境
conda activate simpletrade

# 启动 Uvicorn 服务器 (监听 0.0.0.0:8003，带自动重载)
# 注意：必须在激活的 simpletrade 环境中运行
python -m uvicorn simpletrade.api.server:app --host 0.0.0.0 --port 8003 --reload
```

后端服务启动后，可以通过 `http://localhost:8003/docs` 访问 API 文档。

#### 2. 启动前端开发服务器

在项目根目录下的**另一个系统终端**中执行以下命令：

```bash
# 激活 Conda 环境 (如果需要 Node/npm，确保它们在此环境或系统路径中)
conda activate simpletrade

# 进入前端目录
cd web-frontend

# 安装依赖 (如果尚未安装)
npm install --legacy-peer-deps

# 启动开发服务器 (通常监听 localhost:8080 或类似端口)
npm run serve
```

前端服务启动后，可以通过 `http://localhost:8080` 访问前端页面。

**重要提示**:
- 两个服务都需要保持运行状态。
- 所有后端相关的操作（包括启动 uvicorn）**必须**在激活的 `simpletrade` Conda 环境中进行。
- 确保 MySQL 数据库已经启动并初始化。

## 开发指南

### 1. 环境设置

推荐使用Conda环境进行开发：

```bash
conda create -n simpletrade python=3.8
conda activate simpletrade

# 安装开发依赖
pip install pytest black isort
```

### 2. 代码规范

- 遵循PEP 8编码规范
- 使用类型注解
- 编写详细的文档字符串
- 编写单元测试

### 3. 提交规范

- 使用明确的提交信息
- 提交前运行测试
- 遵循分支管理策略

## 文档

详细文档请参阅`docs/`目录：

- [项目结构](docs/project_structure.md)
- [安装指南](docs/installation.md)
- [API参考](docs/api_reference.md)
- [功能需求文档](docs/functional_requirements.md)
- [技术规格文档](docs/technical_specification.md)
- [vnpy集成指南](docs/vnpy_integration_guide.md)
- [架构设计](docs/architecture_diagram.md)
- [老虎证券Gateway集成指南](docs/tiger_gateway_integration.md)
- [老虎证券Gateway使用指南](docs/tiger_gateway_usage.md)
- [Docker 开发指南](docs/docker_development_guide.md)
- [MySQL 与 Docker 集成指南](docs/mysql_docker_guide.md)

## 许可证

[待定]

```

### `/simpletrade/Dockerfile.cn`
*(统计信息: 217 行, 7937 字符 [~1.14%])*
```
# 使用多阶段构建
# 第一阶段：构建TA-Lib
FROM python:3.9-slim AS builder

# 设置环境变量，避免交互式提示并禁用官方源
ENV DEBIAN_FRONTEND=noninteractive \
    APT_LISTBUGS_FRONTEND=none \
    APT_LISTCHANGES_FRONTEND=none \
    DEBIAN_PRIORITY=critical \
    # 禁用官方源
    ACQUIRE_BY_HASH=yes \
    ACQUIRE_RETRIES=3 \
    ACQUIRE_CONNECT_TIMEOUT=30 \
    ACQUIRE_QUEUE_MTIME=60

# 完全禁用官方源，只使用阿里云镜像
RUN rm -rf /etc/apt/sources.list.d/* && \
    echo "deb https://mirrors.aliyun.com/debian/ bullseye main contrib non-free" > /etc/apt/sources.list && \
    echo "deb https://mirrors.aliyun.com/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list && \
    echo "deb https://mirrors.aliyun.com/debian-security bullseye-security main contrib non-free" >> /etc/apt/sources.list && \
    # 创建apt配置文件，禁用官方源
    mkdir -p /etc/apt/apt.conf.d && \
    echo 'Acquire::http::Proxy "DIRECT";' > /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::https::Proxy "DIRECT";' >> /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::http::Timeout "60";' >> /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::https::Timeout "60";' >> /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::http::ConnectionAttemptDelayMsec "250";' >> /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::https::ConnectionAttemptDelayMsec "250";' >> /etc/apt/apt.conf.d/99direct && \
    # 只安装wget，跳过gnupg
    apt-get update -o Acquire::AllowInsecureRepositories=true -o Acquire::AllowDowngradeToInsecureRepositories=true && \
    apt-get install -y --no-install-recommends wget

# 安装构建TA-Lib所需的依赖
RUN apt-get update \
    -o Acquire::http::Proxy="DIRECT" \
    -o Acquire::https::Proxy="DIRECT" \
    -o Acquire::http::AllowRedirect="false" \
    -o Acquire::https::AllowRedirect="false" \
    && apt-get install -y --no-install-recommends \
    build-essential \
    wget \
    && rm -rf /var/lib/apt/lists/*

# 下载并编译TA-Lib
WORKDIR /tmp

# 使用国内镜像下载TA-Lib
RUN echo "Downloading TA-Lib..." && \
    mkdir -p /tmp/talib && \
    cd /tmp/talib && \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://gitee.com/mirrors/ta-lib/raw/master/ta-lib-0.4.0-src.tar.gz || \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://mirrors.aliyun.com/gentoo/distfiles/ta-lib-0.4.0-src.tar.gz || \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://jztkft.dl.sourceforge.net/project/ta-lib/ta-lib/0.4.0/ta-lib-0.4.0-src.tar.gz || \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://versaweb.dl.sourceforge.net/project/ta-lib/ta-lib/0.4.0/ta-lib-0.4.0-src.tar.gz && \
    echo "Extracting TA-Lib..." && \
    tar -xzf ta-lib-0.4.0-src.tar.gz && \
    cd ta-lib/ && \
    echo "Configuring TA-Lib..." && \
    ./configure --prefix=/usr && \
    echo "Building TA-Lib..." && \
    make && \
    echo "Installing TA-Lib..." && \
    make install && \
    cd /tmp && \
    rm -rf talib

# 第二阶段：构建最终镜像
FROM python:3.9-slim

# 设置环境变量，避免交互式提示并禁用官方源
ENV DEBIAN_FRONTEND=noninteractive \
    APT_LISTBUGS_FRONTEND=none \
    APT_LISTCHANGES_FRONTEND=none \
    DEBIAN_PRIORITY=critical \
    # 禁用官方源
    ACQUIRE_BY_HASH=yes \
    ACQUIRE_RETRIES=3 \
    ACQUIRE_CONNECT_TIMEOUT=30 \
    ACQUIRE_QUEUE_MTIME=60

# 完全禁用官方源，只使用阿里云镜像
RUN rm -rf /etc/apt/sources.list.d/* && \
    echo "deb https://mirrors.aliyun.com/debian/ bullseye main contrib non-free" > /etc/apt/sources.list && \
    echo "deb https://mirrors.aliyun.com/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list && \
    echo "deb https://mirrors.aliyun.com/debian-security bullseye-security main contrib non-free" >> /etc/apt/sources.list && \
    # 创建apt配置文件，禁用官方源
    mkdir -p /etc/apt/apt.conf.d && \
    echo 'Acquire::http::Proxy "DIRECT";' > /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::https::Proxy "DIRECT";' >> /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::http::Timeout "60";' >> /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::https::Timeout "60";' >> /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::http::ConnectionAttemptDelayMsec "250";' >> /etc/apt/apt.conf.d/99direct && \
    echo 'Acquire::https::ConnectionAttemptDelayMsec "250";' >> /etc/apt/apt.conf.d/99direct && \
    # 只安装wget，跳过gnupg
    apt-get update -o Acquire::AllowInsecureRepositories=true -o Acquire::AllowDowngradeToInsecureRepositories=true && \
    apt-get install -y --no-install-recommends wget

# 安装系统依赖
RUN apt-get update \
    -o Acquire::http::Proxy="DIRECT" \
    -o Acquire::https::Proxy="DIRECT" \
    -o Acquire::http::AllowRedirect="false" \
    -o Acquire::https::AllowRedirect="false" \
    && apt-get install -y --no-install-recommends \
    gcc \
    g++ \
    git \
    libssl-dev \
    pkg-config \
    wget \
    curl \
    netcat-openbsd \
    vim \
    nano \
    htop \
    procps \
    iputils-ping \
    net-tools \
    telnet \
    dnsutils \
    lsof \
    unzip \
    && rm -rf /var/lib/apt/lists/*

# 从构建阶段复制TA-Lib库
COPY --from=builder /usr/lib/libta_lib* /usr/lib/
COPY --from=builder /usr/include/ta-lib/ /usr/include/ta-lib/

# 设置工作目录
WORKDIR /app

# 配置pip使用国内镜像
RUN mkdir -p ~/.pip && \
    echo "[global]" > ~/.pip/pip.conf && \
    echo "index-url = https://mirrors.aliyun.com/pypi/simple/" >> ~/.pip/pip.conf && \
    echo "trusted-host = mirrors.aliyun.com" >> ~/.pip/pip.conf && \
    # 备用源
    echo "extra-index-url = https://pypi.tuna.tsinghua.edu.cn/simple" >> ~/.pip/pip.conf && \
    echo "trusted-host = pypi.tuna.tsinghua.edu.cn" >> ~/.pip/pip.conf

# 安装Python依赖
RUN pip install --no-cache-dir --upgrade pip setuptools wheel

# 安装常用Python工具
RUN pip install --no-cache-dir \
    ipython \
    jupyter \
    notebook \
    pandas \
    numpy \
    matplotlib \
    seaborn \
    scikit-learn \
    statsmodels \
    pytest \
    black \
    flake8 \
    isort \
    mypy \
    pylint

# 安装TA-Lib Python包
RUN pip install --no-cache-dir ta-lib

# 安装vnpy核心
RUN echo "Installing vnpy..." && \
    pip install --no-cache-dir vnpy && \
    echo "Installing vnpy_cta_strategy..." && \
    pip install --no-cache-dir vnpy_cta_strategy && \
    echo "Installing vnpy_ctastrategy..." && \
    pip install --no-cache-dir vnpy_ctastrategy && \
    echo "Installing vnpy_datamanager..." && \
    pip install --no-cache-dir vnpy_datamanager && \
    echo "Installing vnpy_sqlite..." && \
    pip install --no-cache-dir vnpy_sqlite && \
    echo "Installing vnpy_rest..." && \
    pip install --no-cache-dir vnpy_rest && \
    echo "Installing vnpy_websocket..." && \
    pip install --no-cache-dir vnpy_websocket && \
    echo "Installing vnpy_csv..." && \
    pip install --no-cache-dir vnpy_csv && \
    echo "Installing vnpy_mysql..." && \
    pip install --no-cache-dir vnpy_mysql && \
    echo "Installing vnpy_ctp..." && \
    pip install --no-cache-dir vnpy_ctp || echo "Failed to install vnpy_ctp, continuing..." && \
    echo "Installing vnpy_ib..." && \
    pip install --no-cache-dir vnpy_ib || echo "Failed to install vnpy_ib, continuing..." && \
    echo "Installing vnpy_tushare..." && \
    pip install --no-cache-dir vnpy_tushare || echo "Failed to install vnpy_tushare, continuing..." && \
    echo "Installing vnpy_rqdata..." && \
    pip install --no-cache-dir vnpy_rqdata || echo "Failed to install vnpy_rqdata, continuing..." && \
    echo "Installing vnpy_jotdx..." && \
    pip install --no-cache-dir vnpy_jotdx || echo "Failed to install vnpy_jotdx, continuing..."

# 创建常用目录
RUN mkdir -p /app/data /app/logs /app/configs /app/notebooks

# 复制启动脚本
COPY docker_scripts/ /app/docker_scripts/
RUN chmod +x /app/docker_scripts/*.sh

# 安装应用依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 验证vnpy安装
RUN echo "Verifying VeighNa installation..." && \
    python -c "import vnpy; print(f'VeighNa version: {vnpy.__version__}')" && \
    python -c "from vnpy.trader.engine import MainEngine; print('VeighNa MainEngine imported successfully!')" || \
    echo "VeighNa installation verification failed but continuing anyway"

# 复制应用代码
COPY . .

# 设置环境变量
ENV PYTHONPATH=/app

```

### `/simpletrade/one_click_start.sh`
*(统计信息: 190 行, 3970 字符 [~0.57%])*
```bash
#!/bin/bash

# SimpleTrade 一键启动脚本
# 这个脚本会检查Docker是否安装，如果没有安装则提示安装
# 然后启动所有服务

# 设置颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_message() {
  echo -e "${BLUE}[SimpleTrade]${NC} $1"
}

print_success() {
  echo -e "${GREEN}[成功]${NC} $1"
}

print_warning() {
  echo -e "${YELLOW}[警告]${NC} $1"
}

print_error() {
  echo -e "${RED}[错误]${NC} $1"
}

# 检查Docker是否安装
check_docker() {
  print_message "检查Docker是否安装..."
  if ! command -v docker &> /dev/null; then
    print_error "Docker未安装。请先安装Docker。"
    print_message "您可以访问 https://docs.docker.com/get-docker/ 获取安装指南。"
    exit 1
  fi
  print_success "Docker已安装。"

  print_message "检查Docker Compose是否安装..."
  if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
    print_error "Docker Compose未安装。请先安装Docker Compose。"
    print_message "您可以访问 https://docs.docker.com/compose/install/ 获取安装指南。"
    exit 1
  fi
  print_success "Docker Compose已安装。"
}

# 检查是否有足够的磁盘空间
check_disk_space() {
  print_message "检查磁盘空间..."

  # 获取当前目录所在磁盘的可用空间（以KB为单位）
  available_space=$(df -k . | awk 'NR==2 {print $4}')

  # 转换为GB
  available_space_gb=$(echo "scale=2; $available_space / 1024 / 1024" | bc)

  # 检查是否有至少5GB的可用空间
  if (( $(echo "$available_space_gb < 5" | bc -l) )); then
    print_warning "磁盘空间不足。建议至少有5GB的可用空间，当前只有${available_space_gb}GB。"
    read -p "是否继续？(y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      print_message "操作已取消。"
      exit 0
    fi
  else
    print_success "磁盘空间充足，当前有${available_space_gb}GB可用空间。"
  fi
}

# 创建.env文件（如果不存在）
create_env_file() {
  if [ ! -f .env ]; then
    print_message "创建.env文件..."
    cp .env.example .env 2>/dev/null || {
      cat > .env << EOF
SIMPLETRADE_DB_USER=root
SIMPLETRADE_DB_PASSWORD=Cz159csa
SIMPLETRADE_DB_NAME=simpletrade
SIMPLETRADE_API_PORT=8003
EOF
    }
    print_success ".env文件已创建。"
  else
    print_message ".env文件已存在，跳过创建。"
  fi
}

# 创建必要的目录
create_directories() {
  print_message "创建必要的目录..."
  mkdir -p data logs configs notebooks mysql-init docker_scripts
  print_success "目录已创建。"
}

# 启动服务
start_services() {
  print_message "启动SimpleTrade服务..."

  # 检查是否有正在运行的容器
  if docker ps | grep -q "simpletrade"; then
    print_warning "检测到SimpleTrade容器已经在运行。"
    read -p "是否停止现有容器并重新启动？(y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      print_message "停止现有容器..."
      docker-compose down
    else
      print_message "操作已取消。"
      exit 0
    fi
  fi

  # 启动服务
  print_message "构建并启动服务..."
  docker-compose up -d

  # 检查服务是否成功启动
  if [ $? -eq 0 ]; then
    print_success "SimpleTrade服务已成功启动！"
  else
    print_error "启动服务时出错。请检查日志获取详细信息。"
    exit 1
  fi
}

# 显示服务信息
show_service_info() {
  print_message "服务信息："
  echo "--------------------------------------"
  echo "API服务: http://localhost:8003"
  echo "API文档: http://localhost:8003/docs"
  echo "前端界面: http://localhost:8080"
  echo "Jupyter Notebook: http://localhost:8888 (用于数据分析和策略开发)"
  echo "MySQL数据库: localhost:3306"
  echo "  - 用户名: root"
  echo "  - 密码: Cz159csa (可在.env文件中修改)"
  echo "  - 数据库名: simpletrade"
  echo "--------------------------------------"
  echo
  echo "您可以使用以下命令查看容器状态："
  echo "  docker-compose ps"
  echo
  echo "您可以使用以下命令查看容器日志："
  echo "  docker-compose logs api"
  echo "  docker-compose logs frontend"
  echo "  docker-compose logs mysql"
  echo "  docker-compose logs jupyter"
  echo
  echo "您可以使用以下命令停止服务："
  echo "  docker-compose down"
  echo "--------------------------------------"
}

# 主函数
main() {
  echo "========================================"
  echo "     SimpleTrade 一键启动脚本"
  echo "========================================"
  echo

  # 检查Docker
  check_docker

  # 检查磁盘空间
  check_disk_space

  # 创建.env文件
  create_env_file

  # 创建必要的目录
  create_directories

  # 启动服务
  start_services

  # 显示服务信息
  show_service_info

  echo
  print_success "SimpleTrade已成功启动！"
  echo "========================================"
}

# 执行主函数
main

```

### `/simpletrade/start_docker_arm64.sh`
*(统计信息: 175 行, 3987 字符 [~0.57%])*
```bash
#!/bin/bash

# 设置颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_message() {
  echo -e "${BLUE}[SimpleTrade]${NC} $1"
}

print_success() {
  echo -e "${GREEN}[成功]${NC} $1"
}

print_warning() {
  echo -e "${YELLOW}[警告]${NC} $1"
}

print_error() {
  echo -e "${RED}[错误]${NC} $1"
}

# 确保脚本在项目根目录运行
cd "$(dirname "$0")"

# 如果.env文件不存在，复制.env.example
if [ ! -f .env ]; then
  print_message "创建.env文件..."
  cp .env.example .env 2>/dev/null || {
    cat > .env << EOF
SIMPLETRADE_DB_USER=root
SIMPLETRADE_DB_PASSWORD=Cz159csa
SIMPLETRADE_DB_NAME=simpletrade
SIMPLETRADE_API_PORT=8003
EOF
  }
  print_success ".env文件已创建。"
else
  print_message ".env文件已存在，跳过创建。"
fi

# 创建必要的目录
print_message "创建必要的目录..."
mkdir -p data logs configs notebooks mysql-init docker_scripts
print_success "目录已创建。"

# 检查是否有正在运行的容器
if docker ps | grep -q "simpletrade"; then
  print_warning "检测到SimpleTrade容器已经在运行。"
  read -p "是否停止现有容器并重新启动？(y/n) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    print_message "停止现有容器..."
    docker-compose -f docker-compose.arm64.yml down
  else
    print_message "操作已取消。"
    exit 0
  fi
fi

# 清理Docker缓存
print_message "清理Docker缓存..."
docker system prune -f > /dev/null 2>&1

# 启动服务
print_message "使用ARM64优化的镜像构建并启动服务..."

# 先启动MySQL服务
print_message "启动MySQL服务..."
docker-compose -f docker-compose.arm64.yml up -d mysql

# 等待MySQL服务启动
print_message "等待MySQL服务启动..."
sleep 10

# 构建并启动前端服务
print_message "启动前端服务..."
docker-compose -f docker-compose.arm64.yml up -d frontend

# 检查是否需要强制重新构建
if [ "$1" = "--rebuild" ]; then
  REBUILD="--no-cache"
  print_message "强制重新构建所有镜像..."
else
  REBUILD=""
  print_message "使用缓存构建镜像（如需强制重新构建，请使用 --rebuild 选项）..."
fi

# 构建并启动API服务
print_message "构建并启动API服务..."
docker-compose -f docker-compose.arm64.yml build $REBUILD api
if [ $? -eq 0 ]; then
  docker-compose -f docker-compose.arm64.yml up -d api
  print_success "API服务启动成功。"
else
  print_warning "API服务构建失败，尝试使用现有镜像启动..."
  docker-compose -f docker-compose.arm64.yml up -d api
fi

# 构建并启动Jupyter服务
print_message "构建并启动Jupyter服务..."
docker-compose -f docker-compose.arm64.yml build $REBUILD jupyter
if [ $? -eq 0 ]; then
  docker-compose -f docker-compose.arm64.yml up -d jupyter
  print_success "Jupyter服务启动成功。"
else
  print_warning "Jupyter服务构建失败，尝试使用现有镜像启动..."
  docker-compose -f docker-compose.arm64.yml up -d jupyter
fi

# 检查服务是否成功启动
print_message "检查服务状态..."

# 检查MySQL服务
if docker ps | grep -q "simpletrade-mysql"; then
  print_success "MySQL服务运行正常。"
else
  print_error "MySQL服务启动失败。"
  exit 1
fi

# 检查API服务
if docker ps | grep -q "simpletrade-api"; then
  print_success "API服务运行正常。"
else
  print_warning "API服务启动失败，但继续运行其他服务。"
fi

# 检查前端服务
if docker ps | grep -q "simpletrade-frontend"; then
  print_success "前端服务运行正常。"
else
  print_warning "前端服务启动失败，但继续运行其他服务。"
fi

# 检查Jupyter服务
if docker ps | grep -q "simpletrade-jupyter"; then
  print_success "Jupyter服务运行正常。"
else
  print_warning "Jupyter服务启动失败，但继续运行其他服务。"
fi

# 显示服务信息
print_message "服务信息："
echo "--------------------------------------"
echo "API服务: http://localhost:8003"
echo "API文档: http://localhost:8003/docs"
echo "前端界面: http://localhost:8080"
echo "Jupyter Notebook: http://localhost:8888 (用于数据分析和策略开发)"
echo "MySQL数据库: localhost:3306"
echo "  - 用户名: root"
echo "  - 密码: Cz159csa (可在.env文件中修改)"
echo "  - 数据库名: simpletrade"
echo "--------------------------------------"
echo
echo "您可以使用以下命令查看容器状态："
echo "  docker-compose -f docker-compose.arm64.yml ps"
echo
echo "您可以使用以下命令查看容器日志："
echo "  docker-compose -f docker-compose.arm64.yml logs api"
echo "  docker-compose -f docker-compose.arm64.yml logs frontend"
echo "  docker-compose -f docker-compose.arm64.yml logs mysql"
echo "  docker-compose -f docker-compose.arm64.yml logs jupyter"
echo
echo "您可以使用以下命令停止服务："
echo "  docker-compose -f docker-compose.arm64.yml down"
echo
echo "您可以使用以下命令重新构建所有镜像（不使用缓存）："
echo "  ./start_docker_arm64.sh --rebuild"
echo "--------------------------------------"

```

### `/simpletrade/start_docker.sh`
*(统计信息: 154 行, 4700 字符 [~0.67%])*
```bash
#!/bin/bash

# =================================================================
# SimpleTrade Docker 启动脚本
# 功能：
# 1. 检查容器是否已经在运行，避免重复启动
# 2. 清理悬空镜像和未使用的资源，减少磁盘空间占用
# 3. 启动 MySQL、API 和前端服务
# 4. 显示常用操作命令
# =================================================================

# 确保脚本在项目根目录运行
cd "$(dirname "$0")"

# 如果 .env 文件不存在，复制 .env.example
if [ ! -f .env ]; then
  echo "Creating .env file from .env.example"
  cp .env.example .env
fi

# 打印启动信息
echo "=================================================================="
echo "                 SimpleTrade Docker 启动脚本                "
echo "=================================================================="

# 检查容器是否已经在运行
# 这可以避免重复启动容器，导致资源浪费
if docker ps | grep -q "simpletrade-api\|simpletrade-mysql\|simpletrade-frontend"; then
  echo "警告：SimpleTrade 容器已经在运行中。"
  echo "您可以使用以下命令查看正在运行的容器："
  echo "  docker ps"
  echo ""
  echo "如果您想停止现有容器并重新启动，请先运行："
  echo "  docker-compose down"
  echo ""
  read -p "是否停止现有容器并重新启动？(y/n) " -n 1 -r
  echo ""
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "停止现有容器..."
    docker-compose down
  else
    echo "操作已取消。"
    exit 0
  fi
fi

# 清理悬空镜像和未使用的资源
# 这可以减少磁盘空间占用，避免磁盘空间不足
echo "清理悬空镜像和未使用的资源..."
echo "注意：这将删除未使用的镜像、容器和网络，但不会删除数据卷。"
read -p "是否继续？(y/n) " -n 1 -r
echo ""
if [[ $REPLY =~ ^[Yy]$ ]]; then
  # 清理悬空镜像
  echo "清理悬空镜像..."
  docker image prune -f

  # 清理未使用的容器
  echo "清理未使用的容器..."
  docker container prune -f

  # 清理未使用的网络
  echo "清理未使用的网络..."
  docker network prune -f

  echo "清理完成！"
else
  echo "跳过清理步骤。"
fi

echo "正在启动 SimpleTrade 的 Docker 容器，包括："
echo "- MySQL 数据库容器 (simpletrade-mysql)"
echo "- API 服务容器 (simpletrade-api)"
echo "- 前端服务容器 (simpletrade-frontend)"
echo ""
echo "启动完成后，可以访问："
echo "- API 文档：http://localhost:8003/docs"
echo "- 前端页面：http://localhost:8080"
echo "- MySQL 数据库：localhost:3306 (用户名：root，密码：Cz159csa)"
echo ""
echo "按 Ctrl+C 可以停止容器运行。"
echo "建议使用 docker-compose down 命令完全停止容器。"
echo "=================================================================="
echo ""

# 创建一个函数来打印常用操作
print_common_operations() {
  echo ""
  echo "=================================================================="
  echo "                   Docker 容器常用操作                   "
  echo "=================================================================="
  echo "1. 进入容器："
  echo "   docker exec -it simpletrade-mysql bash     # 进入 MySQL 容器"
  echo "   docker exec -it simpletrade-api bash       # 进入 API 容器"
  echo "   docker exec -it simpletrade-frontend bash  # 进入前端容器"
  echo ""
  echo "2. 连接到 MySQL 数据库："
  echo "   docker exec -it simpletrade-mysql mysql -uroot -pCz159csa simpletrade"
  echo ""
  echo "3. 查看容器日志："
  echo "   docker-compose logs mysql     # 查看 MySQL 日志"
  echo "   docker-compose logs api       # 查看 API 日志"
  echo "   docker-compose logs frontend  # 查看前端日志"
  echo "   docker-compose logs -f api    # 实时查看 API 日志"
  echo ""
  echo "4. 重启容器："
  echo "   docker restart simpletrade-mysql    # 重启 MySQL 容器"
  echo "   docker restart simpletrade-api      # 重启 API 容器"
  echo "   docker restart simpletrade-frontend # 重启前端容器"
  echo ""
  echo "5. 停止和重置："
  echo "   docker-compose down                      # 停止所有容器"
  echo "   docker volume rm simpletrade_mysql-data  # 删除数据库卷"
  echo "   ./start_docker.sh                        # 重新启动容器"
  echo ""
  echo "6. 在容器中执行命令："
  echo "   docker exec -it simpletrade-mysql mysql -uroot -pCz159csa -e \"SHOW TABLES FROM simpletrade;\""
  echo ""
  echo "7. 备份和恢复数据："
  echo "   docker exec simpletrade-mysql sh -c 'exec mysqldump -uroot -pCz159csa simpletrade' > backup.sql  # 备份"
  echo "   cat backup.sql | docker exec -i simpletrade-mysql mysql -uroot -pCz159csa simpletrade            # 恢复"
  echo ""
  echo "8. 清理 Docker 资源："
  echo "   docker system prune -f                   # 清理所有未使用的资源"
  echo "   docker image prune -a                    # 清理所有未使用的镜像"
  echo "   docker system df                         # 查看 Docker 磁盘使用情况"
  echo "=================================================================="
  echo ""
}

# 启动 Docker 容器
# 尝试使用 docker-compose 命令
if command -v docker-compose &> /dev/null; then
  # 使用 trap 来捕获 SIGINT 信号（Ctrl+C）
  trap 'print_common_operations' SIGINT
  # 使用 docker-compose up 启动容器
  # --build: 在启动容器前重新构建镜像
  # 不使用 -d 参数，以便在终端中显示日志
  docker-compose up --build
  # 如果正常退出（不是通过 Ctrl+C），也打印常用操作
  print_common_operations
# 如果不可用，尝试使用 docker compose 命令
elif command -v docker &> /dev/null; then
  trap 'print_common_operations' SIGINT
  # 使用 docker compose 命令（新版 Docker 的命令格式）
  docker compose build
  docker compose up
  print_common_operations
else
  echo "Error: Neither docker-compose nor docker compose commands are available."
  echo "Please install Docker and Docker Compose first."
  exit 1
fi

```

### `/simpletrade/Dockerfile.ubuntu`
*(统计信息: 153 行, 4799 字符 [~0.69%])*
```
# 使用Ubuntu 20.04作为基础镜像
FROM ubuntu:20.04

# 设置环境变量，避免交互式提示
ENV DEBIAN_FRONTEND=noninteractive \
    TZ=Asia/Shanghai \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

# 设置工作目录
WORKDIR /app

# 先使用原始源安装ca-certificates
RUN apt-get update && \
    apt-get install -y --no-install-recommends ca-certificates && \
    rm -rf /var/lib/apt/lists/*

# 然后使用清华镜像源（使用HTTP而不是HTTPS）
RUN echo "deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse" > /etc/apt/sources.list && \
    echo "deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse" >> /etc/apt/sources.list && \
    echo "deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse" >> /etc/apt/sources.list && \
    echo "deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse" >> /etc/apt/sources.list

# 安装系统依赖
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    build-essential \
    gcc \
    g++ \
    git \
    libssl-dev \
    pkg-config \
    wget \
    curl \
    netcat \
    vim \
    nano \
    htop \
    procps \
    iputils-ping \
    net-tools \
    telnet \
    dnsutils \
    lsof \
    unzip \
    python3 \
    python3-pip \
    python3-dev \
    python3-setuptools \
    python3-wheel \
    && ln -sf /usr/bin/python3 /usr/bin/python \
    && ln -sf /usr/bin/pip3 /usr/bin/pip \
    && rm -rf /var/lib/apt/lists/*

# 安装TA-Lib
RUN cd /tmp && \
    echo "Downloading TA-Lib..." && \
    wget -q -O ta-lib-0.4.0-src.tar.gz http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz && \
    echo "Extracting TA-Lib..." && \
    tar -xzf ta-lib-0.4.0-src.tar.gz && \
    cd ta-lib/ && \
    echo "Configuring TA-Lib..." && \
    ./configure --prefix=/usr && \
    echo "Building TA-Lib..." && \
    make && \
    echo "Installing TA-Lib..." && \
    make install && \
    cd /tmp && \
    rm -rf ta-lib-0.4.0-src.tar.gz ta-lib/

# 配置pip使用清华镜像源（使用HTTP而不是HTTPS）
RUN mkdir -p ~/.pip && \
    echo "[global]" > ~/.pip/pip.conf && \
    echo "index-url = http://pypi.tuna.tsinghua.edu.cn/simple" >> ~/.pip/pip.conf && \
    echo "trusted-host = pypi.tuna.tsinghua.edu.cn" >> ~/.pip/pip.conf

# 升级pip
RUN pip install --no-cache-dir --upgrade pip setuptools wheel

# 安装常用Python工具
RUN pip install --no-cache-dir \
    ipython \
    jupyter \
    notebook \
    pandas \
    numpy \
    matplotlib \
    seaborn \
    scikit-learn \
    statsmodels \
    pytest \
    black \
    flake8 \
    isort \
    mypy \
    pylint

# 安装TA-Lib Python包
RUN pip install --no-cache-dir ta-lib

# 安装vnpy核心
RUN echo "Installing vnpy..." && \
    pip install --no-cache-dir vnpy && \
    echo "Installing vnpy_cta_strategy..." && \
    pip install --no-cache-dir vnpy_cta_strategy && \
    echo "Installing vnpy_ctastrategy..." && \
    pip install --no-cache-dir vnpy_ctastrategy && \
    echo "Installing vnpy_datamanager..." && \
    pip install --no-cache-dir vnpy_datamanager && \
    echo "Installing vnpy_sqlite..." && \
    pip install --no-cache-dir vnpy_sqlite && \
    echo "Installing vnpy_rest..." && \
    pip install --no-cache-dir vnpy_rest && \
    echo "Installing vnpy_websocket..." && \
    pip install --no-cache-dir vnpy_websocket && \
    echo "Installing vnpy_csv..." && \
    pip install --no-cache-dir vnpy_csv && \
    echo "Installing vnpy_mysql..." && \
    pip install --no-cache-dir vnpy_mysql && \
    echo "Installing vnpy_ctp..." && \
    pip install --no-cache-dir vnpy_ctp || echo "Failed to install vnpy_ctp, continuing..." && \
    echo "Installing vnpy_ib..." && \
    pip install --no-cache-dir vnpy_ib || echo "Failed to install vnpy_ib, continuing..." && \
    echo "Installing vnpy_tushare..." && \
    pip install --no-cache-dir vnpy_tushare || echo "Failed to install vnpy_tushare, continuing..." && \
    echo "Installing vnpy_rqdata..." && \
    pip install --no-cache-dir vnpy_rqdata || echo "Failed to install vnpy_rqdata, continuing..." && \
    echo "Installing vnpy_jotdx..." && \
    pip install --no-cache-dir vnpy_jotdx || echo "Failed to install vnpy_jotdx, continuing..."

# 创建常用目录
RUN mkdir -p /app/data /app/logs /app/configs /app/notebooks

# 复制启动脚本
COPY docker_scripts/ /app/docker_scripts/
RUN chmod +x /app/docker_scripts/*.sh

# 安装应用依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 验证vnpy安装
RUN echo "Verifying VeighNa installation..." && \
    python -c "import vnpy; print(f'VeighNa version: {vnpy.__version__}')" && \
    python -c "from vnpy.trader.engine import MainEngine; print('VeighNa MainEngine imported successfully!')" || \
    echo "VeighNa installation verification failed but continuing anyway"

# 复制应用代码
COPY . .

# 设置环境变量
ENV PYTHONPATH=/app

```

### `/simpletrade/Dockerfile.debian11`
*(统计信息: 150 行, 4861 字符 [~0.70%])*
```
# 使用Debian 11 (Bullseye)作为基础镜像
FROM debian:bullseye-slim

# 设置环境变量，避免交互式提示
ENV DEBIAN_FRONTEND=noninteractive \
    TZ=Asia/Shanghai \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

# 设置工作目录
WORKDIR /app

# 使用清华镜像源
RUN echo "deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free" > /etc/apt/sources.list && \
    echo "deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list && \
    echo "deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free" >> /etc/apt/sources.list && \
    echo "deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free" >> /etc/apt/sources.list

# 安装系统依赖
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    build-essential \
    gcc \
    g++ \
    git \
    libssl-dev \
    pkg-config \
    wget \
    curl \
    netcat-openbsd \
    vim \
    nano \
    htop \
    procps \
    iputils-ping \
    net-tools \
    telnet \
    dnsutils \
    lsof \
    unzip \
    python3 \
    python3-pip \
    python3-dev \
    python3-setuptools \
    python3-wheel \
    && ln -sf /usr/bin/python3 /usr/bin/python \
    && ln -sf /usr/bin/pip3 /usr/bin/pip \
    && rm -rf /var/lib/apt/lists/*

# 安装TA-Lib
RUN cd /tmp && \
    echo "Downloading TA-Lib..." && \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://gitee.com/mirrors/ta-lib/raw/master/ta-lib-0.4.0-src.tar.gz || \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://mirrors.tuna.tsinghua.edu.cn/gentoo/distfiles/ta-lib-0.4.0-src.tar.gz || \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://jztkft.dl.sourceforge.net/project/ta-lib/ta-lib/0.4.0/ta-lib-0.4.0-src.tar.gz && \
    echo "Extracting TA-Lib..." && \
    tar -xzf ta-lib-0.4.0-src.tar.gz && \
    cd ta-lib/ && \
    echo "Configuring TA-Lib..." && \
    ./configure --prefix=/usr && \
    echo "Building TA-Lib..." && \
    make && \
    echo "Installing TA-Lib..." && \
    make install && \
    cd /tmp && \
    rm -rf ta-lib-0.4.0-src.tar.gz ta-lib/

# 配置pip使用清华镜像源
RUN mkdir -p ~/.pip && \
    echo "[global]" > ~/.pip/pip.conf && \
    echo "index-url = https://pypi.tuna.tsinghua.edu.cn/simple" >> ~/.pip/pip.conf && \
    echo "trusted-host = pypi.tuna.tsinghua.edu.cn" >> ~/.pip/pip.conf

# 升级pip
RUN pip install --no-cache-dir --upgrade pip setuptools wheel

# 安装常用Python工具
RUN pip install --no-cache-dir \
    ipython \
    jupyter \
    notebook \
    pandas \
    numpy \
    matplotlib \
    seaborn \
    scikit-learn \
    statsmodels \
    pytest \
    black \
    flake8 \
    isort \
    mypy \
    pylint

# 安装TA-Lib Python包
RUN pip install --no-cache-dir ta-lib

# 安装vnpy核心
RUN echo "Installing vnpy..." && \
    pip install --no-cache-dir vnpy && \
    echo "Installing vnpy_cta_strategy..." && \
    pip install --no-cache-dir vnpy_cta_strategy && \
    echo "Installing vnpy_ctastrategy..." && \
    pip install --no-cache-dir vnpy_ctastrategy && \
    echo "Installing vnpy_datamanager..." && \
    pip install --no-cache-dir vnpy_datamanager && \
    echo "Installing vnpy_sqlite..." && \
    pip install --no-cache-dir vnpy_sqlite && \
    echo "Installing vnpy_rest..." && \
    pip install --no-cache-dir vnpy_rest && \
    echo "Installing vnpy_websocket..." && \
    pip install --no-cache-dir vnpy_websocket && \
    echo "Installing vnpy_csv..." && \
    pip install --no-cache-dir vnpy_csv && \
    echo "Installing vnpy_mysql..." && \
    pip install --no-cache-dir vnpy_mysql && \
    echo "Installing vnpy_ctp..." && \
    pip install --no-cache-dir vnpy_ctp || echo "Failed to install vnpy_ctp, continuing..." && \
    echo "Installing vnpy_ib..." && \
    pip install --no-cache-dir vnpy_ib || echo "Failed to install vnpy_ib, continuing..." && \
    echo "Installing vnpy_tushare..." && \
    pip install --no-cache-dir vnpy_tushare || echo "Failed to install vnpy_tushare, continuing..." && \
    echo "Installing vnpy_rqdata..." && \
    pip install --no-cache-dir vnpy_rqdata || echo "Failed to install vnpy_rqdata, continuing..." && \
    echo "Installing vnpy_jotdx..." && \
    pip install --no-cache-dir vnpy_jotdx || echo "Failed to install vnpy_jotdx, continuing..."

# 创建常用目录
RUN mkdir -p /app/data /app/logs /app/configs /app/notebooks

# 复制启动脚本
COPY docker_scripts/ /app/docker_scripts/
RUN chmod +x /app/docker_scripts/*.sh

# 安装应用依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 验证vnpy安装
RUN echo "Verifying VeighNa installation..." && \
    python -c "import vnpy; print(f'VeighNa version: {vnpy.__version__}')" && \
    python -c "from vnpy.trader.engine import MainEngine; print('VeighNa MainEngine imported successfully!')" || \
    echo "VeighNa installation verification failed but continuing anyway"

# 复制应用代码
COPY . .

# 设置环境变量
ENV PYTHONPATH=/app

```

### `/simpletrade/Dockerfile`
*(统计信息: 138 行, 3848 字符 [~0.55%])*
```dockerfile
FROM python:3.9-slim

# 设置工作目录
WORKDIR /app

# 使用国内apt镜像
# 完全替换所有源为国内镜像
RUN echo "Configuring apt mirrors..." && \
    # 备份原始源配置
    if [ -f /etc/apt/sources.list ]; then \
        cp /etc/apt/sources.list /etc/apt/sources.list.bak; \
    fi && \
    # 清空所有源配置
    echo "" > /etc/apt/sources.list && \
    # 移除所有其他源配置
    rm -f /etc/apt/sources.list.d/*.list && \
    # 创建阿里云镜像源配置（速度更快）
    echo "deb https://mirrors.aliyun.com/debian/ bullseye main contrib non-free" > /etc/apt/sources.list && \
    echo "deb https://mirrors.aliyun.com/debian/ bullseye-updates main contrib non-free" >> /etc/apt/sources.list && \
    echo "deb https://mirrors.aliyun.com/debian/ bullseye-backports main contrib non-free" >> /etc/apt/sources.list && \
    echo "deb https://mirrors.aliyun.com/debian-security bullseye-security main contrib non-free" >> /etc/apt/sources.list && \
    # 更新软件包列表
    apt-get clean && \
    apt-get update -y

# 安装系统依赖
RUN apt-get update && \
    echo "Installing system dependencies..." && \
    DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
    build-essential \
    gcc \
    g++ \
    git \
    libssl-dev \
    pkg-config \
    wget \
    curl \
    netcat-openbsd \
    vim \
    nano \
    htop \
    procps \
    iputils-ping \
    net-tools \
    telnet \
    dnsutils \
    lsof \
    unzip \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# 安装TA-Lib
# 使用国内镜像下载TA-Lib
RUN cd /tmp && \
    echo "Downloading TA-Lib..." && \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://gitee.com/mirrors/ta-lib/raw/master/ta-lib-0.4.0-src.tar.gz || \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://jztkft.dl.sourceforge.net/project/ta-lib/ta-lib/0.4.0/ta-lib-0.4.0-src.tar.gz || \
    wget -q -O ta-lib-0.4.0-src.tar.gz https://versaweb.dl.sourceforge.net/project/ta-lib/ta-lib/0.4.0/ta-lib-0.4.0-src.tar.gz || \
    wget -q -O ta-lib-0.4.0-src.tar.gz http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz && \
    echo "Extracting TA-Lib..." && \
    tar -xzf ta-lib-0.4.0-src.tar.gz && \
    cd ta-lib/ && \
    echo "Configuring TA-Lib..." && \
    ./configure --prefix=/usr && \
    echo "Building TA-Lib..." && \
    make && \
    echo "Installing TA-Lib..." && \
    make install && \
    cd /tmp && \
    rm -rf ta-lib-0.4.0-src.tar.gz ta-lib/

# 配置PIP国内镜像
RUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple \
    && pip config set global.trusted-host pypi.tuna.tsinghua.edu.cn

# 安装Python依赖
RUN pip install --no-cache-dir --upgrade pip setuptools wheel

# 安装常用Python工具
RUN pip install --no-cache-dir \
    ipython \
    jupyter \
    notebook \
    pandas \
    numpy \
    matplotlib \
    seaborn \
    scikit-learn \
    statsmodels \
    pytest \
    black \
    flake8 \
    isort \
    mypy \
    pylint

# 安装vnpy核心
RUN pip install --no-cache-dir \
    vnpy \
    vnpy_cta_strategy \
    vnpy_ctastrategy \
    vnpy_datamanager \
    vnpy_sqlite \
    vnpy_rest \
    vnpy_websocket \
    vnpy_csv \
    vnpy_mysql \
    vnpy_ctp \
    vnpy_ib \
    vnpy_tushare \
    vnpy_rqdata \
    vnpy_jotdx

# 安装应用依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 验证vnpy安装
RUN python -c "from vnpy.trader.engine import MainEngine; from vnpy.app.cta_strategy import CtaStrategyApp; print('VeighNa installation verified!')"

# 创建常用目录
RUN mkdir -p /app/data /app/logs /app/configs /app/notebooks

# 添加常用工具脚本
COPY docker_scripts/ /app/docker_scripts/
RUN chmod +x /app/docker_scripts/*.sh

# 复制启动脚本
COPY docker-entrypoint.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/docker-entrypoint.sh

# 暴露端口
EXPOSE 8003

# 启动命令
ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["conda", "run", "--no-capture-output", "-n", "simpletrade", "python", "-m", "uvicorn", "simpletrade.api.server:app", "--host", "0.0.0.0", "--port", "8003", "--reload"]

```

### `/simpletrade/start_docker_cn.sh`
*(统计信息: 128 行, 2915 字符 [~0.42%])*
```bash
#!/bin/bash

# 设置颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_message() {
  echo -e "${BLUE}[SimpleTrade]${NC} $1"
}

print_success() {
  echo -e "${GREEN}[成功]${NC} $1"
}

print_warning() {
  echo -e "${YELLOW}[警告]${NC} $1"
}

print_error() {
  echo -e "${RED}[错误]${NC} $1"
}

# 确保脚本在项目根目录运行
cd "$(dirname "$0")"

# 如果.env文件不存在，复制.env.example
if [ ! -f .env ]; then
  print_message "创建.env文件..."
  cp .env.example .env 2>/dev/null || {
    cat > .env << EOF
SIMPLETRADE_DB_USER=root
SIMPLETRADE_DB_PASSWORD=Cz159csa
SIMPLETRADE_DB_NAME=simpletrade
SIMPLETRADE_API_PORT=8003
EOF
  }
  print_success ".env文件已创建。"
else
  print_message ".env文件已存在，跳过创建。"
fi

# 创建必要的目录
print_message "创建必要的目录..."
mkdir -p data logs configs notebooks mysql-init docker_scripts
print_success "目录已创建。"

# 检查是否有正在运行的容器
if docker ps | grep -q "simpletrade"; then
  print_warning "检测到SimpleTrade容器已经在运行。"
  read -p "是否停止现有容器并重新启动？(y/n) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    print_message "停止现有容器..."
    docker-compose -f docker-compose.cn.yml down
  else
    print_message "操作已取消。"
    exit 0
  fi
fi

# 清理Docker缓存
print_message "清理Docker缓存..."
docker system prune -f > /dev/null 2>&1

# 强制重新构建镜像
print_message "使用国内镜像构建并启动服务..."

# 先启动MySQL服务
print_message "启动MySQL服务..."
docker-compose -f docker-compose.cn.yml up -d mysql

# 等待MySQL服务启动
print_message "等待MySQL服务启动..."
sleep 10

# 构建并启动前端服务
print_message "构建并启动前端服务..."
docker-compose -f docker-compose.cn.yml up -d frontend

# 使用现有的镜像启动API服务
print_message "启动API服务..."
docker-compose -f docker-compose.cn.yml up -d api

# 使用现有的镜像启动Jupyter服务
print_message "启动Jupyter服务..."
docker-compose -f docker-compose.cn.yml up -d jupyter

print_warning "注意：由于依赖冲突问题，我们暂时使用现有的镜像启动服务。"
print_warning "如果需要完整的功能，请使用原始的start_docker.sh脚本。"

# 检查服务是否成功启动
if [ $? -eq 0 ]; then
  print_success "SimpleTrade服务已成功启动！"

  # 显示服务信息
  print_message "服务信息："
  echo "--------------------------------------"
  echo "API服务: http://localhost:8003"
  echo "API文档: http://localhost:8003/docs"
  echo "前端界面: http://localhost:8080"
  echo "Jupyter Notebook: http://localhost:8888 (用于数据分析和策略开发)"
  echo "MySQL数据库: localhost:3306"
  echo "  - 用户名: root"
  echo "  - 密码: Cz159csa (可在.env文件中修改)"
  echo "  - 数据库名: simpletrade"
  echo "--------------------------------------"
  echo
  echo "您可以使用以下命令查看容器状态："
  echo "  docker-compose -f docker-compose.cn.yml ps"
  echo
  echo "您可以使用以下命令查看容器日志："
  echo "  docker-compose -f docker-compose.cn.yml logs api"
  echo "  docker-compose -f docker-compose.cn.yml logs frontend"
  echo "  docker-compose -f docker-compose.cn.yml logs mysql"
  echo "  docker-compose -f docker-compose.cn.yml logs jupyter"
  echo
  echo "您可以使用以下命令停止服务："
  echo "  docker-compose -f docker-compose.cn.yml down"
  echo "--------------------------------------"
else
  print_error "启动服务时出错。请检查日志获取详细信息。"
  exit 1
fi

```

### `/simpletrade/start_docker_debian11.sh`
*(统计信息: 127 行, 3024 字符 [~0.43%])*
```bash
#!/bin/bash

# 设置颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_message() {
  echo -e "${BLUE}[SimpleTrade]${NC} $1"
}

print_success() {
  echo -e "${GREEN}[成功]${NC} $1"
}

print_warning() {
  echo -e "${YELLOW}[警告]${NC} $1"
}

print_error() {
  echo -e "${RED}[错误]${NC} $1"
}

# 确保脚本在项目根目录运行
cd "$(dirname "$0")"

# 如果.env文件不存在，复制.env.example
if [ ! -f .env ]; then
  print_message "创建.env文件..."
  cp .env.example .env 2>/dev/null || {
    cat > .env << EOF
SIMPLETRADE_DB_USER=root
SIMPLETRADE_DB_PASSWORD=Cz159csa
SIMPLETRADE_DB_NAME=simpletrade
SIMPLETRADE_API_PORT=8003
EOF
  }
  print_success ".env文件已创建。"
else
  print_message ".env文件已存在，跳过创建。"
fi

# 创建必要的目录
print_message "创建必要的目录..."
mkdir -p data logs configs notebooks mysql-init docker_scripts
print_success "目录已创建。"

# 检查是否有正在运行的容器
if docker ps | grep -q "simpletrade"; then
  print_warning "检测到SimpleTrade容器已经在运行。"
  read -p "是否停止现有容器并重新启动？(y/n) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    print_message "停止现有容器..."
    docker-compose -f docker-compose.debian11.yml down
  else
    print_message "操作已取消。"
    exit 0
  fi
fi

# 清理Docker缓存
print_message "清理Docker缓存..."
docker system prune -f > /dev/null 2>&1

# 启动服务
print_message "使用Debian 11基础镜像构建并启动服务..."

# 先启动MySQL服务
print_message "启动MySQL服务..."
docker-compose -f docker-compose.debian11.yml up -d mysql

# 等待MySQL服务启动
print_message "等待MySQL服务启动..."
sleep 10

# 构建并启动前端服务
print_message "启动前端服务..."
docker-compose -f docker-compose.debian11.yml up -d frontend

# 构建并启动API服务
print_message "构建并启动API服务..."
docker-compose -f docker-compose.debian11.yml build --no-cache api
docker-compose -f docker-compose.debian11.yml up -d api

# 构建并启动Jupyter服务
print_message "构建并启动Jupyter服务..."
docker-compose -f docker-compose.debian11.yml build --no-cache jupyter
docker-compose -f docker-compose.debian11.yml up -d jupyter

# 检查服务是否成功启动
if [ $? -eq 0 ]; then
  print_success "SimpleTrade服务已成功启动！"

  # 显示服务信息
  print_message "服务信息："
  echo "--------------------------------------"
  echo "API服务: http://localhost:8003"
  echo "API文档: http://localhost:8003/docs"
  echo "前端界面: http://localhost:8080"
  echo "Jupyter Notebook: http://localhost:8888 (用于数据分析和策略开发)"
  echo "MySQL数据库: localhost:3306"
  echo "  - 用户名: root"
  echo "  - 密码: Cz159csa (可在.env文件中修改)"
  echo "  - 数据库名: simpletrade"
  echo "--------------------------------------"
  echo
  echo "您可以使用以下命令查看容器状态："
  echo "  docker-compose -f docker-compose.debian11.yml ps"
  echo
  echo "您可以使用以下命令查看容器日志："
  echo "  docker-compose -f docker-compose.debian11.yml logs api"
  echo "  docker-compose -f docker-compose.debian11.yml logs frontend"
  echo "  docker-compose -f docker-compose.debian11.yml logs mysql"
  echo "  docker-compose -f docker-compose.debian11.yml logs jupyter"
  echo
  echo "您可以使用以下命令停止服务："
  echo "  docker-compose -f docker-compose.debian11.yml down"
  echo "--------------------------------------"
else
  print_error "启动服务时出错。请检查日志获取详细信息。"
  exit 1
fi

```

### `/simpletrade/start_docker_ubuntu.sh`
*(统计信息: 127 行, 2995 字符 [~0.43%])*
```bash
#!/bin/bash

# 设置颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_message() {
  echo -e "${BLUE}[SimpleTrade]${NC} $1"
}

print_success() {
  echo -e "${GREEN}[成功]${NC} $1"
}

print_warning() {
  echo -e "${YELLOW}[警告]${NC} $1"
}

print_error() {
  echo -e "${RED}[错误]${NC} $1"
}

# 确保脚本在项目根目录运行
cd "$(dirname "$0")"

# 如果.env文件不存在，复制.env.example
if [ ! -f .env ]; then
  print_message "创建.env文件..."
  cp .env.example .env 2>/dev/null || {
    cat > .env << EOF
SIMPLETRADE_DB_USER=root
SIMPLETRADE_DB_PASSWORD=Cz159csa
SIMPLETRADE_DB_NAME=simpletrade
SIMPLETRADE_API_PORT=8003
EOF
  }
  print_success ".env文件已创建。"
else
  print_message ".env文件已存在，跳过创建。"
fi

# 创建必要的目录
print_message "创建必要的目录..."
mkdir -p data logs configs notebooks mysql-init docker_scripts
print_success "目录已创建。"

# 检查是否有正在运行的容器
if docker ps | grep -q "simpletrade"; then
  print_warning "检测到SimpleTrade容器已经在运行。"
  read -p "是否停止现有容器并重新启动？(y/n) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    print_message "停止现有容器..."
    docker-compose -f docker-compose.ubuntu.yml down
  else
    print_message "操作已取消。"
    exit 0
  fi
fi

# 清理Docker缓存
print_message "清理Docker缓存..."
docker system prune -f > /dev/null 2>&1

# 启动服务
print_message "使用Ubuntu基础镜像构建并启动服务..."

# 先启动MySQL服务
print_message "启动MySQL服务..."
docker-compose -f docker-compose.ubuntu.yml up -d mysql

# 等待MySQL服务启动
print_message "等待MySQL服务启动..."
sleep 10

# 构建并启动前端服务
print_message "启动前端服务..."
docker-compose -f docker-compose.ubuntu.yml up -d frontend

# 构建并启动API服务
print_message "构建并启动API服务..."
docker-compose -f docker-compose.ubuntu.yml build --no-cache api
docker-compose -f docker-compose.ubuntu.yml up -d api

# 构建并启动Jupyter服务
print_message "构建并启动Jupyter服务..."
docker-compose -f docker-compose.ubuntu.yml build --no-cache jupyter
docker-compose -f docker-compose.ubuntu.yml up -d jupyter

# 检查服务是否成功启动
if [ $? -eq 0 ]; then
  print_success "SimpleTrade服务已成功启动！"

  # 显示服务信息
  print_message "服务信息："
  echo "--------------------------------------"
  echo "API服务: http://localhost:8003"
  echo "API文档: http://localhost:8003/docs"
  echo "前端界面: http://localhost:8080"
  echo "Jupyter Notebook: http://localhost:8888 (用于数据分析和策略开发)"
  echo "MySQL数据库: localhost:3306"
  echo "  - 用户名: root"
  echo "  - 密码: Cz159csa (可在.env文件中修改)"
  echo "  - 数据库名: simpletrade"
  echo "--------------------------------------"
  echo
  echo "您可以使用以下命令查看容器状态："
  echo "  docker-compose -f docker-compose.ubuntu.yml ps"
  echo
  echo "您可以使用以下命令查看容器日志："
  echo "  docker-compose -f docker-compose.ubuntu.yml logs api"
  echo "  docker-compose -f docker-compose.ubuntu.yml logs frontend"
  echo "  docker-compose -f docker-compose.ubuntu.yml logs mysql"
  echo "  docker-compose -f docker-compose.ubuntu.yml logs jupyter"
  echo
  echo "您可以使用以下命令停止服务："
  echo "  docker-compose -f docker-compose.ubuntu.yml down"
  echo "--------------------------------------"
else
  print_error "启动服务时出错。请检查日志获取详细信息。"
  exit 1
fi

```

### `/simpletrade/Dockerfile.arm64`
*(统计信息: 118 行, 4228 字符 [~0.61%])*
```
# 使用Ubuntu 20.04作为基础镜像
FROM ubuntu:20.04

# 设置环境变量，避免交互式提示
ENV DEBIAN_FRONTEND=noninteractive \
    TZ=Asia/Shanghai \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    CONDA_AUTO_UPDATE_CONDA=false \
    CONDA_DEFAULT_ENV=base \
    PATH="/opt/conda/bin:$PATH"

# 设置工作目录
WORKDIR /app

# 使用官方源，但添加arm64架构支持
RUN apt-get update && \
    apt-get install -y --no-install-recommends ca-certificates && \
    rm -rf /var/lib/apt/lists/*

# 安装系统依赖
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    build-essential \
    gcc \
    g++ \
    git \
    libssl-dev \
    pkg-config \
    wget \
    curl \
    netcat \
    vim \
    nano \
    htop \
    procps \
    iputils-ping \
    net-tools \
    telnet \
    dnsutils \
    lsof \
    unzip \
    && rm -rf /var/lib/apt/lists/*

# 安装 Miniconda
RUN wget --quiet https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh -O ~/miniconda.sh && \
    /bin/bash ~/miniconda.sh -b -p /opt/conda && \
    rm ~/miniconda.sh && \
    conda clean -a -y && \
    ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh && \
    echo ". /opt/conda/etc/profile.d/conda.sh" >> ~/.bashrc && \
    echo "conda activate base" >> ~/.bashrc

# 创建 .condarc 文件到 Conda 安装目录，强制使用清华镜像源并排除 defaults
RUN echo "channels:" > /opt/conda/.condarc && \
    echo "  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/" >> /opt/conda/.condarc && \
    echo "  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/" >> /opt/conda/.condarc && \
    echo "  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" >> /opt/conda/.condarc && \
    echo "show_channel_urls: true" >> /opt/conda/.condarc && \
    echo "nodefaults: true" >> /opt/conda/.condarc # Ensure defaults channel is not used

# 使用 Conda 安装 numpy 和 ta-lib (从已配置的镜像源)
RUN conda install -y numpy ta-lib && \
    conda clean -a -y

# 配置pip使用国内镜像源（使用多个镜像源作为备选）
RUN mkdir -p ~/.pip && \
    echo "[global]" > ~/.pip/pip.conf && \
    echo "index-url = https://mirrors.aliyun.com/pypi/simple/" >> ~/.pip/pip.conf && \
    echo "extra-index-url = https://pypi.tuna.tsinghua.edu.cn/simple https://mirrors.cloud.tencent.com/pypi/simple https://mirrors.bfsu.edu.cn/pypi/web/simple" >> ~/.pip/pip.conf && \
    echo "trusted-host = mirrors.aliyun.com pypi.tuna.tsinghua.edu.cn mirrors.cloud.tencent.com mirrors.bfsu.edu.cn" >> ~/.pip/pip.conf && \
    echo "timeout = 120" >> ~/.pip/pip.conf

# 升级pip并安装常用工具（在Conda环境中执行）
RUN pip install --no-cache-dir --upgrade pip setuptools wheel && \
    pip config set global.progress_bar off && \
    pip config set global.no-cache-dir true && \
    pip config set global.disable-pip-version-check true

# 安装常用Python工具（分批安装以加快进程，直接指定国内镜像源）
RUN pip install --no-cache-dir -i https://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com pandas && \
    pip install --no-cache-dir -i https://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com ipython jupyter notebook && \
    pip install --no-cache-dir -i https://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com matplotlib seaborn && \
    pip install --no-cache-dir -i https://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com pytest black flake8 isort mypy pylint

# 使用 pip 安装所有 vnpy 相关包
RUN pip install --no-cache-dir -i https://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com \
    vnpy \
    vnpy-ctastrategy \
    vnpy-sqlite \
    vnpy-datamanager \
    vnpy-rest \
    vnpy-websocket \
    vnpy-mysql

# 创建常用目录
RUN mkdir -p /app/data /app/logs /app/configs /app/notebooks

# 复制启动脚本
COPY docker_scripts/ /app/docker_scripts/
RUN chmod +x /app/docker_scripts/*.sh

# 安装应用依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -i https://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com -r requirements.txt

# 验证vnpy安装
RUN echo "Verifying VeighNa installation..." && \
    python -c "import vnpy; print(f'VeighNa version: {vnpy.__version__}')" && \
    python -c "from vnpy.trader.engine import MainEngine; print('VeighNa MainEngine imported successfully!')" || \
    echo "VeighNa installation verification failed but continuing anyway"

# 复制应用代码
COPY . .

# 设置环境变量
ENV PYTHONPATH=/app

```

### `/simpletrade/docker-compose.yml`
*(统计信息: 96 行, 2422 字符 [~0.35%])*
```yaml
version: '3'

services:
  mysql:
    image: mysql:8.0
    container_name: simpletrade-mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${SIMPLETRADE_DB_PASSWORD:-Cz159csa}
      MYSQL_DATABASE: ${SIMPLETRADE_DB_NAME:-simpletrade}
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./mysql-init:/docker-entrypoint-initdb.d
    networks:
      - simpletrade-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "${SIMPLETRADE_DB_USER:-root}", "-p${SIMPLETRADE_DB_PASSWORD:-Cz159csa}"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  api:
    build: .
    container_name: simpletrade-api
    depends_on:
      mysql:
        condition: service_healthy
    ports:
      - "8003:8003"
    volumes:
      - .:/app
      - data-volume:/app/data
      - logs-volume:/app/logs
      - configs-volume:/app/configs
    environment:
      - PYTHONPATH=/app
      - SIMPLETRADE_DB_HOST=mysql
      - SIMPLETRADE_DB_PORT=3306
      - SIMPLETRADE_DB_USER=${SIMPLETRADE_DB_USER:-root}
      - SIMPLETRADE_DB_PASSWORD=${SIMPLETRADE_DB_PASSWORD:-Cz159csa}
      - SIMPLETRADE_DB_NAME=${SIMPLETRADE_DB_NAME:-simpletrade}
      - SIMPLETRADE_API_PORT=8003
    networks:
      - simpletrade-network
    restart: unless-stopped

  frontend:
    image: node:16
    container_name: simpletrade-frontend
    working_dir: /app
    volumes:
      - ./web-frontend:/app
    ports:
      - "8080:8080"
    command: bash -c "npm install --legacy-peer-deps && npm run serve"
    depends_on:
      - api
    networks:
      - simpletrade-network
    restart: unless-stopped

  jupyter:
    build: .
    container_name: simpletrade-jupyter
    command: /app/docker_scripts/start_jupyter.sh
    ports:
      - "8888:8888"
    volumes:
      - .:/app
      - data-volume:/app/data
      - notebooks-volume:/app/notebooks
    environment:
      - PYTHONPATH=/app
      - SIMPLETRADE_DB_HOST=mysql
      - SIMPLETRADE_DB_PORT=3306
      - SIMPLETRADE_DB_USER=${SIMPLETRADE_DB_USER:-root}
      - SIMPLETRADE_DB_PASSWORD=${SIMPLETRADE_DB_PASSWORD:-Cz159csa}
      - SIMPLETRADE_DB_NAME=${SIMPLETRADE_DB_NAME:-simpletrade}
    networks:
      - simpletrade-network
    depends_on:
      - mysql
    restart: unless-stopped

networks:
  simpletrade-network:

volumes:
  mysql-data:
  data-volume:
  logs-volume:
  configs-volume:
  notebooks-volume:

```

### `/simpletrade/setup_env.sh`
*(统计信息: 43 行, 917 字符 [~0.13%])*
```bash
#!/bin/bash
# SimpleTrade 环境设置脚本
# 此脚本会创建并配置 simpletrade conda 环境

# 检查是否安装了 conda
if ! command -v conda &> /dev/null; then
    echo "错误: 未找到 conda。请先安装 Anaconda 或 Miniconda。"
    exit 1
fi

# 创建 conda 环境
echo "创建 simpletrade 环境..."
conda create -n simpletrade python=3.12 -y

# 激活环境
echo "激活 simpletrade 环境..."
source $(conda info --base)/etc/profile.d/conda.sh
conda activate simpletrade

# 安装 TA-Lib
echo "安装 TA-Lib..."
conda install -c conda-forge ta-lib -y

# 安装 vnpy 相关包
echo "安装 vnpy 相关包..."
pip install vnpy vnpy_sqlite

# 安装 FastAPI 和 Uvicorn
echo "安装 FastAPI 和 Uvicorn..."
pip install fastapi uvicorn[standard] pydantic[email]

# 安装 tigeropen
echo "安装 tigeropen..."
pip install tigeropen

# 以开发模式安装项目
echo "以开发模式安装项目..."
pip install -e .

echo "环境设置完成！"
echo "使用以下命令启动服务器："
echo "conda run --no-capture-output -n simpletrade python -m uvicorn simpletrade.api.server:app --host 0.0.0.0 --port 8002 --reload"

```

### `/simpletrade/setup.py`
*(统计信息: 28 行, 475 字符 [~0.07%])*
```python
"""
SimpleTrade安装脚本
"""

from setuptools import setup, find_packages

setup(
    name="simpletrade",
    version="0.1.0",
    description="简单易用的个人量化交易平台",
    author="SimpleTrade Team",
    packages=find_packages(),
    install_requires=[
        # 基础依赖
        "numpy",
        "pandas",
        "matplotlib",
        # API服务依赖
        "fastapi",
        "uvicorn",
        # 数据库依赖
        "sqlalchemy",
        # 其他依赖
        "pyqt5",
    ],
    python_requires=">=3.7",
)

```

### `/simpletrade/requirements.txt`
*(统计信息: 26 行, 331 字符 [~0.05%])*
```
# 核心依赖
fastapi>=0.95.0
uvicorn[standard]>=0.21.1
pydantic>=1.10.7
sqlalchemy>=2.0.0
pymysql>=1.0.3
python-dotenv>=1.0.0
python-multipart
python-jose
importlib-metadata>=6.0.0

# 数据处理
pandas>=1.5.3
numpy>=1.24.2

# 交易相关
tigeropen>=2.0.0

# 开发工具
pytest>=7.3.1
black>=23.3.0
isort>=5.12.0
flake8>=6.0.0

# 注意: vnpy相关依赖已在Dockerfile中安装

```

### `/simpletrade/.env.example`
*(统计信息: 22 行, 443 字符 [~0.06%])*
```
# SimpleTrade 环境变量配置示例
# 复制此文件为 .env 并根据需要修改

# 数据库配置
SIMPLETRADE_DB_USER=root
SIMPLETRADE_DB_PASSWORD=Cz159csa
SIMPLETRADE_DB_HOST=localhost
SIMPLETRADE_DB_PORT=3306
SIMPLETRADE_DB_NAME=simpletrade
SIMPLETRADE_DB_POOL_SIZE=5
SIMPLETRADE_DB_MAX_OVERFLOW=10
SIMPLETRADE_DB_POOL_RECYCLE=3600
SIMPLETRADE_DB_ECHO=False

# API 配置
SIMPLETRADE_API_HOST=0.0.0.0
SIMPLETRADE_API_PORT=8003
SIMPLETRADE_API_DEBUG=True

# 日志配置
SIMPLETRADE_LOG_LEVEL=INFO

```

### `/simpletrade/docker-entrypoint.sh`
*(统计信息: 17 行, 310 字符 [~0.04%])*
```bash
#!/bin/bash

# 等待 MySQL 服务启动
echo "Waiting for MySQL to start..."
while ! nc -z $SIMPLETRADE_DB_HOST $SIMPLETRADE_DB_PORT; do
  sleep 1
done
echo "MySQL started"

# 初始化数据库
echo "Initializing database..."
conda run -n simpletrade python scripts/init_database.py

# 启动应用
echo "Starting application..."
exec "$@"

```

### `/simpletrade/.gitmodules`
*(统计信息: 8 行, 192 字符 [~0.03%])*
```
[submodule "vendors/vnpy"]
	path = vendors/vnpy
	url = https://github.com/vnpy/vnpy.git

[submodule "vendors/vnpy_ib"]
	path = vendors/vnpy_ib
	url = https://github.com/xingdong23/vnpy_ib.git

```

### `/simpletrade/.cursorignore`
*(统计信息: 2 行, 82 字符 [~0.01%])*
```
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)

```

### `/simpletrade/simpletrade/main.py`
*(统计信息: 219 行, 6639 字符 [~0.95%])*
```python
"""
SimpleTrade主程序入口

启动SimpleTrade交易平台。
"""

import sys
import os
import logging
from pathlib import Path
import time
import threading
import uvicorn
import asyncio

# 添加 vendors 目录到 Python 路径
project_root = Path(__file__).parent.parent.absolute()
vendors_path = project_root / "vendors"
if vendors_path.exists() and str(vendors_path) not in sys.path:
    sys.path.insert(0, str(vendors_path))
    print(f"[INFO] Added vendors path to sys.path: {vendors_path}")

# 导入配置
from simpletrade.config.settings import API_CONFIG, DATA_SYNC_CONFIG

# 导入核心初始化函数
from simpletrade.core.initialization import initialize_core_components

# 配置日志
log_level_str = os.environ.get("SIMPLETRADE_LOG_LEVEL", "INFO").upper()
log_level = getattr(logging, log_level_str, logging.INFO)

logging.basicConfig(
    level=log_level,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("simpletrade.main")
logger.info(f"Logging configured with level: {log_level_str}")


def run_api_server(host: str, port: int, app_instance):
    """运行 API 服务器

    Args:
        host: 主机地址
        port: 端口号
        app_instance: FastAPI应用实例
    """
    if not app_instance:
        logger.error("Cannot start API server: FastAPI app instance not found.")
        return

    logger.info(f"Starting API server on http://{host}:{port}")
    try:
        uvicorn.run(app_instance, host=host, port=port, log_level="info")
    except Exception as e:
        logger.error(f"API server failed: {e}", exc_info=True)
    logger.info("API server stopped.")


def start_data_sync(db_instance, periodic=False):
    """启动数据同步服务

    Args:
        db_instance: 数据库实例
        periodic: 是否周期性运行
    """
    try:
        from simpletrade.services.data_sync_service import run_initial_data_sync, run_periodic_data_sync
    except ImportError as e:
        logger.error(f"Failed to import data sync components: {e}")
        return

    if not db_instance:
        logger.error("Cannot start data sync: database instance not available.")
        return

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        if periodic:
            logger.info("Starting periodic data synchronization...")
            loop.run_until_complete(run_periodic_data_sync(db_instance=db_instance))
        else:
            logger.info("Running one-time data synchronization...")
            loop.run_until_complete(run_initial_data_sync(db_instance=db_instance))
            logger.info("Data synchronization completed.")
    except Exception as e:
        logger.error(f"Error in data sync thread: {e}", exc_info=True)
    finally:
        logger.info("Closing data sync event loop.")
        loop.close()


def start_api_server(main_engine, event_engine):
    """启动API服务器

    Args:
        main_engine: 主引擎实例
        event_engine: 事件引擎实例
    """
    if not API_CONFIG.get("ENABLED", True):
        logger.info("API server disabled in configuration. Skipping start.")
        return

    try:
        # 导入API相关模块
        from simpletrade.core.server import app as fastapi_app, configure_server

        # 配置API服务器
        if main_engine and event_engine and fastapi_app and configure_server:
            configure_server(main_engine=main_engine, event_engine=event_engine)
            logger.info("API server configured successfully.")

            # 启动API服务器线程
            api_host = API_CONFIG.get("HOST", "0.0.0.0")
            api_port = int(API_CONFIG.get("PORT", 8003))

            api_thread = threading.Thread(
                target=run_api_server,
                args=(api_host, api_port, fastapi_app),
                daemon=True
            )
            api_thread.start()
            logger.info(f"API server thread started at http://{api_host}:{api_port}")
            return api_thread
        else:
            logger.warning("Skipping API server start due to missing components.")
            return None
    except ImportError as e:
        logger.error(f"Failed to import API components: {e}")
        return None
    except Exception as e:
        logger.error(f"Error starting API server: {e}", exc_info=True)
        return None


def start_data_sync_service(db_instance):
    """启动数据同步服务

    Args:
        db_instance: 数据库实例
    """
    if not DATA_SYNC_CONFIG.get("ENABLED", True):
        logger.info("Data sync service disabled in configuration. Skipping start.")
        return None

    if not db_instance:
        logger.error("Cannot start data sync service: database instance not available.")
        return None

    try:
        # 检查是否启用同步周期
        run_periodic = DATA_SYNC_CONFIG.get("PERIODIC_SYNC", False)

        # 是否在启动时同步
        sync_on_startup = DATA_SYNC_CONFIG.get("SYNC_ON_STARTUP", True)

        if sync_on_startup or run_periodic:
            # 创建并启动数据同步线程
            sync_thread = threading.Thread(
                target=start_data_sync,
                args=(db_instance, run_periodic),  # 传递周期性运行标志
                daemon=True
            )
            sync_thread.start()

            if run_periodic:
                logger.info("Periodic data synchronization service thread started.")
            else:
                logger.info("One-time data synchronization service thread started.")

            return sync_thread
        else:
            logger.info("Data synchronization on startup disabled. Skipping initial sync.")
            return None

    except Exception as e:
        logger.error(f"Error starting data sync service: {e}", exc_info=True)
        return None


def keep_running():
    """保持主程序运行，直到收到终止信号"""
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Shutting down SimpleTrade...")


def main():
    """SimpleTrade主程序入口点"""
    logger.info("Starting SimpleTrade...")

    try:
        # 1. 初始化核心组件
        main_engine, event_engine, db_instance = initialize_core_components()
        logger.info("Core components initialized successfully.")

        # 2. 启动API服务器（如果配置启用）
        start_api_server(main_engine, event_engine)

        # 3. 启动数据同步服务（如果配置启用）
        start_data_sync_service(db_instance)

        # 4. 主循环保持程序运行
        logger.info("SimpleTrade is running. Press Ctrl+C to shut down.")
        keep_running()

    except Exception as e:
        logger.critical(f"FATAL ERROR during SimpleTrade startup: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()

```

### `/simpletrade/simpletrade/__init__.py`
*(统计信息: 9 行, 112 字符 [~0.02%])*
```python
"""
SimpleTrade包

SimpleTrade是一个简单易用的个人量化交易平台，采用微信小程序/消息交互作为前端，
支持策略交易、AI分析和实时监控等功能。
"""

__version__ = "0.1.0"

```

### `/simpletrade/simpletrade/apps/README.md`
*(统计信息: 190 行, 4377 字符 [~0.63%])*
```markdown
# SimpleTrade 应用模块

SimpleTrade 应用模块包含了 SimpleTrade 交易平台的各种功能应用。这些应用基于 vnpy 的应用框架，但进行了扩展和增强，以提供更多功能和更好的用户体验。

## 应用概览

SimpleTrade 应用模块目前包含以下主要应用：

1. **st_datamanager** - 数据管理应用
2. **st_message** - 消息系统应用
3. **st_trader** - 交易增强应用

## 应用架构

所有 SimpleTrade 应用都继承自 `simpletrade.core.app.STBaseApp` 基类，该基类又继承自 vnpy 的 `BaseApp`。每个应用通常包含以下组件：

- **__init__.py** - 定义应用类和基本信息
- **engine.py** - 实现应用的核心功能引擎
- **widget.py** (可选) - 实现应用的图形界面
- **api/** (可选) - 提供 RESTful API 接口
- **commands/** (可选) - 提供消息指令处理功能

## 应用详情

### st_datamanager - 数据管理应用

数据管理应用提供数据下载、导入、导出、查看和管理功能，扩展了 vnpy_datamanager，并添加了 API 接口和消息指令处理功能。

**主要功能**：

- 获取 K 线数据和 Tick 数据
- 下载历史数据
- 从 CSV 文件导入数据
- 导出数据到 CSV 文件
- 删除数据

**API 接口**：

- `GET /api/data/overview` - 获取数据概览
- `GET /api/data/bars` - 获取 K 线数据
- `POST /api/data/download` - 下载历史数据
- `POST /api/data/import/csv` - 导入 CSV 数据
- `POST /api/data/export` - 导出数据
- `DELETE /api/data/bar/{exchange}/{symbol}/{interval}` - 删除 K 线数据

**消息指令**：

- `/data query [类型] [代码] [交易所] [周期] [开始日期] [结束日期(可选)]` - 查询数据
- `/data download [代码] [交易所] [周期] [开始日期] [结束日期(可选)]` - 下载数据
- `/data import [文件路径] [代码] [交易所] [周期] [时间列名] [开盘列名] [最高列名] [最低列名] [收盘列名] [成交量列名] [持仓量列名] [时间格式]` - 从 CSV 导入数据
- `/data export [代码] [交易所] [周期] [开始日期] [结束日期] [文件路径]` - 导出数据到 CSV
- `/data delete [类型] [代码] [交易所] [周期(仅 bar 类型需要)]` - 删除数据
- `/data help` - 显示帮助信息

### st_message - 消息系统应用

消息系统应用提供消息处理功能，支持通过消息指令控制系统。它是 SimpleTrade 的核心组件之一，使用户能够通过微信、飞书等消息平台与系统交互。

**主要功能**：

- 处理消息指令
- 将消息分发到相应的处理器
- 发送消息到用户或群组

**核心方法**：

- `register_processor(prefix, processor)` - 注册命令处理器
- `process_message(message_text)` - 处理消息
- `send_message(message, target)` - 发送消息

### st_trader - 交易增强应用

交易增强应用提供交易功能的增强，包括订单管理、持仓管理等。它扩展了 vnpy 的交易功能，提供更好的用户体验和更多的功能。

**主要功能**：

- 处理订单事件
- 处理成交事件
- 发送订单
- 撤销订单

**核心方法**：

- `send_order(symbol, exchange, direction, offset, price, volume, gateway_name)` - 发送订单
- `cancel_order(order_id, gateway_name)` - 撤销订单

**设计说明**：

st_trader 并非重复造轮子，而是对 vnpy 原有功能的轻量级封装和扩展：

1. **最小化的实现**：
   - `STTraderEngine` 的实现非常简洁，只有几个基本方法
   - 主要方法 `send_order` 和 `cancel_order` 只是对 vnpy 主引擎相应方法的简单封装
   - 没有重新实现订单管理、持仓管理等核心功能

2. **直接使用 vnpy 的事件系统**：
   - 注册了 vnpy 的标准事件 "eOrder" 和 "eTrade"
   - 事件处理函数目前只是简单的打印，为将来的扩展预留空间

3. **依赖 vnpy 的核心功能**：
   - 使用 vnpy 的 `OrderRequest` 和 `CancelRequest` 对象
   - 调用 `main_engine.send_order` 和 `main_engine.cancel_order` 方法
   - 没有自己实现订单路由、风控等功能

4. **扩展而非替代**：
   - 这是一个"交易增强引擎"，目的是增强而非替代 vnpy 的交易功能
   - 与 SimpleTrade 的其他组件（如消息系统、API 接口）集成
## 应用集成

应用通过 `simpletrade.core.initialization` 模块进行集成和初始化。在系统启动时，会自动加载和初始化所有注册的应用。

```python
# 初始化核心组件
event_engine = EventEngine()
main_engine = STMainEngine(event_engine)

# 添加应用
main_engine.add_app(STMessageApp)
main_engine.add_app(STTraderApp)
main_engine.add_app(STDataManagerApp)
```

## 开发新应用

要开发新的 SimpleTrade 应用，需要遵循以下步骤：

1. 创建一个新的应用目录，如 `simpletrade/apps/st_newapp`
2. 创建 `__init__.py` 文件，定义应用类
3. 创建 `engine.py` 文件，实现应用的核心功能引擎
4. 如果需要图形界面，创建 `widget.py` 文件
5. 如果需要 API 接口，创建 `api` 目录和相应的路由文件
6. 如果需要消息指令处理，创建 `commands` 目录和相应的处理器文件
7. 在 `simpletrade.core.initialization` 模块中注册新应用

## 测试应用

可以使用以下方法测试应用：

1. **API 测试**：启动 API 服务，通过 HTTP 请求测试 API 接口
2. **消息指令测试**：使用 `test_message` 函数测试消息指令处理
3. **交互式测试**：使用 `run_interactive_test` 函数进行交互式测试

```python
# 测试 API
from simpletrade.core.server import app, configure_server
configure_server(main_engine, event_engine)
import uvicorn
uvicorn.run(app, host="0.0.0.0", port=8000)

# 测试消息指令
message_engine = main_engine.get_engine("st_message")
run_interactive_test(message_engine)
```

## API 目录关系说明

在 SimpleTrade 项目中，存在两个主要的 API 相关目录：

1. **simpletrade/api/** - 整个平台的通用 API 目录
2. **simpletrade/apps/st_datamanager/api/** - 数据管理应用特定的 API 目录

这两个目录有明确的区别和关系：

### simpletrade/apps/st_datamanager/api/

- 特定于数据管理应用的 API 路由
- 定义了数据管理相关的所有 API 端点，如获取数据概览、获取 K 线数据、下载数据等
- 直接与 st_datamanager 引擎交互，通过依赖注入获取引擎实例
- 前缀为 `/api/data`，专注于数据管理功能

### simpletrade/api/

- 整个 SimpleTrade 平台的通用 API 路由
- 包含各种功能模块的 API 端点，如分析、策略管理、微信小程序等
- 可能会调用 st_datamanager 的功能，但不直接实现数据管理功能
- 各模块有不同的前缀，如 `/api/analysis`、`/api/strategies` 等

### 集成关系

在 `simpletrade/core/server.py` 中，会导入并注册 st_datamanager 的 API 路由：

```python
from simpletrade.apps.st_datamanager.api import router as data_router
app.include_router(data_router)
```

这意味着 st_datamanager 的 API 路由被集成到了整个 SimpleTrade 的 API 服务中，同时，其他模块的 API 路由也会被导入和注册。

这种设计使得各个应用可以独立开发和维护自己的 API，同时又能够集成到统一的 API 服务中，提供一致的用户体验。

```

### `/simpletrade/simpletrade/apps/__init__.py`
*(统计信息: 6 行, 47 字符 [~0.01%])*
```python
"""
SimpleTrade应用模块

包含SimpleTrade的各种功能应用。
"""

```

### `/simpletrade/simpletrade/apps/st_datamanager/engine.py`
*(统计信息: 477 行, 15842 字符 [~2.27%])*
```python
"""
SimpleTrade数据管理引擎

扩展vnpy_datamanager的功能，提供数据管理功能，并添加API接口和消息指令处理。
"""

import os
import sys
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple
import time # 导入 time 模块
import pandas as pd # 添加 pandas 导入
import traceback # 添加 traceback 导入
from pathlib import Path

# 导入数据导入器
from simpletrade.apps.st_datamanager.importers.qlib_importer import QlibDataImporter

# 导入vnpy相关模块
from vnpy.trader.object import BarData, TickData, HistoryRequest
from vnpy.trader.constant import Interval, Exchange
from vnpy.trader.database import get_database

# 获取数据库对象
database_manager = get_database()
from vnpy.trader.utility import extract_vt_symbol

from simpletrade.core.app import STBaseEngine

# 移除 vnpy_datamanager 的导入和检查
# try:
#     from vnpy_datamanager.engine import ManagerEngine
#     HAS_DATAMANAGER = True
# except ImportError:
#     HAS_DATAMANAGER = False
#     ManagerEngine = object  # 类型提示用

class STDataManagerEngine(STBaseEngine):
    """SimpleTrade数据管理引擎"""

    def __init__(self, main_engine, event_engine, engine_name: str):
        """初始化"""
        super().__init__(main_engine, event_engine, engine_name)

        # 移除原始 DataManager 引擎的实例化
        # self.original_engine = None
        # if HAS_DATAMANAGER:
        #     self.original_engine = ManagerEngine(main_engine, event_engine)
        #     self.write_log("vnpy_datamanager引擎已加载")
        # else:
        #     self.write_log("警告：vnpy_datamanager未安装，部分功能可能不可用")
        self.write_log("STDataManagerEngine 初始化完成。") # 添加简单的初始化日志

        # 初始化API路由和消息指令
        self.init_api_routes()
        self.init_message_commands()

    def init_api_routes(self):
        """初始化API路由"""
        try:
            from .api import router
            self.write_log("API路由初始化成功")

            # 将路由器保存到引擎实例中，便于外部访问
            self.router = router

            # 将引擎实例注册到全局变量中，便于API访问
            # 注意：这里使用了全局变量，实际应用中可能需要更好的方式
            import sys
            sys.modules["simpletrade.apps.st_datamanager.api.engine"] = self
        except Exception as e:
            self.write_log(f"API路由初始化失败：{str(e)}")

    def init_message_commands(self):
        """初始化消息指令"""
        try:
            from .commands import DataCommandProcessor
            self.command_processor = DataCommandProcessor(self)
            self.write_log("消息指令处理器初始化成功")

            # 将指令处理器注册到消息引擎（如果存在）
            message_engine = self.main_engine.get_engine("st_message")
            if message_engine:
                message_engine.register_processor("/data", self.command_processor)
                self.write_log("消息指令处理器注册成功")
            else:
                self.write_log("警告：st_message引擎未找到，消息指令将无法使用")
        except Exception as e:
            self.write_log(f"消息指令处理器初始化失败：{str(e)}")

    def process_command(self, command_text: str) -> str:
        """处理消息指令

        这个方法可以直接调用，方便测试和开发
        """
        if hasattr(self, "command_processor"):
            return self.command_processor.process(command_text)
        else:
            return "消息指令处理器未初始化"

    def write_log(self, msg: str):
        """写入日志"""
        self.main_engine.write_log(msg, source=self.engine_name)

    # ---- 数据查询功能 ----

    def get_bar_data(
        self,
        symbol: str,
        exchange: Exchange,
        interval: Interval,
        start: datetime,
        end: Optional[datetime] = None
    ) -> List[BarData]:
        """获取K线数据"""
        if end is None:
            end = datetime.now()

        return database_manager.load_bar_data(
            symbol=symbol,
            exchange=exchange,
            interval=interval,
            start=start,
            end=end
        )

    def get_tick_data(
        self,
        symbol: str,
        exchange: Exchange,
        start: datetime,
        end: Optional[datetime] = None
    ) -> List[TickData]:
        """获取Tick数据"""
        if end is None:
            end = datetime.now()

        return database_manager.load_tick_data(
            symbol=symbol,
            exchange=exchange,
            start=start,
            end=end
        )

    def get_available_data(self) -> List[Dict[str, Any]]:
        """获取可用的数据列表"""
        data = []

        # 获取所有K线数据的合约信息
        for interval in Interval:
            bar_symbols = database_manager.get_bar_symbols(interval)
            for vt_symbol in bar_symbols:
                symbol, exchange = extract_vt_symbol(vt_symbol)
                overview = database_manager.get_bar_overview(symbol, exchange, interval)
                if overview:
                    data.append({
                        "symbol": symbol,
                        "exchange": exchange.value,
                        "interval": interval.value,
                        "count": overview.count,
                        "start": overview.start.strftime("%Y-%m-%d %H:%M:%S"),
                        "end": overview.end.strftime("%Y-%m-%d %H:%M:%S"),
                        "type": "bar"
                    })

        # 获取所有Tick数据的合约信息
        tick_symbols = database_manager.get_tick_symbols()
        for vt_symbol in tick_symbols:
            symbol, exchange = extract_vt_symbol(vt_symbol)
            overview = database_manager.get_tick_overview(symbol, exchange)
            if overview:
                data.append({
                    "symbol": symbol,
                    "exchange": exchange.value,
                    "count": overview.count,
                    "start": overview.start.strftime("%Y-%m-%d %H:%M:%S"),
                    "end": overview.end.strftime("%Y-%m-%d %H:%M:%S"),
                    "type": "tick"
                })

        return data

    # ---- 新增：数据概览查询 ----
    def get_bar_overview(self) -> List[Any]:
        """获取所有K线数据的概览"""
        return database_manager.get_bar_overview()

    def get_tick_overview(self) -> List[Any]:
        """获取所有Tick数据的概览"""
        return database_manager.get_tick_overview()

    # ---- 数据下载功能 ----

    def download_bar_data(
        self,
        symbol: str,
        exchange: Exchange,
        interval: Interval,
        start: datetime,
        end: Optional[datetime] = None,
        gateway_name: str = "TIGER" # 默认使用 TIGER, 或许可以设为可配置
    ) -> bool:
        """下载K线数据"""
        self.write_log(f"收到K线数据下载请求: {symbol=}, {exchange=}, {interval=}, {start=}, {end=}, {gateway_name=}")

        if end is None:
            end = datetime.now()
            self.write_log(f"结束时间未指定，使用当前时间: {end}")

        # 检查可用的网关
        all_gateways = self.main_engine.get_all_gateway_names()
        self.write_log(f"可用的网关: {all_gateways}")

        # 从 main_engine 获取 gateway 实例
        gateway = self.main_engine.get_gateway(gateway_name)
        if not gateway:
            self.write_log(f"错误：找不到名为 {gateway_name} 的 Gateway 实例。")
            return False

        # 检查 Gateway 是否已连接（通过检查核心客户端是否初始化）
        # 并实现按需连接
        connected = False
        if hasattr(gateway, "quote_client") and gateway.quote_client is not None: # 检查 quote_client 是否已初始化
            self.write_log(f"Gateway {gateway_name} 已连接。")
            connected = True
        else:
            self.write_log(f"Gateway {gateway_name} 未连接，尝试连接...")
            try:
                self.main_engine.connect({}, gateway_name)
                # 再次检查连接是否成功
                if hasattr(gateway, "quote_client") and gateway.quote_client is not None:
                    self.write_log(f"Gateway {gateway_name} 连接成功。")
                    connected = True
                    time.sleep(1) # 短暂等待，确保内部状态稳定
                else:
                    self.write_log(f"错误：调用 main_engine.connect 后，Gateway {gateway_name} 仍然未初始化客户端。")
            except Exception as e:
                self.write_log(f"连接 Gateway {gateway_name} 时出错：{e}")
                import traceback
                traceback.print_exc()

        if not connected:
            return False # 如果未连接或连接失败，则无法下载

        # 检查 gateway 是否有 query_history 方法 (有些 gateway 可能不支持)
        if not hasattr(gateway, "query_history") or not callable(gateway.query_history):
             self.write_log(f"错误：Gateway {gateway_name} 不支持历史数据查询 (缺少 query_history 方法)。")
             return False

        # 创建历史数据请求
        req = HistoryRequest(
            symbol=symbol,
            exchange=exchange,
            interval=interval,
            start=start,
            end=end
        )

        # 发送请求到 gateway
        try:
            gateway.query_history(req)
            self.write_log(f"已向 Gateway {gateway_name} 发送历史数据下载请求: {req}")
            # 注意：这里只表示请求已发送，数据是异步下载和存储的。
            # 实际是否成功下载需要通过事件监听或后续查询数据库确认。
            return True
        except Exception as e:
            self.write_log(f"向 Gateway {gateway_name} 发送下载请求时出错：{e}")
            import traceback
            traceback.print_exc()
            return False

    # ---- 数据导入导出功能 ----

    def import_data_from_csv(
        self,
        file_path: str,
        symbol: str,
        exchange: Exchange,
        interval: Interval,
        datetime_head: str,
        open_head: str,
        high_head: str,
        low_head: str,
        close_head: str,
        volume_head: str,
        open_interest_head: str,
        datetime_format: str
    ) -> Tuple[bool, str]:
        """从CSV导入K线数据"""
        self.write_log(f"开始从CSV导入数据: {file_path}, 合约: {symbol}.{exchange.value}, 周期: {interval.value}")

        # 1. 检查文件是否存在
        if not os.path.exists(file_path):
            msg = f"错误：CSV文件不存在 {file_path}"
            self.write_log(msg)
            return False, msg

        # 2. 使用 pandas 读取文件
        try:
            # 显式指定dtype为str防止pandas自动类型推断导致问题, keep_default_na=False 防止空字符串被读为 NaN
            df = pd.read_csv(file_path, dtype=str, keep_default_na=False)
            self.write_log(f"成功读取CSV文件: {file_path}, 共 {len(df)} 行")
        except Exception as e:
            msg = f"错误：读取CSV文件失败 {file_path} - {e}"
            self.write_log(msg)
            traceback.print_exc()
            return False, msg

        # 3. 解析数据行，创建 BarData 对象列表
        bars: List[BarData] = []
        imported_count = 0
        failed_count = 0

        # 获取vnpy gateway实例名称，BarData需要gateway_name
        # 暂定使用默认的TIGER, 或许可以从配置读取或作为参数传入
        gateway_name = "TIGER"

        required_headers = {
            datetime_head, open_head, high_head, low_head,
            close_head, volume_head, open_interest_head
        }
        if not required_headers.issubset(df.columns):
             missing_headers = required_headers - set(df.columns)
             msg = f"错误：CSV文件缺少必要的列: {missing_headers}"
             self.write_log(msg)
             return False, msg

        for index, row in df.iterrows():
            try:
                # 解析时间戳
                dt_str = row[datetime_head]
                dt = datetime.strptime(dt_str, datetime_format)

                # 解析价格和成交量/持仓量，处理空字符串或非数字值
                # 尝试转换为浮点数，如果失败（例如空字符串），则设为 0.0
                open_price = float(row[open_head]) if row[open_head] else 0.0
                high_price = float(row[high_head]) if row[high_head] else 0.0
                low_price = float(row[low_head]) if row[low_head] else 0.0
                close_price = float(row[close_head]) if row[close_head] else 0.0
                volume = float(row[volume_head]) if row[volume_head] else 0.0
                open_interest = float(row[open_interest_head]) if row[open_interest_head] else 0.0

                # 创建BarData对象
                bar = BarData(
                    symbol=symbol,
                    exchange=exchange,
                    datetime=dt,
                    interval=interval,
                    volume=volume,
                    open_price=open_price,
                    high_price=high_price,
                    low_price=low_price,
                    close_price=close_price,
                    open_interest=open_interest,
                    gateway_name=gateway_name # BarData 需要 gateway_name
                )
                bars.append(bar)
                imported_count += 1
            except ValueError as ve:
                failed_count += 1
                self.write_log(f"警告：解析CSV第 {index + 2} 行数据失败 (值错误): {row.to_dict()} - {ve}")
            except KeyError as ke:
                failed_count += 1
                self.write_log(f"警告：解析CSV第 {index + 2} 行数据失败 (列名错误): {row.to_dict()} - {ke}")
            except Exception as e:
                failed_count += 1
                self.write_log(f"警告：解析CSV第 {index + 2} 行数据失败 (未知错误): {row.to_dict()} - {e}")
                traceback.print_exc()


        if not bars:
            msg = "错误：未能从CSV文件中解析出任何有效的K线数据。"
            if failed_count > 0:
                msg += f" (共失败 {failed_count} 行)"
            self.write_log(msg)
            return False, msg

        # 4. 调用 database_manager.save_bar_data() 保存数据
        try:
            database_manager.save_bar_data(bars)
            success_msg = f"成功导入 {imported_count} 条K线数据到数据库。"
            if failed_count > 0:
                success_msg += f" (跳过 {failed_count} 条错误数据)"
            self.write_log(success_msg)
            return True, success_msg
        except Exception as e:
            msg = f"错误：保存导入的K线数据到数据库时失败 - {e}"
            self.write_log(msg)
            traceback.print_exc()
            return False, msg

    def import_data_from_qlib(
        self,
        qlib_dir: str,
        symbol: str,
        exchange: Exchange,
        interval: Interval,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Tuple[bool, str]:
        """从Qlib格式导入K线数据"""
        self.write_log(f"开始从Qlib导入数据: {qlib_dir}, 合约: {symbol}.{exchange.value}, 周期: {interval.value}")

        # 1. 检查目录是否存在
        if not os.path.exists(qlib_dir):
            msg = f"错误：Qlib数据目录不存在 {qlib_dir}"
            self.write_log(msg)
            return False, msg

        # 2. 使用QlibDataImporter导入数据
        try:
            importer = QlibDataImporter()
            success, message, bars = importer.import_data(
                qlib_dir=qlib_dir,
                symbol=symbol,
                exchange=exchange,
                interval=interval,
                start_date=start_date,
                end_date=end_date
            )

            if not success or not bars:
                self.write_log(f"从Qlib导入数据失败: {message}")
                return False, message

            # 3. 保存数据到数据库
            try:
                database_manager.save_bar_data(bars)
                success_msg = f"成功从Qlib导入 {len(bars)} 条K线数据到数据库。"
                self.write_log(success_msg)
                return True, success_msg
            except Exception as e:
                msg = f"错误：保存从Qlib导入的K线数据到数据库时失败 - {e}"
                self.write_log(msg)
                traceback.print_exc()
                return False, msg

        except Exception as e:
            msg = f"错误：从Qlib导入数据时发生异常 - {e}"
            self.write_log(msg)
            traceback.print_exc()
            return False, msg

    # ---- 数据管理功能 ----

    def delete_bar_data(
        self,
        symbol: str,
        exchange: Exchange,
        interval: Interval
    ) -> Tuple[bool, str]:
        """删除K线数据"""
        try:
            count = database_manager.delete_bar_data(
                symbol=symbol,
                exchange=exchange,
                interval=interval
            )
            return True, f"成功删除 {count} 条K线数据"
        except Exception as e:
            return False, f"删除数据出错：{str(e)}"

    def delete_tick_data(
        self,
        symbol: str,
        exchange: Exchange
    ) -> Tuple[bool, str]:
        """删除Tick数据"""
        try:
            count = database_manager.delete_tick_data(
                symbol=symbol,
                exchange=exchange
            )
            return True, f"成功删除 {count} 条Tick数据"
        except Exception as e:
            return False, f"删除数据出错：{str(e)}"

```

### `/simpletrade/simpletrade/apps/st_datamanager/__init__.py`
*(统计信息: 24 行, 488 字符 [~0.07%])*
```python
"""
SimpleTrade数据管理应用

提供数据管理功能，包括数据下载、导入、导出、查看和管理。
扩展vnpy_datamanager，添加API接口和消息指令处理功能。
"""

from pathlib import Path

from simpletrade.core.app import STBaseApp
from .engine import STDataManagerEngine

APP_NAME = "st_datamanager"

class STDataManagerApp(STBaseApp):
    """SimpleTrade数据管理应用"""

    app_name = APP_NAME
    app_module = __module__
    app_path = Path(__file__).parent
    display_name = "ST数据管理"
    engine_class = STDataManagerEngine
    widget_class = None  # 不需要图形界面

```

### `/simpletrade/simpletrade/apps/st_datamanager/importers/qlib_importer.py`
*(统计信息: 428 行, 18258 字符 [~2.61%])*
```python
"""
Qlib数据格式导入器

用于将qlib格式的数据导入到SimpleTrade系统中。
"""

import os
import sys
import struct
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Tuple, Dict, Any, Optional
from pathlib import Path
import logging

# 添加vendors目录到Python路径
root_path = str(Path(__file__).parent.parent.parent.parent.parent)
vendors_path = os.path.join(root_path, 'vendors')
sys.path.append(vendors_path)

# 导入vnpy相关模块
from vnpy.trader.object import BarData
from vnpy.trader.constant import Exchange, Interval

# 导入基类
from .base_importer import BaseDataImporter

logger = logging.getLogger(__name__) # Setup logger for the importer module

class QlibDataImporter(BaseDataImporter):
    """Qlib数据格式导入器"""

    def __init__(self):
        """初始化"""
        # 定义qlib数据字段映射
        self.qlib_fields = {
            'open': 'open_price',
            'high': 'high_price',
            'low': 'low_price',
            'close': 'close_price',
            'volume': 'volume',
            'factor': 'open_interest',  # 使用factor作为open_interest
            # 'change': 'change'  # 移除：价格变化百分比，VnPy BarData无此字段
        }

        # 支持的周期映射
        self.interval_map = {
            Interval.DAILY: 'day',
            Interval.MINUTE: 'min'
        }

    def extract_and_validate_params(self, target_config: Dict[str, Any]) -> Dict[str, Any]:
        """从目标配置中提取并验证Qlib导入器参数

        Args:
            target_config: 完整的目标配置字典

        Returns:
            处理后的参数字典，可直接用于import_data方法

        Raises:
            ValueError: 当必要参数缺失或无效时
        """
        # 首先获取基类提取的基本参数
        params = super().extract_and_validate_params(target_config)

        # 提取并验证Qlib特有参数：market
        market = target_config.get("market")
        if not market:
            raise ValueError("Missing required parameter for Qlib: market ('cn' or 'us')")

        if market not in ["cn", "us"]:
            raise ValueError(f"Invalid market identifier for Qlib: '{market}'. Expected 'cn' or 'us'.")

        params["market"] = market

        # 处理qlib_dir参数
        qlib_dir = target_config.get("qlib_dir")
        if not qlib_dir:
            # 从配置中获取默认路径
            from simpletrade.config.settings import QLIB_DATA_PATH
            if not QLIB_DATA_PATH:
                raise ValueError("QLIB_DATA_PATH not configured. Set SIMPLETRADE_QLIB_DATA_PATH environment variable.")

            if not os.path.exists(QLIB_DATA_PATH):
                raise ValueError(f"QLIB_DATA_PATH ('{QLIB_DATA_PATH}') does not exist.")

            qlib_dir = QLIB_DATA_PATH
            logger.debug(f"Using default Qlib data path from config: {QLIB_DATA_PATH}")

        params["qlib_dir"] = qlib_dir

        return params

    def _get_market_subdir(self, market: str) -> str:
        """根据市场标识获取子目录名"""
        # 简单映射，可以根据需要扩展
        if market == "cn":
            return "cn_data"
        elif market == "us":
            return "us_data"
        else:
            # 如果市场未知或不支持，可以选择抛出错误或返回空字符串/None
            logger.error(f"Unsupported market identifier: '{market}'. Expected 'cn' or 'us'.")
            # raise ValueError(f"Unsupported market identifier: {market}")
            return "" # 返回空字符串，让后续路径检查失败

    def _read_calendar(self, qlib_dir: str, market: str) -> List[str]:
        """读取交易日历 (根据市场)"""
        market_subdir = self._get_market_subdir(market)
        if not market_subdir:
            return [] # 如果市场无效，无法找到日历

        calendar_path = os.path.join(qlib_dir, market_subdir, 'calendars', 'day.txt')
        logger.debug(f"_read_calendar: Attempting to read calendar from: {calendar_path}")
        if not os.path.exists(calendar_path):
            logger.error(f"Calendar file not found at {calendar_path}")
            return []

        try:
            with open(calendar_path, 'r') as f:
                calendar = [line.strip() for line in f if line.strip()]
            logger.debug(f"_read_calendar: Successfully read calendar with {len(calendar)} entries.")
            return calendar
        except Exception as e:
            logger.error(f"Error reading calendar file {calendar_path}: {e}")
            return []

    def _get_symbol_path(self, qlib_dir: str, market: str, symbol: str) -> str:
        """获取品种数据路径 (根据市场)"""
        market_subdir = self._get_market_subdir(market)
        if not market_subdir:
            return "" # 如果市场无效，无法找到路径

        # 基础 features 目录现在包含市场子目录
        features_dir = os.path.join(qlib_dir, market_subdir, 'features')
        logger.debug(f"_get_symbol_path: Base features directory for market '{market}': {features_dir}")

        # 检查symbol是否直接存在 (例如 AAPL)
        symbol_path = os.path.join(features_dir, symbol)
        logger.debug(f"_get_symbol_path: Checking direct path: {symbol_path}")
        if os.path.exists(symbol_path):
            return symbol_path

        # 如果市场是中国市场 (cn) 且 symbol 是数字，尝试添加 sh/sz 前缀
        if market == "cn" and symbol.isdigit():
            logger.debug(f"_get_symbol_path: CN market and numeric symbol '{symbol}', attempting prefix conversion.")
            # 尝试上海交易所格式
            sh_symbol = f'sh{symbol}'
            sh_path = os.path.join(features_dir, sh_symbol)
            logger.debug(f"_get_symbol_path: Checking SH path: {sh_path}")
            if os.path.exists(sh_path):
                return sh_path

            # 尝试深圳交易所格式
            sz_symbol = f'sz{symbol}'
            sz_path = os.path.join(features_dir, sz_symbol)
            logger.debug(f"_get_symbol_path: Checking SZ path: {sz_path}")
            if os.path.exists(sz_path):
                return sz_path

        # 如果各种尝试都失败，返回最初尝试的直接路径（即使它不存在）
        logger.warning(f"_get_symbol_path: Symbol path not found after checks for market '{market}'. Returning initial attempt: {symbol_path}")
        return symbol_path # 返回这个不存在的路径，让后续逻辑处理

    def _read_bin_file(self, file_path: str) -> pd.DataFrame:
        """读取qlib二进制文件

        qlib的数据格式是一种特殊的二进制格式，每个文件对应一个字段（如open, close, high, low, volume等）
        文件格式为：开始索引（4字节浮点数）+ 一系列数据（4字节浮点数）
        """
        if not os.path.exists(file_path):
            return pd.DataFrame()

        # 获取字段名称
        field_name = os.path.basename(file_path).split('.')[0]

        # 读取二进制文件
        with open(file_path, 'rb') as f:
            # 读取文件头（第一个浮点数是开始索引）
            start_index = struct.unpack('f', f.read(4))[0]

            # 读取所有数据
            data = np.fromfile(f, dtype='<f')

            # 创建日期索引
            indices = np.arange(int(start_index), int(start_index) + len(data))

        # 创建DataFrame
        df = pd.DataFrame({field_name: data}, index=indices)
        # Add logging for shape
        logger.debug(f"_read_bin_file: Read {field_name} from {file_path}. Shape: {df.shape}")
        return df

    def _read_symbol_data(self, qlib_dir: str, market: str, symbol: str, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None) -> pd.DataFrame:
        """读取品种数据 (根据市场)"""
        symbol_path = self._get_symbol_path(qlib_dir, market, symbol)
        logger.info(f"_read_symbol_data: Attempting to read data for symbol '{symbol}' (market: {market}) from path: {symbol_path}")
        if not symbol_path or not os.path.exists(symbol_path): # 检查路径有效性
            logger.error(f"_read_symbol_data: Symbol path is invalid or does not exist: '{symbol_path}'")
            return pd.DataFrame()

        # 获取所有可用的数据文件
        data_files = []
        try:
            # 假设数据文件直接在 symbol_path 下，不包含 day/min 子目录
            for file in os.listdir(symbol_path):
                 # 根据文件扩展名判断周期 (这里简单处理，只找 .bin)
                 # 注意：这可能需要根据 qlib 的实际存储方式调整
                 # 如果 qlib 把日线和分钟线放不同子目录，这里需要修改
                 if file.endswith('.bin'): # 假设直接是 .bin 文件
                    data_files.append(os.path.join(symbol_path, file))
            logger.debug(f"_read_symbol_data: Found .bin files in {symbol_path}: {data_files}")
        except Exception as list_e:
            logger.error(f"_read_symbol_data: Error listing files in {symbol_path}: {list_e}")
            return pd.DataFrame()

        if not data_files:
            logger.warning(f"_read_symbol_data: No .bin files found in {symbol_path}")
            return pd.DataFrame()

        # 读取各个字段的数据
        field_dfs = {}
        for file_path in data_files:
            field_name = os.path.basename(file_path).split('.')[0]
            # Check if field is relevant (e.g., open, high, low, close, volume, factor)
            if field_name in self.qlib_fields:
                try:
                     df_field = self._read_bin_file(file_path)
                     if not df_field.empty:
                         field_dfs[field_name] = df_field
                except Exception as read_bin_e:
                     logger.error(f"_read_symbol_data: Error reading bin file {file_path}: {read_bin_e}")
            else:
                logger.debug(f"_read_symbol_data: Skipping irrelevant file: {file_path}")

        if not field_dfs:
            logger.warning("_read_symbol_data: No relevant data loaded from any .bin files.")
            return pd.DataFrame()

        # 合并所有字段数据
        try:
            all_indices = sorted(set().union(*[df.index for df in field_dfs.values()]))
            result_df = pd.DataFrame(index=all_indices)
            for field_name, df in field_dfs.items():
                result_df[field_name] = df[field_name]
            logger.debug(f"_read_symbol_data: Merged DataFrame shape before datetime conversion: {result_df.shape}")
        except Exception as merge_e:
            logger.error(f"_read_symbol_data: Error merging field DataFrames: {merge_e}")
            return pd.DataFrame()

        # 将索引转换为日期
        calendar = self._read_calendar(qlib_dir, market)
        if not calendar:
            logger.error(f"_read_symbol_data: Cannot convert index to datetime, calendar for market '{market}' not found or empty.")
            return pd.DataFrame()

        logger.debug(f"_read_symbol_data: Using calendar for market '{market}' with {len(calendar)} entries.")
        try:
            date_map = {i: pd.Timestamp(date) for i, date in enumerate(calendar)}
            result_df['datetime'] = result_df.index.map(lambda x: date_map.get(x, pd.NaT))
            logger.debug(f"_read_symbol_data: DataFrame shape after index mapping: {result_df.shape}")

            initial_rows = len(result_df)
            result_df = result_df.dropna(subset=['datetime'])
            dropped_rows = initial_rows - len(result_df)
            if dropped_rows > 0:
                logger.warning(f"_read_symbol_data: Dropped {dropped_rows} rows due to invalid datetime mapping.")
            logger.debug(f"_read_symbol_data: DataFrame shape after dropna('datetime'): {result_df.shape}")

            # --- Localize datetime ---
            # 决定时区：US 市场用 US/Eastern, CN 市场用 Asia/Shanghai
            target_tz = 'Asia/Shanghai' if market == 'cn' else 'US/Eastern'
            logger.debug(f"_read_symbol_data: Attempting to localize datetime to {target_tz}")
            if 'datetime' in result_df.columns and not result_df.empty:
                try:
                    result_df['datetime'] = result_df['datetime'].dt.tz_localize(target_tz, ambiguous='infer')
                    logger.debug(f"_read_symbol_data: Localized datetime column to {target_tz}. Example: {result_df['datetime'].iloc[0] if not result_df.empty else 'N/A'}")
                except Exception as tz_localize_e:
                    logger.error(f"_read_symbol_data: Failed to localize datetime column: {tz_localize_e}")
                    # Decide action: continue with naive or return empty

            # 过滤日期范围 (使用本地化后的日期)
            localized_start_date = None
            localized_end_date = None
            try:
                if start_date:
                    ts_start = pd.Timestamp(start_date)
                    localized_start_date = ts_start.tz_localize(target_tz) if ts_start.tzinfo is None else ts_start.tz_convert(target_tz)
                    logger.debug(f"_read_symbol_data: Localized start_date for filtering: {localized_start_date}")
                if end_date:
                    ts_end = pd.Timestamp(end_date)
                    localized_end_date = ts_end.tz_localize(target_tz) if ts_end.tzinfo is None else ts_end.tz_convert(target_tz)
                    logger.debug(f"_read_symbol_data: Localized end_date for filtering: {localized_end_date}")
            except Exception as filter_localize_e:
                 logger.error(f"_read_symbol_data: Error localizing start/end date for filtering: {filter_localize_e}")
                 return pd.DataFrame()

            initial_rows_before_filter = len(result_df)
            if localized_start_date: result_df = result_df[result_df['datetime'] >= localized_start_date]
            if localized_end_date: result_df = result_df[result_df['datetime'] <= localized_end_date]
            filtered_rows = initial_rows_before_filter - len(result_df)
            if filtered_rows > 0: logger.debug(f"_read_symbol_data: Filtered out {filtered_rows} rows based on date range.")
            logger.info(f"_read_symbol_data: Final DataFrame shape after date filtering: {result_df.shape}")

        except Exception as convert_e:
            logger.error(f"_read_symbol_data: Error during datetime conversion or filtering: {convert_e}", exc_info=True)
            return pd.DataFrame()

        return result_df

    def import_data(
        self,
        symbol: str,
        exchange: Exchange,
        interval: Interval,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        **kwargs
    ) -> Tuple[bool, str, List[BarData]]:
        """导入指定品种、周期的数据

        Args:
            symbol: 品种代码
            exchange: 交易所
            interval: K线周期
            start_date: 开始日期
            end_date: 结束日期
            **kwargs: 额外参数，包括：
                qlib_dir: Qlib数据根目录
                market: 市场标识 ('cn' 或 'us')

        Returns:
            Tuple[bool, str, List[BarData]]: (是否成功, 消息, BarData列表)
        """
        # 从 kwargs 中获取 qlib 特有参数
        qlib_dir = kwargs.get("qlib_dir")
        market = kwargs.get("market")

        if not qlib_dir:
            return False, "Missing required parameter: qlib_dir", []

        if not market:
            return False, "Missing required parameter: market ('cn' or 'us')", []

        # 检查 interval 是否支持 (当前实现主要针对日线 .day.bin)
        if interval != Interval.DAILY:
             msg = f"Unsupported interval for Qlib importer: {interval}. Currently only supports Daily."
             logger.warning(msg)
             return False, msg, []

        # 检查市场标识是否有效
        if market not in ["cn", "us"]:
            msg = f"Invalid market identifier: '{market}'. Expected 'cn' or 'us'."
            logger.error(msg)
            return False, msg, []

        logger.info(f"Starting Qlib import: Market={market}, Symbol={symbol}, Interval={interval}, Exchange={exchange} from {qlib_dir}")

        # 读取数据到 DataFrame
        try:
            data_df = self._read_symbol_data(qlib_dir, market, symbol, start_date, end_date)
        except Exception as e:
            msg = f"Error reading symbol data for {symbol} (market {market}): {e}"
            logger.error(msg, exc_info=True)
            return False, msg, []

        if data_df.empty:
            msg = f"No data found or loaded for {symbol} (market {market}) in the specified period or path."
            logger.warning(msg)
            return True, msg, [] # 认为成功，但没有数据

        # 转换 DataFrame 为 BarData 列表
        bars: List[BarData] = []
        try:
            for _, row in data_df.iterrows():
                # 获取必要字段，使用 .get 提供默认值以防字段缺失
                dt = row.get('datetime')
                open_price = float(row.get('open', 0.0) or 0.0)
                high_price = float(row.get('high', 0.0) or 0.0)
                low_price = float(row.get('low', 0.0) or 0.0)
                close_price = float(row.get('close', 0.0) or 0.0)
                volume = float(row.get('volume', 0.0) or 0.0)
                open_interest = float(row.get('factor', 0.0) or 0.0) # 从 factor 映射

                # 检查数据有效性 (例如 datetime 是否存在)
                if pd.isna(dt):
                    logger.warning(f"Skipping row due to missing datetime: {row.to_dict()}")
                    continue
                if high_price < low_price or any(p < 0 for p in [open_price, high_price, low_price, close_price]) or volume < 0:
                    logger.warning(f"Skipping row due to invalid price/volume data: {row.to_dict()}")
                    continue

                # 转换时区到 UTC (因为 VnPy 内部通常期望 UTC)
                # 之前已经本地化到市场时区，现在转换为 UTC
                try:
                     dt_utc = dt.tz_convert('UTC')
                     # Convert to Python datetime
                     dt_py = dt_utc.to_pydatetime()
                except Exception as utc_convert_e:
                     logger.error(f"Failed to convert datetime {dt} to UTC or Python datetime: {utc_convert_e}")
                     continue # Skip if conversion fails

                bar = BarData(
                    symbol=symbol,
                    exchange=exchange,
                    datetime=dt_py,
                    interval=interval,
                    volume=volume,
                    open_price=open_price,
                    high_price=high_price,
                    low_price=low_price,
                    close_price=close_price,
                    open_interest=open_interest,
                    gateway_name="QIMPORT" # 标记数据来源
                )
                bars.append(bar)

            msg = f"Successfully converted {len(bars)} bars from DataFrame for {symbol} (market {market})."
            logger.info(msg)
            return True, msg, bars

        except Exception as convert_e:
            msg = f"Error converting DataFrame to BarData for {symbol} (market {market}): {convert_e}"
            logger.error(msg, exc_info=True)
            return False, msg, []

```

### `/simpletrade/simpletrade/apps/st_datamanager/importers/base_importer.py`
*(统计信息: 70 行, 1732 字符 [~0.25%])*
```python
"""
数据导入器基类

定义所有数据导入器必须实现的标准接口。
"""

from abc import ABC, abstractmethod
from datetime import datetime
from typing import List, Tuple, Optional, Dict, Any

from vnpy.trader.constant import Exchange, Interval
from vnpy.trader.object import BarData

class BaseDataImporter(ABC):
    """数据导入器基类

    所有数据导入器必须继承此类并实现 import_data 方法。
    """

    def extract_and_validate_params(self, target_config: Dict[str, Any]) -> Dict[str, Any]:
        """从目标配置中提取并验证导入参数

        从完整的目标配置中提取此导入器所需的特定参数，并进行验证。
        子类应当重写此方法以实现特定的参数提取和验证逻辑。

        Args:
            target_config: 完整的目标配置字典

        Returns:
            处理后的参数字典，可直接用于import_data方法

        Raises:
            ValueError: 当必要参数缺失或无效时
        """
        # 提取基本参数（所有导入器通用）
        params = {
            "symbol": target_config.get("symbol"),
            "exchange": target_config.get("exchange"),
            "interval": target_config.get("interval"),
            "start_date": target_config.get("start_date"),
            "end_date": target_config.get("end_date")
        }

        # 基类默认实现：不提取额外参数
        return params

    @abstractmethod
    def import_data(
        self,
        symbol: str,
        exchange: Exchange,
        interval: Interval,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        **kwargs
    ) -> Tuple[bool, str, List[BarData]]:
        """导入数据的抽象方法

        Args:
            symbol: 品种代码
            exchange: 交易所
            interval: K线周期
            start_date: 开始日期
            end_date: 结束日期
            **kwargs: 额外参数，可由具体导入器定义

        Returns:
            (是否成功, 消息, BarData列表)
        """
        pass
```

### `/simpletrade/simpletrade/apps/st_datamanager/importers/importer_factory.py`
*(统计信息: 56 行, 1495 字符 [~0.21%])*
```python
"""
数据导入器工厂

负责管理和创建不同的数据导入器实例。
"""

from typing import Dict, Type, Optional
import logging

from .base_importer import BaseDataImporter

logger = logging.getLogger(__name__)

class ImporterFactory:
    """数据导入器工厂

    负责管理和创建各种数据导入器。
    """

    _importers: Dict[str, Type[BaseDataImporter]] = {}

    @classmethod
    def register_importer(cls, source_name: str, importer_class: Type[BaseDataImporter]) -> None:
        """注册新的导入器类

        Args:
            source_name: 数据源名称
            importer_class: 导入器类，必须继承 BaseDataImporter
        """
        if not issubclass(importer_class, BaseDataImporter):
            raise TypeError(f"Importer class must inherit from BaseDataImporter")

        cls._importers[source_name.lower()] = importer_class
        logger.info(f"Registered data importer for source: {source_name}")

    @classmethod
    def create_importer(cls, source_name: str) -> Optional[BaseDataImporter]:
        """创建指定数据源的导入器实例

        Args:
            source_name: 数据源名称

        Returns:
            导入器实例，如果数据源未注册则返回 None
        """
        importer_class = cls._importers.get(source_name.lower())
        if not importer_class:
            logger.warning(f"No registered importer found for source: {source_name}")
            return None

        return importer_class()

    @classmethod
    def get_supported_sources(cls) -> list:
        """获取所有支持的数据源列表"""
        return list(cls._importers.keys())
```

### `/simpletrade/simpletrade/apps/st_datamanager/importers/__init__.py`
*(统计信息: 19 行, 324 字符 [~0.05%])*
```python
"""
数据导入器包

包含各种数据源导入器的实现。
"""

from .base_importer import BaseDataImporter
from .importer_factory import ImporterFactory
from .qlib_importer import QlibDataImporter

# 注册内置的导入器
ImporterFactory.register_importer("qlib", QlibDataImporter)

__all__ = [
    "BaseDataImporter",
    "ImporterFactory",
    "QlibDataImporter",
]

```

### `/simpletrade/simpletrade/apps/st_datamanager/api/routes.py`
*(统计信息: 488 行, 16154 字符 [~2.31%])*
```python
"""
SimpleTrade数据管理API路由

定义数据管理的RESTful API路由。
"""

import os
import sys
from datetime import datetime
from typing import List, Optional, Dict, Any
from pathlib import Path

from fastapi import APIRouter, Query, Path, Body, HTTPException, Depends, UploadFile, File
from pydantic import BaseModel, Field

# 导入vnpy相关模块
# Revert to standard vnpy imports
from vnpy.trader.constant import Exchange, Interval
from vnpy.trader.object import BarData as VnpyBarData # Rename to avoid conflict
# # Ensure consistent vnpy import path (should be vnpy.vnpy.*)
# # from vnpy.vnpy.trader.constant import Exchange, Interval
# # from vnpy.vnpy.trader.object import BarData as VnpyBarData # Rename to avoid conflict
# # try:
# #     from vnpy.trader.constant import Exchange, Interval

import logging
import traceback

from simpletrade.apps.st_datamanager import STDataManagerApp # 导入 App 类

# 创建路由器
router = APIRouter(prefix="/api/data", tags=["data"])

# 设置日志
logger = logging.getLogger("simpletrade.apps.st_datamanager.api")

# 数据模型
class ApiResponse(BaseModel):
    """API响应模型"""
    success: bool
    message: str
    data: Optional[Any] = None

class BarData(BaseModel):
    """K线数据模型"""
    datetime: str
    open_price: float # Field(..., alias="open")
    high_price: float # Field(..., alias="high")
    low_price: float # Field(..., alias="low")
    close_price: float # Field(..., alias="close")
    volume: float
    open_interest: float

    class Config:
        allow_population_by_field_name = True

class DataOverview(BaseModel):
    """数据概览模型"""
    symbol: str
    exchange: str
    interval: Optional[str] = None
    count: int
    start: str
    end: str
    type: str

class DownloadRequest(BaseModel):
    """下载请求模型"""
    symbol: str
    exchange: str
    interval: str
    start_date: str
    end_date: Optional[str] = None

class ImportCsvRequestParams(BaseModel):
    """CSV导入请求参数模型 (for query/form data)"""
    symbol: str
    exchange: str
    interval: str
    datetime_head: str
    open_head: str
    high_head: str
    low_head: str
    close_head: str
    volume_head: str
    open_interest_head: str
    datetime_format: str = "%Y-%m-%d %H:%M:%S"

class ImportQlibRequest(BaseModel):
    """导入Qlib数据请求模型"""
    qlib_dir: str
    symbol: str
    exchange: str
    interval: str
    start_date: Optional[str] = None
    end_date: Optional[str] = None

class ExportRequest(BaseModel):
    """导出请求模型"""
    symbol: str
    exchange: str
    interval: str
    start_date: str
    end_date: str
    file_path: str

# 依赖注入：获取数据管理引擎
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)  # 设置为DEBUG级别

def get_data_manager_engine():
    """获取数据管理引擎"""
    # 这里需要从全局获取引擎实例
    # 实际实现时需要根据SimpleTrade的架构调整
    from simpletrade.main import main_engine
    # 使用 App 类的 __name__ 属性来获取实例
    # engine_instance = main_engine.get_engine(STDataManagerApp.__name__)
    # 使用 app_name 属性来获取实例
    engine_instance = main_engine.get_engine(STDataManagerApp.app_name)
    logger.info(f"get_data_manager_engine called. Requested engine name: {STDataManagerApp.app_name}, got instance: {engine_instance}") # 更新日志
    return engine_instance

# API路由
@router.get("/symbols", response_model=ApiResponse)
async def get_symbols():
    """获取可用的交易品种列表"""
    logger.info("Entering get_symbols endpoint")
    try:
        # 从数据库获取交易品种
        from simpletrade.config.database import get_db
        from simpletrade.models.database import Symbol

        db = next(get_db())  # 获取数据库会话
        try:
            db_symbols = db.query(Symbol).filter(Symbol.is_active == True).all()

            # 如果数据库中没有数据，返回测试数据
            if not db_symbols:
                logger.warning("No symbols found in database, returning test data")
                symbols = [
                    {"symbol": "AAPL", "exchange": "SMART", "name": "Apple Inc.", "category": "Stock"},
                    {"symbol": "MSFT", "exchange": "SMART", "name": "Microsoft Corporation", "category": "Stock"},
                    {"symbol": "GOOG", "exchange": "SMART", "name": "Alphabet Inc.", "category": "Stock"},
                    {"symbol": "AMZN", "exchange": "SMART", "name": "Amazon.com, Inc.", "category": "Stock"},
                    {"symbol": "FB", "exchange": "SMART", "name": "Meta Platforms, Inc.", "category": "Stock"}
                ]
            else:
                # 将数据库对象转换为字典
                symbols = [
                    {
                        "symbol": s.symbol,
                        "exchange": s.exchange,
                        "name": s.name,
                        "category": s.category
                    } for s in db_symbols
                ]
        finally:
            db.close()  # 确保关闭会话

        return {
            "success": True,
            "message": f"获取交易品种成功，共 {len(symbols)} 个",
            "data": symbols
        }
    except Exception as e:
        logger.error(f"Error getting symbols: {e}")
        return {
            "success": False,
            "message": f"获取交易品种失败: {str(e)}"
        }

@router.get("/overview", response_model=ApiResponse)
async def get_data_overview(
    engine = Depends(get_data_manager_engine) # 启用依赖注入
):
    """获取数据概览"""
    logger.info(f"Entering st_datamanager get_data_overview") # 更新日志信息
    if not engine:
        logger.error("Dependency injection returned None for engine!")
        raise HTTPException(status_code=500, detail="Data manager engine not available.")
    try:
        # 直接调用引擎的 get_available_data 方法获取合并后的概览
        logger.info(f"Calling engine.get_available_data() on {engine}...")
        available_data = engine.get_available_data()
        logger.info(f"Available data received: {len(available_data)}")

        # get_available_data 返回的已经是 Dict 列表，可以直接使用
        logger.info("数据概览获取完成，准备返回响应.")
        return {
            "success": True,
            "message": "获取数据概览成功", # 更新成功消息
            "data": available_data # 返回引擎处理好的数据
        }
    except Exception as e:
        logger.error(f"Error in st_datamanager get_data_overview: {e}")
        traceback.print_exc() # 强制打印堆栈
        raise HTTPException(status_code=500, detail="获取数据概览时发生服务器内部错误。") # 返回通用错误信息

@router.get("/bars", response_model=ApiResponse)
async def get_bars(
    symbol: str,
    exchange: str,
    interval: str,
    start_date: str,
    end_date: Optional[str] = None,
    engine = Depends(get_data_manager_engine)
):
    """获取K线数据"""
    try:
        # 解析参数
        exchange_obj = Exchange(exchange)
        interval_obj = Interval(interval)
        start = datetime.strptime(start_date, "%Y-%m-%d")
        end = datetime.now()
        if end_date:
            end = datetime.strptime(end_date, "%Y-%m-%d")

        # 加载数据
        bars: List[VnpyBarData] = engine.get_bar_data(
            symbol=symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start=start,
            end=end
        )

        # 转换为API模型
        result = []
        for bar in bars:
            result.append({
                "datetime": bar.datetime.strftime("%Y-%m-%d %H:%M:%S"),
                "open_price": bar.open_price,
                "high_price": bar.high_price,
                "low_price": bar.low_price,
                "close_price": bar.close_price,
                "volume": bar.volume,
                "open_interest": bar.open_interest
            })

        return {
            "success": True,
            "message": f"获取K线数据成功，共 {len(bars)} 条",
            "data": result
        }
    except ValueError as ve:
        logger.error(f"Invalid parameter value: {ve}")
        raise HTTPException(status_code=400, detail=f"Invalid parameter value: {ve}")
    except Exception as e:
        logger.error(f"Error getting bars: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="获取K线数据时发生错误")

@router.post("/download", response_model=ApiResponse)
async def download_data(
    request: DownloadRequest,
    engine = Depends(get_data_manager_engine)
):
    """下载历史数据"""
    try:
        # 解析参数
        exchange_obj = Exchange(request.exchange)
        interval_obj = Interval(request.interval)
        start = datetime.strptime(request.start_date, "%Y-%m-%d")
        end = datetime.now()
        if request.end_date:
            end = datetime.strptime(request.end_date, "%Y-%m-%d")

        # 下载数据
        success = engine.download_bar_data(
            symbol=request.symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start=start,
            end=end
        )

        if success:
            return {
                "success": True,
                "message": f"成功下载 {request.symbol}.{request.exchange} 的 {request.interval} 数据"
            }
        else:
            return {
                "success": False,
                "message": f"下载 {request.symbol}.{request.exchange} 的 {request.interval} 数据失败"
            }
    except Exception as e:
        logger.error(f"Error downloading data: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="下载数据时发生错误")

@router.post("/import/csv", response_model=ApiResponse)
async def import_data_from_csv_upload(
    params: ImportCsvRequestParams = Depends(), # Use Depends for form data or query params
    file: UploadFile = File(...),
    engine = Depends(get_data_manager_engine)
):
    """通过上传CSV文件导入K线数据"""
    if not engine:
        logger.error("Data manager engine not available via dependency injection.")
        raise HTTPException(status_code=500, detail="数据管理引擎不可用")

    # Create a temporary file to store the uploaded content
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".csv", mode="wb") as tmp_file:
            shutil.copyfileobj(file.file, tmp_file)
            temp_file_path = tmp_file.name
        logger.info(f"Uploaded CSV file saved temporarily to: {temp_file_path}")

        # Parse parameters
        try:
            exchange_obj = Exchange(params.exchange)
            interval_obj = Interval(params.interval)
        except ValueError as e:
            logger.error(f"Invalid exchange or interval: {e}")
            raise HTTPException(status_code=400, detail=f"无效的交易所或周期: {e}")

        # Call the engine's import function with the temporary file path
        success, message = engine.import_data_from_csv(
            file_path=temp_file_path,
            symbol=params.symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            datetime_head=params.datetime_head,
            open_head=params.open_head,
            high_head=params.high_head,
            low_head=params.low_head,
            close_head=params.close_head,
            volume_head=params.volume_head,
            open_interest_head=params.open_interest_head,
            datetime_format=params.datetime_format
        )

        return {
            "success": success,
            "message": message
        }

    except Exception as e:
        logger.error(f"Error importing CSV: {e}")
        traceback.print_exc()
        # Ensure detail message is helpful but avoids leaking sensitive info
        error_detail = f"导入CSV文件时发生错误: {type(e).__name__}"
        if isinstance(e, FileNotFoundError):
            error_detail = "处理上传文件时出错"
        elif isinstance(e, HTTPException):
            error_detail = e.detail # Propagate specific HTTP errors
        # Add more specific error handling if needed
        raise HTTPException(status_code=500, detail=error_detail)
    finally:
        # Clean up the temporary file
        if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
            try:
                os.remove(temp_file_path)
                logger.info(f"Temporary file {temp_file_path} removed.")
            except Exception as cleanup_error:
                logger.error(f"Error removing temporary file {temp_file_path}: {cleanup_error}")
        # Ensure the uploaded file resource is closed
        if file:
            await file.close()

@router.post("/import/qlib", response_model=ApiResponse)
async def import_qlib_data(
    request: ImportQlibRequest,
    engine = Depends(get_data_manager_engine)
):
    """导入Qlib格式数据"""
    try:
        # 解析参数
        exchange_obj = Exchange(request.exchange)
        interval_obj = Interval(request.interval)

        # 解析日期
        start_date = None
        end_date = None
        if request.start_date:
            start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
        if request.end_date:
            end_date = datetime.strptime(request.end_date, "%Y-%m-%d")

        # 导入数据
        success, msg = engine.import_data_from_qlib(
            qlib_dir=request.qlib_dir,
            symbol=request.symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start_date=start_date,
            end_date=end_date
        )

        return {
            "success": success,
            "message": msg
        }
    except Exception as e:
        logger.error(f"Error importing Qlib data: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="导入Qlib数据时发生错误")

@router.post("/export", response_model=ApiResponse)
async def export_data(
    request: ExportRequest,
    engine = Depends(get_data_manager_engine)
):
    """导出数据"""
    try:
        # 解析参数
        exchange_obj = Exchange(request.exchange)
        interval_obj = Interval(request.interval)
        start = datetime.strptime(request.start_date, "%Y-%m-%d")
        end = datetime.strptime(request.end_date, "%Y-%m-%d")

        # 导出数据
        success, msg = engine.export_data_to_csv(
            symbol=request.symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start=start,
            end=end,
            file_path=request.file_path
        )

        return {
            "success": success,
            "message": msg
        }
    except Exception as e:
        logger.error(f"Error exporting data: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="导出数据时发生错误")

@router.delete("/bar/{exchange}/{symbol}/{interval}", response_model=ApiResponse)
async def delete_bar_data(
    exchange: str = Path(..., title="交易所"),
    symbol: str = Path(..., title="代码"),
    interval: str = Path(..., title="周期"),
    engine = Depends(get_data_manager_engine)
):
    """删除指定的K线数据"""
    if not engine:
        logger.error("Data manager engine not available.")
        raise HTTPException(status_code=500, detail="数据管理引擎不可用")
    try:
        exchange_obj = Exchange(exchange)
        interval_obj = Interval(interval)
    except ValueError as e:
        logger.error(f"Invalid exchange or interval: {e}")
        raise HTTPException(status_code=400, detail=f"无效的交易所或周期: {e}")

    try:
        success, message = engine.delete_bar_data(
            symbol=symbol,
            exchange=exchange_obj,
            interval=interval_obj
        )
        return {"success": success, "message": message}
    except Exception as e:
        logger.error(f"Error deleting bar data: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="删除K线数据时发生错误")

@router.delete("/tick/{exchange}/{symbol}", response_model=ApiResponse)
async def delete_tick_data(
    exchange: str = Path(..., title="交易所"),
    symbol: str = Path(..., title="代码"),
    engine = Depends(get_data_manager_engine)
):
    """删除指定的Tick数据"""
    if not engine:
        logger.error("Data manager engine not available.")
        raise HTTPException(status_code=500, detail="数据管理引擎不可用")
    try:
        exchange_obj = Exchange(exchange)
    except ValueError as e:
        logger.error(f"Invalid exchange: {e}")
        raise HTTPException(status_code=400, detail=f"无效的交易所: {e}")

    try:
        success, message = engine.delete_tick_data(
            symbol=symbol,
            exchange=exchange_obj
        )
        return {"success": success, "message": message}
    except Exception as e:
        logger.error(f"Error deleting tick data: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="删除Tick数据时发生错误")

```

### `/simpletrade/simpletrade/apps/st_datamanager/api/__init__.py`
*(统计信息: 8 行, 86 字符 [~0.01%])*
```python
"""
SimpleTrade数据管理API模块

提供RESTful API接口，用于访问数据管理功能。
"""

from .routes import router

```

### `/simpletrade/simpletrade/apps/st_datamanager/commands/processor.py`
*(统计信息: 345 行, 11333 字符 [~1.62%])*
```python
"""
SimpleTrade数据管理命令处理器

处理数据管理相关的消息指令。
"""

import re
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple

from vnpy.trader.constant import Exchange, Interval

class DataCommandProcessor:
    """数据管理命令处理器"""

    def __init__(self, engine):
        """初始化"""
        self.engine = engine
        self.commands = {
            "query": self.cmd_query,
            "download": self.cmd_download,
            "import": self.cmd_import,
            "export": self.cmd_export,
            "delete": self.cmd_delete,
            "help": self.cmd_help,
        }

    def process(self, command_text: str) -> str:
        """处理命令"""
        # 检查命令前缀
        if not command_text.startswith("/data"):
            return ""

        # 解析命令
        parts = command_text.split()
        if len(parts) < 2:
            return "无效的命令格式。使用 `/data help` 获取帮助。"

        cmd = parts[1].lower()
        args = parts[2:]

        # 执行命令
        if cmd in self.commands:
            try:
                return self.commands[cmd](args)
            except Exception as e:
                return f"命令执行错误: {str(e)}"
        else:
            return f"未知命令: {cmd}。使用 `/data help` 获取帮助。"

    def cmd_query(self, args: List[str]) -> str:
        """查询数据命令"""
        if not args:
            # 查询所有可用数据
            data = self.engine.get_available_data()
            if not data:
                return "数据库中没有可用数据。"

            result = "可用数据列表:\n"
            for i, item in enumerate(data[:10]):  # 只显示前10条
                if item["type"] == "bar":
                    result += f"{i+1}. {item['symbol']}.{item['exchange']} - {item['interval']} - {item['count']}条 ({item['start']} 至 {item['end']})\n"
                else:
                    result += f"{i+1}. {item['symbol']}.{item['exchange']} - Tick - {item['count']}条 ({item['start']} 至 {item['end']})\n"

            if len(data) > 10:
                result += f"... 共 {len(data)} 条记录"

            return result

        if len(args) < 4:
            return "格式: /data query [类型] [代码] [交易所] [周期] [开始日期] [结束日期(可选)]"

        data_type = args[0]  # bar 或 tick
        symbol = args[1]
        exchange = args[2]

        if data_type == "bar":
            if len(args) < 5:
                return "格式: /data query bar [代码] [交易所] [周期] [开始日期] [结束日期(可选)]"

            interval = args[3]
            start_date = args[4]
            end_date = None
            if len(args) > 5:
                end_date = args[5]

            try:
                # 解析参数
                exchange_obj = Exchange(exchange)
                interval_obj = Interval(interval)
                start = datetime.strptime(start_date, "%Y-%m-%d")
                end = datetime.now()
                if end_date:
                    end = datetime.strptime(end_date, "%Y-%m-%d")

                # 查询数据
                bars = self.engine.get_bar_data(
                    symbol=symbol,
                    exchange=exchange_obj,
                    interval=interval_obj,
                    start=start,
                    end=end
                )

                if not bars:
                    return "未找到符合条件的数据"

                # 格式化输出
                result = f"查询到 {len(bars)} 条K线数据:\n"
                for i, bar in enumerate(bars[:5]):  # 只显示前5条
                    result += f"{i+1}. {bar.datetime.strftime('%Y-%m-%d %H:%M:%S')}: 开{bar.open_price} 高{bar.high_price} 低{bar.low_price} 收{bar.close_price} 量{bar.volume}\n"

                if len(bars) > 5:
                    result += f"... 共 {len(bars)} 条数据"

                return result
            except Exception as e:
                return f"查询出错: {str(e)}"

        elif data_type == "tick":
            if len(args) < 4:
                return "格式: /data query tick [代码] [交易所] [开始日期] [结束日期(可选)]"

            start_date = args[3]
            end_date = None
            if len(args) > 4:
                end_date = args[4]

            try:
                # 解析参数
                exchange_obj = Exchange(exchange)
                start = datetime.strptime(start_date, "%Y-%m-%d")
                end = datetime.now()
                if end_date:
                    end = datetime.strptime(end_date, "%Y-%m-%d")

                # 查询数据
                ticks = self.engine.get_tick_data(
                    symbol=symbol,
                    exchange=exchange_obj,
                    start=start,
                    end=end
                )

                if not ticks:
                    return "未找到符合条件的数据"

                # 格式化输出
                result = f"查询到 {len(ticks)} 条Tick数据:\n"
                for i, tick in enumerate(ticks[:5]):  # 只显示前5条
                    result += f"{i+1}. {tick.datetime.strftime('%Y-%m-%d %H:%M:%S.%f')}: 最新{tick.last_price} 买1{tick.bid_price_1}({tick.bid_volume_1}) 卖1{tick.ask_price_1}({tick.ask_volume_1})\n"

                if len(ticks) > 5:
                    result += f"... 共 {len(ticks)} 条数据"

                return result
            except Exception as e:
                return f"查询出错: {str(e)}"

        return f"不支持的数据类型: {data_type}。支持的类型: bar, tick"

    def cmd_download(self, args: List[str]) -> str:
        """下载数据命令"""
        if len(args) < 4:
            return "格式: /data download [代码] [交易所] [周期] [开始日期] [结束日期(可选)]"

        symbol = args[0]
        exchange = args[1]
        interval = args[2]
        start_date = args[3]
        end_date = None
        if len(args) > 4:
            end_date = args[4]

        try:
            # 解析参数
            exchange_obj = Exchange(exchange)
            interval_obj = Interval(interval)
            start = datetime.strptime(start_date, "%Y-%m-%d")
            end = datetime.now()
            if end_date:
                end = datetime.strptime(end_date, "%Y-%m-%d")

            # 下载数据
            success = self.engine.download_bar_data(
                symbol=symbol,
                exchange=exchange_obj,
                interval=interval_obj,
                start=start,
                end=end
            )

            if success:
                return f"成功下载 {symbol}.{exchange} 的 {interval} 数据"
            else:
                return f"下载 {symbol}.{exchange} 的 {interval} 数据失败"
        except Exception as e:
            return f"下载出错: {str(e)}"

    def cmd_import(self, args: List[str]) -> str:
        """导入数据命令"""
        if len(args) < 12:
            return """格式: /data import [文件路径] [代码] [交易所] [周期] [时间列名] [开盘列名] [最高列名] [最低列名] [收盘列名] [成交量列名] [持仓量列名] [时间格式]

例如: /data import /path/to/data.csv AAPL SMART 1d datetime open high low close volume open_interest "%Y-%m-%d %H:%M:%S"
            """

        file_path = args[0]
        symbol = args[1]
        exchange = args[2]
        interval = args[3]
        datetime_head = args[4]
        open_head = args[5]
        high_head = args[6]
        low_head = args[7]
        close_head = args[8]
        volume_head = args[9]
        open_interest_head = args[10]
        datetime_format = args[11]

        try:
            # 解析参数
            exchange_obj = Exchange(exchange)
            interval_obj = Interval(interval)

            # 导入数据
            success, msg = self.engine.import_data_from_csv(
                file_path=file_path,
                symbol=symbol,
                exchange=exchange_obj,
                interval=interval_obj,
                datetime_head=datetime_head,
                open_head=open_head,
                high_head=high_head,
                low_head=low_head,
                close_head=close_head,
                volume_head=volume_head,
                open_interest_head=open_interest_head,
                datetime_format=datetime_format
            )

            return msg
        except Exception as e:
            return f"导入出错: {str(e)}"

    def cmd_export(self, args: List[str]) -> str:
        """导出数据命令"""
        if len(args) < 6:
            return "格式: /data export [代码] [交易所] [周期] [开始日期] [结束日期] [文件路径]"

        symbol = args[0]
        exchange = args[1]
        interval = args[2]
        start_date = args[3]
        end_date = args[4]
        file_path = args[5]

        try:
            # 解析参数
            exchange_obj = Exchange(exchange)
            interval_obj = Interval(interval)
            start = datetime.strptime(start_date, "%Y-%m-%d")
            end = datetime.strptime(end_date, "%Y-%m-%d")

            # 导出数据
            success, msg = self.engine.export_data_to_csv(
                symbol=symbol,
                exchange=exchange_obj,
                interval=interval_obj,
                start=start,
                end=end,
                file_path=file_path
            )

            return msg
        except Exception as e:
            return f"导出出错: {str(e)}"

    def cmd_delete(self, args: List[str]) -> str:
        """删除数据命令"""
        if len(args) < 3:
            return "格式: /data delete [类型] [代码] [交易所] [周期(仅bar类型需要)]"

        data_type = args[0]  # bar 或 tick
        symbol = args[1]
        exchange = args[2]

        try:
            # 解析参数
            exchange_obj = Exchange(exchange)

            # 删除数据
            if data_type == "bar":
                if len(args) < 4:
                    return "格式: /data delete bar [代码] [交易所] [周期]"

                interval = args[3]
                interval_obj = Interval(interval)

                success, msg = self.engine.delete_bar_data(
                    symbol=symbol,
                    exchange=exchange_obj,
                    interval=interval_obj
                )
            elif data_type == "tick":
                success, msg = self.engine.delete_tick_data(
                    symbol=symbol,
                    exchange=exchange_obj
                )
            else:
                return f"不支持的数据类型: {data_type}。支持的类型: bar, tick"

            return msg
        except Exception as e:
            return f"删除出错: {str(e)}"

    def cmd_help(self, args: List[str]) -> str:
        """帮助命令"""
        return """
数据管理命令帮助:

/data query - 查询数据
  /data query - 查询所有可用数据
  /data query bar [代码] [交易所] [周期] [开始日期] [结束日期(可选)] - 查询K线数据
  /data query tick [代码] [交易所] [开始日期] [结束日期(可选)] - 查询Tick数据

/data download [代码] [交易所] [周期] [开始日期] [结束日期(可选)] - 下载数据

/data import [文件路径] [代码] [交易所] [周期] [时间列名] [开盘列名] [最高列名] [最低列名] [收盘列名] [成交量列名] [持仓量列名] [时间格式] - 从CSV导入数据

/data export [代码] [交易所] [周期] [开始日期] [结束日期] [文件路径] - 导出数据到CSV

/data delete [类型] [代码] [交易所] [周期(仅bar类型需要)] - 删除数据

/data help - 显示帮助信息

示例:
/data query bar AAPL SMART 1d 2023-01-01 2023-12-31
/data download AAPL SMART 1d 2023-01-01
/data import /path/to/data.csv AAPL SMART 1d datetime open high low close volume open_interest "%Y-%m-%d %H:%M:%S"
/data export AAPL SMART 1d 2023-01-01 2023-12-31 /path/to/export.csv
/data delete bar AAPL SMART 1d
"""

```

### `/simpletrade/simpletrade/apps/st_datamanager/commands/__init__.py`
*(统计信息: 8 行, 99 字符 [~0.01%])*
```python
"""
SimpleTrade数据管理命令模块

提供消息指令处理功能，用于通过消息进行数据管理。
"""

from .processor import DataCommandProcessor

```

### `/simpletrade/simpletrade/apps/st_backtest/service.py`
*(统计信息: 464 行, 16524 字符 [~2.37%])*
```python
"""
SimpleTrade回测服务

提供策略回测服务功能。
"""

import logging
import traceback
from datetime import datetime, date
from typing import List, Optional, Any, Dict, Union, Tuple

import numpy as np
import pandas as pd

from vnpy.trader.constant import Interval
from vnpy_ctastrategy.backtesting import BacktestingMode

from simpletrade.config.database import SessionLocal
from simpletrade.models.database import Strategy, BacktestRecord
from simpletrade.strategies import get_strategy_class
from .engine import BacktestEngineFactory, _get_vnpy_interval, _get_vnpy_exchange

logger = logging.getLogger("simpletrade.apps.st_backtest.service")


class BacktestService:
    """回测服务"""

    def __init__(self, backtest_engine=None):
        """初始化回测服务

        Args:
            backtest_engine: 回测引擎实例，如果不提供则使用工厂创建
        """
        self.backtest_engine = backtest_engine

    def _prepare_date_range(self, start_date, end_date) -> Tuple[datetime, datetime]:
        """处理并标准化日期范围

        Args:
            start_date: 开始日期 (可以是日期对象或字符串)
            end_date: 结束日期 (可以是日期对象或字符串)

        Returns:
            tuple: (开始日期, 结束日期) 的datetime对象元组
        """
        # 转换开始日期
        if hasattr(start_date, 'isoformat'):
            start_date_str = start_date.isoformat()
        else:
            start_date_str = str(start_date)

        # 转换结束日期
        if hasattr(end_date, 'isoformat'):
            end_date_str = end_date.isoformat()
        else:
            end_date_str = str(end_date)

        # 转换为datetime对象
        start = datetime.strptime(start_date_str, "%Y-%m-%d")
        end = datetime.strptime(end_date_str, "%Y-%m-%d")

        return start, end

    def _prepare_parameters(self, default_params, user_params) -> Dict[str, Any]:
        """合并并处理策略参数

        Args:
            default_params: 默认参数字典
            user_params: 用户提供的参数字典

        Returns:
            dict: 处理后的最终参数字典
        """
        final_params = {}

        # 从默认参数中提取参数值
        for key, value in default_params.items():
            if isinstance(value, dict) and "default" in value:
                final_params[key] = value["default"]
            else:
                final_params[key] = value

        # 添加用户提供的参数
        if user_params:
            final_params.update(user_params)

        # 处理字符串类型的数值参数
        for key, value in final_params.items():
            if isinstance(value, str):
                if value.replace('.', '', 1).isdigit():  # 更好的数字检测
                    if '.' in value:
                        final_params[key] = float(value)
                    else:
                        final_params[key] = int(value)

        return final_params

    def _process_daily_results(self, engine) -> pd.DataFrame:
        """处理回测每日结果

        Args:
            engine: 回测引擎实例

        Returns:
            pd.DataFrame: 处理后的每日结果DataFrame
        """
        daily_df = pd.DataFrame()

        try:
            # 首先尝试调用get_daily_results()方法
            daily_df = engine.get_daily_results()

            # 如果不是DataFrame，尝试转换
            if not isinstance(daily_df, pd.DataFrame):
                daily_df = pd.DataFrame(daily_df) if daily_df else pd.DataFrame()

            # 转换数据类型
            if not daily_df.empty:
                for col in daily_df.columns:
                    if col != "date":
                        try:
                            daily_df[col] = pd.to_numeric(daily_df[col], errors='coerce')
                        except Exception as e:
                            logger.warning(f"转换列 {col} 为数字类型时出错: {str(e)}")
                            daily_df[col] = None
        except AttributeError:
            # 尝试从不同属性获取每日结果
            if hasattr(engine, 'daily_df'):
                daily_df = engine.daily_df
                if not isinstance(daily_df, pd.DataFrame):
                    daily_df = pd.DataFrame(daily_df) if daily_df else pd.DataFrame()
            elif hasattr(engine, 'engine') and hasattr(engine.engine, 'daily_df'):
                daily_df = engine.engine.daily_df
                if not isinstance(daily_df, pd.DataFrame):
                    daily_df = pd.DataFrame(daily_df) if daily_df else pd.DataFrame()
            else:
                logger.warning("回测引擎没有get_daily_results()方法或daily_df属性")
        except Exception as e:
            logger.warning(f"获取每日结果时发生错误: {str(e)}")

        return daily_df

    def _process_trades(self, engine) -> List[Dict[str, Any]]:
        """处理回测交易记录

        Args:
            engine: 回测引擎实例

        Returns:
            list: 处理后的交易记录列表
        """
        trades = []

        try:
            # 首先尝试调用get_all_trades方法
            for trade in engine.get_all_trades():
                trade_dict = {
                    "datetime": trade.datetime.strftime("%Y-%m-%d %H:%M:%S"),
                    "symbol": trade.symbol,
                    "exchange": trade.exchange.value,
                    "direction": trade.direction.value,
                    "offset": trade.offset.value,
                    "price": float(trade.price),
                    "volume": float(trade.volume),
                    "vt_tradeid": trade.vt_tradeid,
                }
                trades.append(trade_dict)
        except AttributeError:
            # 尝试从不同属性获取交易记录
            if hasattr(engine, 'trades'):
                trades = self._extract_trades_from_dict(engine.trades)
            elif hasattr(engine, 'engine') and hasattr(engine.engine, 'trades'):
                trades = self._extract_trades_from_dict(engine.engine.trades)
            else:
                logger.warning("回测引擎没有get_all_trades()方法或trades属性")
        except Exception as e:
            logger.warning(f"获取交易记录时发生错误: {str(e)}")

        return trades

    def _extract_trades_from_dict(self, trades_dict) -> List[Dict[str, Any]]:
        """从交易字典中提取交易记录

        Args:
            trades_dict: 交易记录字典

        Returns:
            list: 处理后的交易记录列表
        """
        trades = []
        for _, trade in trades_dict.items():
            trade_dict = {
                "datetime": trade.datetime.strftime("%Y-%m-%d %H:%M:%S") if hasattr(trade, 'datetime') else '',
                "symbol": trade.symbol if hasattr(trade, 'symbol') else '',
                "exchange": trade.exchange.value if hasattr(trade, 'exchange') else '',
                "direction": trade.direction.value if hasattr(trade, 'direction') else '',
                "offset": trade.offset.value if hasattr(trade, 'offset') else '',
                "price": float(trade.price) if hasattr(trade, 'price') else 0.0,
                "volume": float(trade.volume) if hasattr(trade, 'volume') else 0.0,
                "vt_tradeid": trade.vt_tradeid if hasattr(trade, 'vt_tradeid') else '',
            }
            trades.append(trade_dict)
        return trades

    def _convert_to_json_serializable(self, obj: Any) -> Any:
        """转换对象为JSON可序列化格式

        Args:
            obj: 任意类型的对象

        Returns:
            转换后的JSON可序列化对象
        """
        if isinstance(obj, (datetime, date)):
            return obj.isoformat()
        elif isinstance(obj, (np.int32, np.int64)):
            return int(obj)
        elif isinstance(obj, (np.float16, np.float32, np.float64)):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        elif isinstance(obj, Dict):
            return {k: self._convert_to_json_serializable(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._convert_to_json_serializable(item) for item in obj]
        return obj

    def _save_backtest_record(self, user_id, strategy_id, symbol, exchange, interval,
                             start, end, initial_capital, stats, final_params) -> Optional[int]:
        """保存回测记录到数据库

        Args:
            user_id: 用户ID
            strategy_id: 策略ID
            symbol: 交易品种符号
            exchange: 交易所
            interval: 时间间隔
            start: 开始日期
            end: 结束日期
            initial_capital: 初始资金
            stats: 回测统计结果
            final_params: 策略参数

        Returns:
            int: 回测记录ID，如果保存失败则返回None
        """
        try:
            with SessionLocal() as db:
                # 转换统计数据和参数为JSON可序列化格式
                serialized_stats = self._convert_to_json_serializable(stats)
                serialized_params = self._convert_to_json_serializable(final_params)

                # 创建回测记录
                backtest_record = BacktestRecord(
                    user_id=user_id,
                    strategy_id=strategy_id,
                    symbol=symbol,
                    exchange=exchange,
                    interval=interval,
                    start_date=start,
                    end_date=end,
                    initial_capital=float(initial_capital),
                    final_capital=float(stats.get("end_balance", 0.0)),
                    total_return=float(stats.get("total_return", 0.0)),
                    annual_return=float(stats.get("annual_return", 0.0)),
                    max_drawdown=float(stats.get("max_ddpercent", 0.0)),
                    sharpe_ratio=float(stats.get("sharpe_ratio", 0.0)),
                    results={
                        "statistics": serialized_stats,
                        "parameters": serialized_params
                    },
                    created_at=datetime.now()
                )

                # 保存到数据库
                db.add(backtest_record)
                db.commit()
                logger.info(f"回测记录已保存至数据库，记录ID: {backtest_record.id}")
                return backtest_record.id
        except Exception as e:
            logger.error(f"保存回测记录到数据库失败: {str(e)}")
            logger.debug(traceback.format_exc())
            return None

    def run_backtest(self, strategy_id, symbol, exchange, interval, start_date, end_date, initial_capital, rate, slippage, parameters=None, user_id=None):
        """运行回测并返回结果

        Args:
            strategy_id (int): 策略ID
            symbol (str): 交易品种符号
            exchange (str): 交易所
            interval (str): 时间间隔
            start_date (date): 开始日期
            end_date (date): 结束日期
            initial_capital (float): 初始资金
            rate (float): 手续费率
            slippage (float): 滑点大小
            parameters (dict, optional): 策略参数
            user_id (int, optional): 用户ID

        Returns:
            dict: 回测结果
        """
        logger.info(f"开始回测策略 ID {strategy_id}: {start_date} 至 {end_date}")
        if parameters:
            logger.info(f"使用参数: {parameters}")

        try:
            # 获取策略
            with SessionLocal() as db:
                db_strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
                if not db_strategy:
                    raise ValueError(f"数据库中找不到策略 ID {strategy_id}")

            # 获取策略类
            strategy_class = get_strategy_class(db_strategy.identifier)
            if not strategy_class:
                raise ValueError(f"找不到策略类 {db_strategy.type}")

            # 处理日期参数
            start, end = self._prepare_date_range(start_date, end_date)

            # 获取策略类型和默认参数
            strategy_type = db_strategy.strategy_type
            default_params = db_strategy.parameters

            # 使用工厂创建合适的回测引擎
            engine = BacktestEngineFactory.create_engine(strategy_type)

            # 处理策略参数
            final_params = self._prepare_parameters(default_params, parameters)

            # 检查并转换时间间隔和交易所
            interval_obj = _get_vnpy_interval(interval)
            if not interval_obj:
                raise ValueError(f"无效的时间间隔: {interval}")

            exchange_obj = _get_vnpy_exchange(exchange)
            if not exchange_obj:
                raise ValueError(f"无效的交易所: {exchange}")

            # 构建VT符号
            vt_symbol = f"{symbol}.{exchange_obj.value}"

            # 设置回测引擎参数
            engine.set_parameters(
                vt_symbol=vt_symbol,
                interval=interval_obj,
                start=start,
                end=end,
                rate=float(rate),
                slippage=float(slippage),
                size=float(default_params.get("size", 1.0)),
                pricetick=float(default_params.get("pricetick", 0.01)),
                capital=float(initial_capital),
                mode=BacktestingMode.BAR
            )

            # 添加策略
            engine.add_strategy(strategy_class, final_params)

            # 加载历史数据
            engine.load_data()

            # 检查是否加载了数据
            if not engine.history_data:
                logger.warning(f"未加载到数据: {vt_symbol}, {interval}, {start_date} 至 {end_date}")
                return {
                    "success": False,
                    "message": f"未加载到数据: {vt_symbol}, {interval}, {start_date} 至 {end_date}"
                }

            logger.info(f"成功加载 {len(engine.history_data)} 条历史数据")

            # 运行回测
            engine.run_backtesting()

            # 计算回测结果
            engine.calculate_result()

            # 计算统计指标
            stats = engine.calculate_statistics()

            # 获取并处理每日结果
            daily_df = self._process_daily_results(engine)

            # 获取并处理交易记录
            trades = self._process_trades(engine)

            # 构建结果字典
            result = {
                "success": True,
                "statistics": {},
                "daily_results": [],
                "trades": trades
            }

            # 处理统计指标
            for key, value in stats.items():
                try:
                    result["statistics"][key] = self._convert_to_json_serializable(value)
                except Exception as e:
                    logger.warning(f"处理统计指标 {key} 时出错: {str(e)}")
                    result["statistics"][key] = None

            # 处理每日结果
            if isinstance(daily_df, pd.DataFrame) and not daily_df.empty:
                result["daily_results"] = daily_df.to_dict(orient="records")

            # 记录回测结果
            logger.info(f"回测完成，收益率: {stats.get('total_return', 0.0) * 100:.2f}%, 夏普比率: {stats.get('sharpe_ratio', 0.0):.2f}")

            # 如果提供了用户ID，保存回测记录
            if user_id is not None:
                record_id = self._save_backtest_record(
                    user_id, strategy_id, symbol, exchange, interval,
                    start, end, initial_capital, stats, final_params
                )
                if record_id:
                    result["record_id"] = record_id

            return result

        except Exception as e:
            logger.error(f"回测过程中发生错误: {str(e)}")
            logger.debug(traceback.format_exc())
            return {
                "success": False,
                "message": f"回测失败: {str(e)}"
            }

    def get_backtest_records(self, user_id: Optional[int] = None,
                           strategy_id: Optional[int] = None) -> List[BacktestRecord]:
        """获取回测记录列表

        Args:
            user_id (int, optional): 用户ID
            strategy_id (int, optional): 策略ID

        Returns:
            List[BacktestRecord]: 回测记录列表
        """
        with SessionLocal() as db:
            query = db.query(BacktestRecord)

            if user_id is not None:
                query = query.filter(BacktestRecord.user_id == user_id)
            if strategy_id is not None:
                query = query.filter(BacktestRecord.strategy_id == strategy_id)

            return query.order_by(BacktestRecord.created_at.desc()).all()

    def get_backtest_record(self, record_id: int) -> Optional[BacktestRecord]:
        """获取回测记录详情

        Args:
            record_id (int): 回测记录ID

        Returns:
            BacktestRecord: 回测记录，如果不存在则返回None
        """
        with SessionLocal() as db:
            return db.query(BacktestRecord).filter(BacktestRecord.id == record_id).first()
```

### `/simpletrade/simpletrade/apps/st_backtest/engine.py`
*(统计信息: 248 行, 7214 字符 [~1.03%])*
```python
"""
SimpleTrade回测引擎

提供统一的回测引擎接口，支持不同类型的策略回测
"""

import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Type, Optional

import pandas as pd
from vnpy.trader.constant import Interval, Exchange
from vnpy_ctastrategy.backtesting import BacktestingEngine as CTABacktestingEngine
from vnpy_ctastrategy.backtesting import BacktestingMode

from simpletrade.core.app import STBaseEngine

# 尝试导入其他策略类型的回测引擎
try:
    from vnpy_optionmaster.backtesting import BacktestingEngine as OptionBacktestingEngine
    HAS_OPTION_ENGINE = True
except ImportError:
    HAS_OPTION_ENGINE = False
    logging.warning("vnpy_optionmaster not found. Option strategy backtesting won't be available.")

try:
    from vnpy_spreadtrading.backtesting import BacktestingEngine as SpreadBacktestingEngine
    HAS_SPREAD_ENGINE = True
except ImportError:
    HAS_SPREAD_ENGINE = False
    logging.warning("vnpy_spreadtrading not found. Spread strategy backtesting won't be available.")

try:
    from vnpy_algotrading.backtesting import BacktestingEngine as AlgoBacktestingEngine
    HAS_ALGO_ENGINE = True
except ImportError:
    HAS_ALGO_ENGINE = False
    logging.warning("vnpy_algotrading not found. Algo strategy backtesting won't be available.")

logger = logging.getLogger("simpletrade.apps.st_backtest.engine")

# Helper functions
def _get_vnpy_interval(interval_str: str) -> Optional[Interval]:
    """转换字符串间隔为VnPy Interval枚举"""
    interval_map = {
        "1m": Interval.MINUTE,
        "1h": Interval.HOUR,
        "d": Interval.DAILY,
        "w": Interval.WEEKLY,
    }
    return interval_map.get(interval_str)

def _get_vnpy_exchange(exchange_str: str) -> Optional[Exchange]:
    """转换字符串交易所为VnPy Exchange枚举"""
    try:
        return Exchange(exchange_str.upper()) # 尝试直接转换 (例如 "SHFE")
    except ValueError:
        # 如果需要,添加映射
        logger.warning(f"无法直接将 '{exchange_str}' 转换为Exchange枚举. 返回None.")
        return None

class AbstractBacktestEngine(ABC):
    """抽象回测引擎基类"""

    @abstractmethod
    def set_parameters(self, **kwargs) -> None:
        """设置回测参数"""
        pass

    @abstractmethod
    def add_strategy(self, strategy_class: Type, strategy_params: Dict[str, Any]) -> None:
        """添加策略"""
        pass

    @abstractmethod
    def load_data(self) -> None:
        """加载历史数据"""
        pass

    @abstractmethod
    def run_backtesting(self) -> None:
        """运行回测"""
        pass

    @abstractmethod
    def calculate_result(self) -> None:
        """计算回测结果"""
        pass

    @abstractmethod
    def calculate_statistics(self) -> Dict[str, Any]:
        """计算回测统计指标"""
        pass

    @abstractmethod
    def get_daily_results(self) -> pd.DataFrame:
        """获取每日结果"""
        pass

    @abstractmethod
    def get_all_trades(self) -> List[Any]:
        """获取所有交易记录"""
        pass

    @property
    @abstractmethod
    def history_data(self) -> List[Any]:
        """获取历史数据"""
        pass


class CTABacktestEngine(AbstractBacktestEngine):
    """CTA策略回测引擎"""

    def __init__(self):
        """初始化"""
        self.engine = CTABacktestingEngine()

    def set_parameters(self, **kwargs) -> None:
        """设置回测参数"""
        self.engine.set_parameters(**kwargs)

    def add_strategy(self, strategy_class: Type, strategy_params: Dict[str, Any]) -> None:
        """添加策略"""
        self.engine.add_strategy(strategy_class, strategy_params)

    def load_data(self) -> None:
        """加载历史数据"""
        self.engine.load_data()

    def run_backtesting(self) -> None:
        """运行回测"""
        self.engine.run_backtesting()

    def calculate_result(self) -> None:
        """计算回测结果"""
        self.engine.calculate_result()

    def calculate_statistics(self) -> Dict[str, Any]:
        """计算回测统计指标"""
        return self.engine.calculate_statistics()

    def get_daily_results(self) -> pd.DataFrame:
        """获取每日结果"""
        return pd.DataFrame(self.engine.get_daily_results()).fillna(0.0)

    def get_all_trades(self) -> List[Any]:
        """获取所有交易记录"""
        return self.engine.get_all_trades()

    @property
    def history_data(self) -> List[Any]:
        """获取历史数据"""
        return self.engine.history_data


# 如果支持期权策略，添加期权回测引擎
if HAS_OPTION_ENGINE:
    class OptionBacktestEngine(AbstractBacktestEngine):
        """期权策略回测引擎"""

        def __init__(self):
            """初始化"""
            self.engine = OptionBacktestingEngine()

        def set_parameters(self, **kwargs) -> None:
            """设置回测参数"""
            self.engine.set_parameters(**kwargs)

        def add_strategy(self, strategy_class: Type, strategy_params: Dict[str, Any]) -> None:
            """添加策略"""
            self.engine.add_strategy(strategy_class, strategy_params)

        def load_data(self) -> None:
            """加载历史数据"""
            self.engine.load_data()

        def run_backtesting(self) -> None:
            """运行回测"""
            self.engine.run_backtesting()

        def calculate_result(self) -> None:
            """计算回测结果"""
            self.engine.calculate_result()

        def calculate_statistics(self) -> Dict[str, Any]:
            """计算回测统计指标"""
            return self.engine.calculate_statistics()

        def get_daily_results(self) -> pd.DataFrame:
            """获取每日结果"""
            return pd.DataFrame(self.engine.get_daily_results()).fillna(0.0)

        def get_all_trades(self) -> List[Any]:
            """获取所有交易记录"""
            return self.engine.get_all_trades()

        @property
        def history_data(self) -> List[Any]:
            """获取历史数据"""
            return self.engine.history_data


class BacktestEngineFactory:
    """回测引擎工厂，根据策略类型创建合适的回测引擎"""

    @staticmethod
    def create_engine(strategy_type: str) -> AbstractBacktestEngine:
        """
        创建回测引擎

        Args:
            strategy_type (str): 策略类型，如 'cta', 'option', 'spread', 'algo'

        Returns:
            AbstractBacktestEngine: 回测引擎实例

        Raises:
            ValueError: 如果策略类型不支持
        """
        if strategy_type is None:
            logger.warning("策略类型为None，使用默认的CTA回测引擎")
            return CTABacktestEngine()

        strategy_type = strategy_type.lower()

        if strategy_type in ['cta', 'cat']:  # 添加对'cat'类型的支持
            return CTABacktestEngine()
        elif strategy_type == 'option' and HAS_OPTION_ENGINE:
            return OptionBacktestEngine()
        # 添加其他策略类型...
        else:
            # 默认使用CTA回测引擎
            logger.warning(f"策略类型 '{strategy_type}' 不支持或未找到对应回测引擎, 使用默认的CTA回测引擎")
            return CTABacktestEngine()


class STBacktestEngine(STBaseEngine):
    """SimpleTrade回测引擎"""

    def __init__(self, main_engine=None, event_engine=None, app_name=None):
        """初始化回测引擎"""
        super().__init__(main_engine, event_engine, app_name)
        self.factory = BacktestEngineFactory()

    def create_backtest_engine(self, strategy_type: str) -> AbstractBacktestEngine:
        """创建回测引擎实例"""
        return self.factory.create_engine(strategy_type)
```

### `/simpletrade/simpletrade/apps/st_backtest/__init__.py`
*(统计信息: 24 行, 486 字符 [~0.07%])*
```python
"""
SimpleTrade回测应用

提供策略回测功能。
"""

from pathlib import Path

from simpletrade.core.app import STBaseApp
from .engine import STBacktestEngine
from .service import BacktestService
from .ui import STBacktestWidget

APP_NAME = "st_backtest"

class STBacktestApp(STBaseApp):
    """SimpleTrade回测应用"""

    app_name = APP_NAME
    app_module = __module__
    app_path = Path(__file__).parent
    display_name = "ST回测"
    engine_class = STBacktestEngine
    widget_class = None  # 当前不需要图形界面
```

### `/simpletrade/simpletrade/apps/st_backtest/ui/__init__.py`
*(统计信息: 13 行, 202 字符 [~0.03%])*
```python
"""
SimpleTrade回测应用UI模块

提供回测图形界面组件。
"""

# 未来可以添加回测UI组件
class STBacktestWidget:
    """回测应用界面组件（占位类）"""

    def __init__(self, main_engine=None, event_engine=None):
        """初始化"""
        pass
```

### `/simpletrade/simpletrade/apps/st_analysis/engine.py`
*(统计信息: 228 行, 7641 字符 [~1.09%])*
```python
"""
SimpleTrade分析引擎

提供数据分析功能，包括技术指标计算、策略回测和可视化分析。
"""

from typing import List, Dict, Any, Optional
from datetime import datetime
import pandas as pd
import numpy as np

from vnpy.trader.object import BarData
from vnpy.trader.constant import Interval, Exchange

from simpletrade.core.app import STBaseEngine

class STAnalysisEngine(STBaseEngine):
    """SimpleTrade分析引擎"""

    def __init__(self, main_engine, event_engine, engine_name: str):
        """初始化"""
        super().__init__(main_engine, event_engine, engine_name)

        # 初始化API路由和消息指令
        self.init_api_routes()
        self.init_message_commands()

    def init_api_routes(self):
        """初始化API路由"""
        try:
            from .api import router
            self.write_log("API路由初始化成功")

            # 将路由器保存到引擎实例中，便于外部访问
            self.router = router

            # 将引擎实例注册到全局变量中，便于API访问
            import sys
            sys.modules["simpletrade.apps.st_analysis.api.engine"] = self
        except Exception as e:
            self.write_log(f"API路由初始化失败：{str(e)}")

    def init_message_commands(self):
        """初始化消息指令"""
        try:
            from .commands import AnalysisCommandProcessor
            self.command_processor = AnalysisCommandProcessor(self)
            self.write_log("消息指令处理器初始化成功")

            # 将指令处理器注册到消息引擎（如果存在）
            message_engine = self.main_engine.get_engine("st_message")
            if message_engine:
                message_engine.register_processor("/analysis", self.command_processor)
                self.write_log("消息指令处理器注册成功")
            else:
                self.write_log("警告：st_message引擎未找到，消息指令将无法使用")
        except Exception as e:
            self.write_log(f"消息指令处理器初始化失败：{str(e)}")

    def write_log(self, msg: str):
        """写入日志"""
        self.main_engine.write_log(msg, source=self.engine_name)

    # ---- 从core/analysis移动过来的功能 ----

    def calculate_indicators(self, bars: List[BarData], indicators: List[str]) -> pd.DataFrame:
        """计算技术指标"""
        # 将K线数据转换为DataFrame
        df = self.bars_to_dataframe(bars)

        # 计算指标
        for indicator in indicators:
            if indicator == "ma":
                df = self.calculate_ma(df)
            elif indicator == "macd":
                df = self.calculate_macd(df)
            elif indicator == "rsi":
                df = self.calculate_rsi(df)
            # 可以添加更多指标...

        return df

    def bars_to_dataframe(self, bars: List[BarData]) -> pd.DataFrame:
        """将K线数据转换为DataFrame"""
        data = []
        for bar in bars:
            data.append({
                "datetime": bar.datetime,
                "open": bar.open_price,
                "high": bar.high_price,
                "low": bar.low_price,
                "close": bar.close_price,
                "volume": bar.volume,
                "open_interest": bar.open_interest
            })

        df = pd.DataFrame(data)
        df.set_index("datetime", inplace=True)
        return df

    def calculate_ma(self, df: pd.DataFrame, periods: List[int] = [5, 10, 20, 60]) -> pd.DataFrame:
        """计算移动平均线"""
        for period in periods:
            df[f"ma{period}"] = df["close"].rolling(period).mean()
        return df

    def calculate_macd(self, df: pd.DataFrame, fast: int = 12, slow: int = 26, signal: int = 9) -> pd.DataFrame:
        """计算MACD指标"""
        # 计算EMA
        ema_fast = df["close"].ewm(span=fast, adjust=False).mean()
        ema_slow = df["close"].ewm(span=slow, adjust=False).mean()

        # 计算MACD线和信号线
        df["macd"] = ema_fast - ema_slow
        df["macd_signal"] = df["macd"].ewm(span=signal, adjust=False).mean()
        df["macd_hist"] = df["macd"] - df["macd_signal"]

        return df

    def calculate_rsi(self, df: pd.DataFrame, period: int = 14) -> pd.DataFrame:
        """计算RSI指标"""
        # 计算价格变化
        delta = df["close"].diff()

        # 分离上涨和下跌
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)

        # 计算平均上涨和下跌
        avg_gain = gain.rolling(window=period).mean()
        avg_loss = loss.rolling(window=period).mean()

        # 计算相对强度和RSI
        rs = avg_gain / avg_loss
        df["rsi"] = 100 - (100 / (1 + rs))

        return df

    def backtest_strategy(self, bars: List[BarData], strategy_params: Dict[str, Any]) -> Dict[str, Any]:
        """回测策略"""
        # 将K线数据转换为DataFrame
        df = self.bars_to_dataframe(bars)

        # 根据策略参数计算指标
        if "ma" in strategy_params:
            df = self.calculate_ma(df, strategy_params["ma"])
        if "macd" in strategy_params:
            df = self.calculate_macd(df, **strategy_params["macd"])
        if "rsi" in strategy_params:
            df = self.calculate_rsi(df, strategy_params["rsi"])

        # 生成交易信号
        df = self.generate_signals(df, strategy_params)

        # 计算回测结果
        results = self.calculate_returns(df)

        return results

    def generate_signals(self, df: pd.DataFrame, strategy_params: Dict[str, Any]) -> pd.DataFrame:
        """生成交易信号"""
        # 这里是一个简单的示例，实际应用中需要根据具体策略生成信号
        df["signal"] = 0

        if "ma_cross" in strategy_params:
            fast = strategy_params["ma_cross"]["fast"]
            slow = strategy_params["ma_cross"]["slow"]

            # 计算快线和慢线
            if f"ma{fast}" not in df.columns:
                df = self.calculate_ma(df, [fast])
            if f"ma{slow}" not in df.columns:
                df = self.calculate_ma(df, [slow])

            # 生成信号：快线上穿慢线买入，下穿卖出
            df["signal"] = np.where(df[f"ma{fast}"] > df[f"ma{slow}"], 1, 0)
            df["signal"] = np.where(df[f"ma{fast}"] < df[f"ma{slow}"], -1, df["signal"])

        return df

    def calculate_returns(self, df: pd.DataFrame) -> Dict[str, Any]:
        """计算回测结果"""
        # 计算每日收益率
        df["returns"] = df["close"].pct_change()

        # 计算策略收益率
        df["strategy_returns"] = df["signal"].shift(1) * df["returns"]

        # 计算累计收益率
        df["cumulative_returns"] = (1 + df["returns"]).cumprod() - 1
        df["strategy_cumulative_returns"] = (1 + df["strategy_returns"]).cumprod() - 1

        # 计算最大回撤
        df["peak"] = df["strategy_cumulative_returns"].cummax()
        df["drawdown"] = (df["strategy_cumulative_returns"] - df["peak"]) / (1 + df["peak"])
        max_drawdown = df["drawdown"].min()

        # 计算年化收益率
        days = (df.index[-1] - df.index[0]).days
        annual_return = (1 + df["strategy_cumulative_returns"].iloc[-1]) ** (365 / days) - 1

        # 计算夏普比率
        sharpe_ratio = df["strategy_returns"].mean() / df["strategy_returns"].std() * (252 ** 0.5)

        # 返回结果
        results = {
            "annual_return": annual_return,
            "max_drawdown": max_drawdown,
            "sharpe_ratio": sharpe_ratio,
            "total_return": df["strategy_cumulative_returns"].iloc[-1],
            "win_rate": len(df[df["strategy_returns"] > 0]) / len(df[df["strategy_returns"] != 0]),
            "data": df
        }

        return results

    def visualize_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """可视化回测结果"""
        # 在实际应用中，这里可以生成图表或报告
        # 这里只返回一些关键指标
        return {
            "annual_return": results["annual_return"],
            "max_drawdown": results["max_drawdown"],
            "sharpe_ratio": results["sharpe_ratio"],
            "total_return": results["total_return"],
            "win_rate": results["win_rate"]
        }

```

### `/simpletrade/simpletrade/apps/st_analysis/__init__.py`
*(统计信息: 23 行, 434 字符 [~0.06%])*
```python
"""
SimpleTrade分析应用

提供数据分析功能，包括技术指标计算、策略回测和可视化分析。
"""

from pathlib import Path

from simpletrade.core.app import STBaseApp
from .engine import STAnalysisEngine

APP_NAME = "st_analysis"

class STAnalysisApp(STBaseApp):
    """SimpleTrade分析应用"""

    app_name = APP_NAME
    app_module = __module__
    app_path = Path(__file__).parent
    display_name = "ST分析"
    engine_class = STAnalysisEngine
    widget_class = None  # 不需要图形界面

```

### `/simpletrade/simpletrade/apps/st_analysis/commands/processor.py`
*(统计信息: 188 行, 5987 字符 [~0.86%])*
```python
"""
SimpleTrade分析应用命令处理器
"""

from typing import List, Dict, Any
from datetime import datetime

from vnpy.trader.constant import Exchange, Interval

class AnalysisCommandProcessor:
    """分析命令处理器"""

    def __init__(self, engine):
        """初始化"""
        self.engine = engine
        self.commands = {
            "indicator": self.cmd_indicator,
            "backtest": self.cmd_backtest,
            "help": self.cmd_help,
        }

    def process(self, command_text: str) -> str:
        """处理命令"""
        # 检查命令前缀
        if not command_text.startswith("/analysis"):
            return ""

        # 解析命令
        parts = command_text.split()
        if len(parts) < 2:
            return "无效的命令格式。使用 `/analysis help` 获取帮助。"

        cmd = parts[1].lower()
        args = parts[2:]

        # 执行命令
        if cmd in self.commands:
            try:
                return self.commands[cmd](args)
            except Exception as e:
                return f"命令执行错误: {str(e)}"
        else:
            return f"未知命令: {cmd}。使用 `/analysis help` 获取帮助。"

    def cmd_indicator(self, args: List[str]) -> str:
        """计算技术指标命令"""
        if len(args) < 5:
            return "格式: /analysis indicator [代码] [交易所] [周期] [开始日期] [结束日期] [指标1] [指标2] ..."

        symbol = args[0]
        exchange = args[1]
        interval = args[2]
        start_date = args[3]
        end_date = args[4]
        indicators = args[5:]

        if not indicators:
            indicators = ["ma", "macd", "rsi"]  # 默认指标

        try:
            # 解析参数
            exchange_obj = Exchange(exchange)
            interval_obj = Interval(interval)
            start = datetime.strptime(start_date, "%Y-%m-%d")
            end = datetime.strptime(end_date, "%Y-%m-%d")

            # 获取数据
            data_engine = self.engine.main_engine.get_engine("st_datamanager")
            if not data_engine:
                return "错误：无法获取数据管理引擎"

            bars = data_engine.get_bar_data(
                symbol=symbol,
                exchange=exchange_obj,
                interval=interval_obj,
                start=start,
                end=end
            )

            if not bars:
                return "未找到符合条件的数据"

            # 计算指标
            df = self.engine.calculate_indicators(bars, indicators)

            # 格式化输出
            result = f"计算 {symbol}.{exchange} 的技术指标:\n"
            for indicator in indicators:
                if indicator == "ma":
                    result += "- 移动平均线 (MA5, MA10, MA20, MA60)\n"
                elif indicator == "macd":
                    result += "- MACD (12, 26, 9)\n"
                elif indicator == "rsi":
                    result += "- RSI (14)\n"

            result += f"\n最近数据 ({df.index[-1].strftime('%Y-%m-%d')}):\n"

            # 显示最近的指标值
            last_row = df.iloc[-1]
            if "ma5" in df.columns:
                result += f"MA5: {last_row['ma5']:.2f}, MA10: {last_row['ma10']:.2f}, MA20: {last_row['ma20']:.2f}\n"
            if "macd" in df.columns:
                result += f"MACD: {last_row['macd']:.4f}, Signal: {last_row['macd_signal']:.4f}, Hist: {last_row['macd_hist']:.4f}\n"
            if "rsi" in df.columns:
                result += f"RSI: {last_row['rsi']:.2f}\n"

            return result
        except Exception as e:
            return f"计算指标出错: {str(e)}"

    def cmd_backtest(self, args: List[str]) -> str:
        """回测策略命令"""
        if len(args) < 5:
            return "格式: /analysis backtest [代码] [交易所] [周期] [开始日期] [结束日期] [策略参数]"

        symbol = args[0]
        exchange = args[1]
        interval = args[2]
        start_date = args[3]
        end_date = args[4]

        # 解析策略参数（简化版，实际应用中可能需要更复杂的解析）
        strategy_params = {
            "ma_cross": {
                "fast": 5,
                "slow": 20
            }
        }

        try:
            # 解析参数
            exchange_obj = Exchange(exchange)
            interval_obj = Interval(interval)
            start = datetime.strptime(start_date, "%Y-%m-%d")
            end = datetime.strptime(end_date, "%Y-%m-%d")

            # 获取数据
            data_engine = self.engine.main_engine.get_engine("st_datamanager")
            if not data_engine:
                return "错误：无法获取数据管理引擎"

            bars = data_engine.get_bar_data(
                symbol=symbol,
                exchange=exchange_obj,
                interval=interval_obj,
                start=start,
                end=end
            )

            if not bars:
                return "未找到符合条件的数据"

            # 回测策略
            results = self.engine.backtest_strategy(bars, strategy_params)

            # 格式化输出
            result = f"回测 {symbol}.{exchange} 的策略结果:\n"
            result += f"策略: MA交叉 (快线: {strategy_params['ma_cross']['fast']}, 慢线: {strategy_params['ma_cross']['slow']})\n"
            result += f"时间段: {start_date} 至 {end_date}\n\n"

            result += f"年化收益率: {results['annual_return']:.2%}\n"
            result += f"最大回撤: {results['max_drawdown']:.2%}\n"
            result += f"夏普比率: {results['sharpe_ratio']:.2f}\n"
            result += f"总收益率: {results['total_return']:.2%}\n"
            result += f"胜率: {results['win_rate']:.2%}\n"

            return result
        except Exception as e:
            return f"回测出错: {str(e)}"

    def cmd_help(self, args: List[str]) -> str:
        """帮助命令"""
        return """
分析命令帮助:

/analysis indicator [代码] [交易所] [周期] [开始日期] [结束日期] [指标1] [指标2] ... - 计算技术指标
  支持的指标: ma, macd, rsi

/analysis backtest [代码] [交易所] [周期] [开始日期] [结束日期] [策略参数] - 回测策略
  目前支持的策略: MA交叉

/analysis help - 显示帮助信息

示例:
/analysis indicator AAPL SMART 1d 2023-01-01 2023-12-31 ma macd
/analysis backtest AAPL SMART 1d 2023-01-01 2023-12-31
"""

```

### `/simpletrade/simpletrade/apps/st_analysis/commands/__init__.py`
*(统计信息: 8 行, 118 字符 [~0.02%])*
```python
"""
SimpleTrade分析应用命令处理器
"""

from .processor import AnalysisCommandProcessor

__all__ = ["AnalysisCommandProcessor"]

```

### `/simpletrade/simpletrade/apps/st_analysis/api/routes.py`
*(统计信息: 141 行, 3994 字符 [~0.57%])*
```python
"""
SimpleTrade分析应用API路由
"""

import logging
from typing import List, Dict, Any, Optional
from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel

from vnpy.trader.constant import Exchange, Interval

# 创建路由器
router = APIRouter(
    prefix="/api/analysis",
    tags=["analysis"],
    responses={404: {"description": "Not found"}},
)

# 依赖注入：获取分析引擎
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

def get_analysis_engine():
    """获取分析引擎"""
    # 这里需要从全局获取引擎实例
    from simpletrade.main import main_engine
    from simpletrade.apps.st_analysis import STAnalysisApp
    engine_instance = main_engine.get_engine(STAnalysisApp.app_name)
    logger.info(f"get_analysis_engine called. Requested engine name: {STAnalysisApp.app_name}, got instance: {engine_instance}")
    return engine_instance

# 模型定义
class IndicatorRequest(BaseModel):
    symbol: str
    exchange: str
    interval: str
    start_date: str
    end_date: str
    indicators: List[str] = ["ma", "macd", "rsi"]

class BacktestRequest(BaseModel):
    symbol: str
    exchange: str
    interval: str
    start_date: str
    end_date: str
    strategy_params: Dict[str, Any]

# 路由定义
@router.post("/indicators")
async def calculate_indicators(
    request: IndicatorRequest,
    engine = Depends(get_analysis_engine)
):
    """计算技术指标"""
    try:
        # 解析参数
        exchange_obj = Exchange(request.exchange)
        interval_obj = Interval(request.interval)
        start = datetime.strptime(request.start_date, "%Y-%m-%d")
        end = datetime.strptime(request.end_date, "%Y-%m-%d")

        # 获取数据
        data_engine = engine.main_engine.get_engine("st_datamanager")
        if not data_engine:
            raise HTTPException(status_code=500, detail="无法获取数据管理引擎")

        bars = data_engine.get_bar_data(
            symbol=request.symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start=start,
            end=end
        )

        if not bars:
            raise HTTPException(status_code=404, detail="未找到符合条件的数据")

        # 计算指标
        df = engine.calculate_indicators(bars, request.indicators)

        # 转换为JSON格式
        df.index = df.index.astype(str)  # 将datetime索引转换为字符串
        result = df.to_dict(orient="index")

        return {
            "success": True,
            "data": result
        }
    except Exception as e:
        logger.exception("计算指标出错")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/backtest")
async def backtest_strategy(
    request: BacktestRequest,
    engine = Depends(get_analysis_engine)
):
    """回测策略"""
    try:
        # 解析参数
        exchange_obj = Exchange(request.exchange)
        interval_obj = Interval(request.interval)
        start = datetime.strptime(request.start_date, "%Y-%m-%d")
        end = datetime.strptime(request.end_date, "%Y-%m-%d")

        # 获取数据
        data_engine = engine.main_engine.get_engine("st_datamanager")
        if not data_engine:
            raise HTTPException(status_code=500, detail="无法获取数据管理引擎")

        bars = data_engine.get_bar_data(
            symbol=request.symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start=start,
            end=end
        )

        if not bars:
            raise HTTPException(status_code=404, detail="未找到符合条件的数据")

        # 回测策略
        results = engine.backtest_strategy(bars, request.strategy_params)

        # 处理DataFrame
        if "data" in results:
            df = results["data"]
            df.index = df.index.astype(str)  # 将datetime索引转换为字符串
            results["data"] = df.to_dict(orient="index")

        return {
            "success": True,
            "data": results
        }
    except Exception as e:
        logger.exception("回测出错")
        raise HTTPException(status_code=500, detail=str(e))

```

### `/simpletrade/simpletrade/apps/st_analysis/api/__init__.py`
*(统计信息: 8 行, 77 字符 [~0.01%])*
```python
"""
SimpleTrade分析应用API
"""

from .routes import router

__all__ = ["router"]

```

### `/simpletrade/simpletrade/apps/st_message/base.py`
*(统计信息: 70 行, 1466 字符 [~0.21%])*
```python
"""
SimpleTrade消息处理基础接口

定义消息处理的基础接口，包括命令处理器和消息处理器的基类。
"""

from typing import Dict, Any, Optional, List, Callable


class CommandProcessor:
    """命令处理器基类"""

    def __init__(self, prefix: str):
        """初始化

        参数:
            prefix: 命令前缀
        """
        self.prefix = prefix

    def process(self, command: str) -> str:
        """处理命令

        参数:
            command: 命令文本

        返回:
            str: 处理结果
        """
        raise NotImplementedError("子类必须实现process方法")


class MessageProcessor:
    """消息处理器"""

    def __init__(self):
        """初始化"""
        self.processors: Dict[str, CommandProcessor] = {}

    def register_processor(self, processor: CommandProcessor):
        """注册命令处理器

        参数:
            processor: 命令处理器
        """
        self.processors[processor.prefix] = processor

    def process(self, message: str) -> str:
        """处理消息

        参数:
            message: 消息文本

        返回:
            str: 处理结果
        """
        # 检查是否是命令
        if not message.startswith("/"):
            return ""

        # 查找匹配的处理器
        for prefix, processor in self.processors.items():
            if message.startswith(prefix):
                try:
                    return processor.process(message)
                except Exception as e:
                    return f"命令处理错误: {str(e)}"

        return "未知命令。使用 `/help` 获取帮助。"

```

### `/simpletrade/simpletrade/apps/st_message/engine.py`
*(统计信息: 61 行, 1688 字符 [~0.24%])*
```python
"""
SimpleTrade消息系统引擎

处理消息指令，并将其分发到相应的处理器。
"""

from typing import Dict, Any, Optional, List, Callable

from simpletrade.core.app import STBaseEngine

class STMessageEngine(STBaseEngine):
    """SimpleTrade消息系统引擎"""

    def __init__(self, main_engine, event_engine, engine_name: str):
        """初始化"""
        super().__init__(main_engine, event_engine, engine_name)

        # 命令处理器字典
        self.processors = {}

        self.write_log("消息系统引擎初始化成功")

    def write_log(self, msg: str):
        """写入日志"""
        self.main_engine.write_log(msg, source=self.engine_name)

    def register_processor(self, prefix: str, processor):
        """注册命令处理器"""
        self.processors[prefix] = processor
        self.write_log(f"注册命令处理器: {prefix}")

    def process_message(self, message_text: str) -> str:
        """处理消息"""
        # 检查是否是命令
        if not message_text.startswith("/"):
            return None

        # 查找匹配的处理器
        for prefix, processor in self.processors.items():
            if message_text.startswith(prefix):
                try:
                    return processor.process(message_text)
                except Exception as e:
                    return f"命令处理错误: {str(e)}"

        return "未知命令。使用 `/help` 获取帮助。"

    def send_message(self, message: str, target: Optional[str] = None) -> bool:
        """发送消息

        参数:
            message (str): 消息内容
            target (str, optional): 目标用户或群组ID

        返回:
            bool: 是否发送成功
        """
        # 这里只是一个占位实现，实际应用中需要连接到真实的消息系统
        self.write_log(f"发送消息: {message}" + (f" 到 {target}" if target else ""))
        return True

```

### `/simpletrade/simpletrade/apps/st_message/test.py`
*(统计信息: 36 行, 644 字符 [~0.09%])*
```python
"""
SimpleTrade消息系统测试

提供测试消息指令的功能。
"""

def test_message(engine, message_text: str) -> str:
    """测试消息指令

    参数:
        engine: 消息引擎实例
        message_text: 消息文本

    返回:
        str: 处理结果
    """
    return engine.process_message(message_text)

def run_interactive_test(engine):
    """运行交互式测试

    参数:
        engine: 消息引擎实例
    """
    print("SimpleTrade消息系统测试")
    print("输入消息指令进行测试，输入'exit'退出")
    print("示例: /data query")

    while True:
        message = input("> ")
        if message.lower() == "exit":
            break

        result = test_message(engine, message)
        print(result or "无响应")

```

### `/simpletrade/simpletrade/apps/st_message/__init__.py`
*(统计信息: 28 行, 591 字符 [~0.08%])*
```python
"""
SimpleTrade消息系统应用

提供消息处理功能，支持通过消息指令控制系统。
同时提供消息处理的基础接口，包括命令处理器和消息处理器的基类。
"""

from pathlib import Path

from simpletrade.core.app import STBaseApp
from .engine import STMessageEngine
from .base import CommandProcessor, MessageProcessor

APP_NAME = "st_message"

class STMessageApp(STBaseApp):
    """SimpleTrade消息系统应用"""

    app_name = APP_NAME
    app_module = __module__
    app_path = Path(__file__).parent
    display_name = "ST消息系统"
    engine_class = STMessageEngine
    widget_class = None  # 不需要图形界面

# 导出基础接口
__all__ = ["STMessageApp", "CommandProcessor", "MessageProcessor"]

```

### `/simpletrade/simpletrade/apps/st_trader/engine.py`
*(统计信息: 102 行, 2564 字符 [~0.37%])*
```python
"""
SimpleTrade交易增强引擎

实现交易功能的增强，包括订单管理、持仓管理等。
"""

from simpletrade.core.app import STBaseEngine
from vnpy.trader.object import OrderRequest, CancelRequest
from vnpy.trader.constant import Direction, Offset, OrderType
from vnpy.event import Event

class STTraderEngine(STBaseEngine):
    """
    SimpleTrade交易增强引擎

    提供交易功能的增强，包括订单管理、持仓管理等。
    """

    def __init__(self, main_engine, event_engine, engine_name: str):
        """
        初始化

        参数:
            main_engine (MainEngine): 主引擎
            event_engine (EventEngine): 事件引擎
            engine_name (str): 引擎名称
        """
        super().__init__(main_engine, event_engine, engine_name)

        # 注册事件处理函数
        self.register_event()

    def register_event(self):
        """注册事件处理函数"""
        self.event_engine.register("eOrder", self.process_order_event)
        self.event_engine.register("eTrade", self.process_trade_event)

    def process_order_event(self, event):
        """
        处理订单事件

        参数:
            event (Event): 订单事件
        """
        order = event.data
        # 处理订单逻辑
        print(f"收到订单事件: {order.orderid}, 状态: {order.status}")

    def process_trade_event(self, event):
        """
        处理成交事件

        参数:
            event (Event): 成交事件
        """
        trade = event.data
        # 处理成交逻辑
        print(f"收到成交事件: {trade.tradeid}, 价格: {trade.price}, 数量: {trade.volume}")

    def send_order(self, symbol, exchange, direction, offset, price, volume, gateway_name):
        """
        发送订单

        参数:
            symbol (str): 合约代码
            exchange (Exchange): 交易所
            direction (Direction): 方向
            offset (Offset): 开平
            price (float): 价格
            volume (float): 数量
            gateway_name (str): 接口名称

        返回:
            str: 订单ID
        """
        req = OrderRequest(
            symbol=symbol,
            exchange=exchange,
            direction=direction,
            offset=offset,
            type=OrderType.LIMIT,
            price=price,
            volume=volume
        )
        return self.main_engine.send_order(req, gateway_name)

    def cancel_order(self, order_id, gateway_name):
        """
        撤销订单

        参数:
            order_id (str): 订单ID
            gateway_name (str): 接口名称

        返回:
            bool: 是否成功
        """
        req = CancelRequest(
            orderid=order_id
        )
        return self.main_engine.cancel_order(req, gateway_name)

```

### `/simpletrade/simpletrade/apps/st_trader/widget.py`
*(统计信息: 44 行, 896 字符 [~0.13%])*
```python
"""
SimpleTrade交易增强界面

提供交易功能的图形界面。
"""

from vnpy.trader.ui import QtWidgets

class STTraderWidget(QtWidgets.QWidget):
    """
    SimpleTrade交易增强界面

    提供交易功能的图形界面。
    """

    def __init__(self, main_engine, event_engine):
        """
        初始化

        参数:
            main_engine (MainEngine): 主引擎
            event_engine (EventEngine): 事件引擎
        """
        super().__init__()

        self.main_engine = main_engine
        self.event_engine = event_engine
        self.engine = main_engine.get_engine("st_trader")

        self.init_ui()

    def init_ui(self):
        """初始化界面"""
        self.setWindowTitle("ST交易增强")
        self.resize(1000, 600)

        # 创建界面组件
        label = QtWidgets.QLabel("ST交易增强界面")

        # 设置布局
        vbox = QtWidgets.QVBoxLayout()
        vbox.addWidget(label)
        self.setLayout(vbox)

```

### `/simpletrade/simpletrade/apps/st_trader/__init__.py`
*(统计信息: 24 行, 460 字符 [~0.07%])*
```python
"""
SimpleTrade交易增强应用

提供交易功能的增强，包括订单管理、持仓管理等。
"""

from pathlib import Path

from simpletrade.core.app import STBaseApp
from .engine import STTraderEngine
from .widget import STTraderWidget

APP_NAME = "st_trader"

class STTraderApp(STBaseApp):
    """SimpleTrade交易增强应用"""

    app_name = APP_NAME
    app_module = __module__
    app_path = Path(__file__).parent
    display_name = "ST交易增强"
    engine_class = STTraderEngine
    widget_class = STTraderWidget

```

### `/simpletrade/simpletrade/api/main.py`
*(统计信息: 126 行, 3346 字符 [~0.48%])*
```python
"""
SimpleTrade API 主程序入口
"""

import logging
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import time

from simpletrade.core.logging import configure_logging, get_logger
from simpletrade.core.exceptions import SimpleTradeError, handle_exception
from simpletrade.api.schemas.common import ErrorResponse
from simpletrade.api.routers import data

# 配置日志
configure_logging()
logger = get_logger(__name__)

# 创建FastAPI应用
app = FastAPI(
    title="SimpleTrade API",
    description="SimpleTrade交易系统API",
    version="0.1.0"
)

# 配置CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 允许所有来源，生产环境应限制
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(data.router)

# 添加请求计时中间件
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    """添加处理时间头部的中间件"""
    start_time = time.time()
    try:
        response = await call_next(request)
        process_time = time.time() - start_time
        response.headers["X-Process-Time"] = str(process_time)
        return response
    except Exception as exc:
        # 异常记录和包装
        logger.error(f"处理请求时出错: {exc}", exc_info=True)
        process_time = time.time() - start_time

        # 将异常转换为SimpleTradeError
        st_error = handle_exception(exc, log_exception=True, reraise=False)

        # 返回JSON错误响应
        return JSONResponse(
            status_code=500,
            content=ErrorResponse(
                success=False,
                message=st_error.message,
                code=st_error.code,
                details=st_error.details
            ).dict(),
            headers={"X-Process-Time": str(process_time)}
        )

# 全局异常处理
@app.exception_handler(SimpleTradeError)
async def simpletrade_exception_handler(request: Request, exc: SimpleTradeError):
    """处理SimpleTradeError异常"""
    return JSONResponse(
        status_code=500,
        content=ErrorResponse(
            success=False,
            message=exc.message,
            code=exc.code,
            details=exc.details
        ).dict()
    )

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """处理FastAPI的HTTPException"""
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            success=False,
            message=exc.detail,
            code=f"HTTP{exc.status_code}",
            details={"headers": dict(exc.headers or {})}
        ).dict()
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """处理所有其他异常"""
    # 转换为SimpleTradeError
    st_error = handle_exception(exc, log_exception=True, reraise=False)

    return JSONResponse(
        status_code=500,
        content=ErrorResponse(
            success=False,
            message=st_error.message,
            code=st_error.code,
            details=st_error.details
        ).dict()
    )

# 根路由
@app.get("/")
async def root():
    """API根路径"""
    return {
        "name": "SimpleTrade API",
        "version": "0.1.0",
        "status": "running"
    }

# 健康检查
@app.get("/health")
async def health_check():
    """API健康检查"""
    return {"status": "ok"}
```

### `/simpletrade/simpletrade/api/deps.py`
*(统计信息: 25 行, 697 字符 [~0.10%])*
```python
from simpletrade.config.database import SessionLocal # Need SessionLocal
import logging
import traceback
from fastapi import HTTPException

logger = logging.getLogger(__name__)

def get_db():
    """FastAPI 依赖项：获取数据库会话"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def handle_api_exception(func_name: str, exc: Exception) -> None:
    """统一处理API异常并记录日志"""
    error_msg = f"{func_name}失败: {exc}\n{traceback.format_exc()}"
    logger.error(error_msg)
    if isinstance(exc, HTTPException):
        raise exc
    raise HTTPException(status_code=500, detail=f"操作失败: {str(exc)}")

# Add other dependencies here later if needed
# e.g., def get_current_user(...)
```

### `/simpletrade/simpletrade/api/__init__.py`
*(统计信息: 2 行, 29 字符 [~0.00%])*
```python
# API module for SimpleTrade

```

### `/simpletrade/simpletrade/api/routers/strategies.py`
*(统计信息: 351 行, 12675 字符 [~1.81%])*
```python
"""
SimpleTrade策略API

提供策略相关的RESTful API接口。
"""

import logging
from typing import Optional

from fastapi import APIRouter, HTTPException, Depends, Request
from sqlalchemy.orm import Session

from simpletrade.api.deps import get_db, handle_api_exception
from simpletrade.api.schemas.strategy import (
    ApiResponse,
    CreateUserStrategyRequest,
    BacktestRequest
)
from simpletrade.apps.st_backtest.service import BacktestService
from simpletrade.core.engine import STMainEngine
from simpletrade.services.monitor_service import MonitorService
from simpletrade.services.strategy_service import StrategyService

# 获取logger实例
logger = logging.getLogger(__name__)

# 创建路由器
router = APIRouter(
    prefix="/api/strategies",
    tags=["strategies"],
)

# 依赖注入函数
def get_main_engine(request: Request) -> STMainEngine:
    """从FastAPI app state获取主引擎实例"""
    if hasattr(request.app.state, 'main_engine') and request.app.state.main_engine:
        return request.app.state.main_engine
    raise HTTPException(
        status_code=500,
        detail="主引擎未初始化，请检查服务器启动流程"
    )

def get_strategy_service(main_engine: STMainEngine = Depends(get_main_engine)) -> StrategyService:
    """获取策略服务"""
    return StrategyService(main_engine)

def get_monitor_service(main_engine: STMainEngine = Depends(get_main_engine)) -> MonitorService:
    """获取监控服务"""
    return MonitorService(main_engine=main_engine)

def get_backtest_service(main_engine: STMainEngine = Depends(get_main_engine)) -> BacktestService:
    """获取回测服务"""
    try:
        backtest_engine = main_engine.engines.get("st_backtest")
        return BacktestService(backtest_engine)
    except Exception as e:
        logger.warning(f"无法从主引擎获取回测引擎: {e}，创建独立服务实例")
        return BacktestService()

# ---------------- 策略管理API ----------------

@router.get("/types", response_model=ApiResponse)
async def get_strategy_types(
    db: Session = Depends(get_db),
    strategy_service: StrategyService = Depends(get_strategy_service)
):
    """获取所有可用策略类型"""
    try:
        types = strategy_service.get_strategy_types(db)
        return {"success": True, "message": "获取策略类型成功", "data": types}
    except Exception as e:
        handle_api_exception("获取策略类型", e)

@router.get("/", response_model=ApiResponse)
async def get_strategies(
    type: Optional[str] = None,
    category: Optional[str] = None,
    db: Session = Depends(get_db),
    strategy_service: StrategyService = Depends(get_strategy_service)
):
    """获取策略列表，可按类型和分类过滤"""
    try:
        strategies = strategy_service.get_strategies(db, type, category)

        if not strategies:
            return {
                "success": True,
                "message": "没有找到符合条件的策略",
                "data": []
            }

        strategy_list = [
            {
                "id": s.id,
                "name": s.name,
                "description": s.description,
                "category": s.category,
                "type": s.type,
                "complexity": s.complexity,
                "resource_requirement": s.resource_requirement,
                "parameters": s.parameters
            } for s in strategies
        ]

        return {
            "success": True,
            "message": f"获取策略成功，共 {len(strategy_list)} 个",
            "data": strategy_list
        }
    except Exception as e:
        handle_api_exception("获取策略列表", e)

@router.get("/{strategy_id}", response_model=ApiResponse)
async def get_strategy(
    strategy_id: int,
    db: Session = Depends(get_db),
    strategy_service: StrategyService = Depends(get_strategy_service)
):
    """获取单个策略详情，包括源代码"""
    try:
        strategy = strategy_service.get_strategy(db, strategy_id)

        if not strategy:
            raise HTTPException(status_code=404, detail=f"未找到ID为 {strategy_id} 的策略")

        # 加载策略代码
        strategy_code = strategy_service.load_strategy_code(strategy)

        # 获取策略类详情
        strategy_details = None
        for detail in strategy_service.get_strategy_details():
            if detail["class_name"] == strategy.type:
                strategy_details = detail
                break

        strategy_dict = {
            "id": strategy.id,
            "name": strategy.name,
            "description": strategy.description,
            "category": strategy.category,
            "type": strategy.type,
            "identifier": getattr(strategy, 'identifier', None),
            "complexity": strategy.complexity,
            "resource_requirement": strategy.resource_requirement,
            "parameters": strategy.parameters,
            "code": strategy_code
        }

        if strategy_details:
            strategy_dict["class_details"] = strategy_details

        return {
            "success": True,
            "message": "获取策略详情成功",
            "data": strategy_dict
        }
    except Exception as e:
        handle_api_exception("获取策略详情", e)

# ---------------- 用户策略API ----------------

@router.get("/user/{user_id}", response_model=ApiResponse)
async def get_user_strategies(
    user_id: int,
    db: Session = Depends(get_db),
    strategy_service: StrategyService = Depends(get_strategy_service)
):
    """获取用户策略列表"""
    try:
        user_strategies = strategy_service.get_user_strategies(db, user_id)
        return {"success": True, "message": "获取用户策略成功", "data": user_strategies}
    except Exception as e:
        handle_api_exception("获取用户策略", e)

@router.post("/user/create", response_model=ApiResponse)
async def create_user_strategy(
    request: CreateUserStrategyRequest,
    strategy_service: StrategyService = Depends(get_strategy_service)
):
    """创建用户策略实例"""
    try:
        user_strategy = strategy_service.create_user_strategy(
            user_id=request.user_id,
            strategy_id=request.strategy_id,
            name=request.name,
            parameters=request.parameters
        )

        if not user_strategy:
            raise HTTPException(status_code=400, detail="创建用户策略失败")

        user_strategy_dict = {
            "id": user_strategy.id,
            "user_id": user_strategy.user_id,
            "strategy_id": user_strategy.strategy_id,
            "name": user_strategy.name,
            "parameters": user_strategy.parameters,
            "created_at": user_strategy.created_at.isoformat() if user_strategy.created_at else None,
            "updated_at": user_strategy.updated_at.isoformat() if user_strategy.updated_at else None,
            "is_active": user_strategy.is_active
        }

        return {
            "success": True,
            "message": "用户策略创建成功",
            "data": user_strategy_dict
        }
    except ValueError as ve:
        logger.warning(f"创建用户策略参数错误: {ve}")
        raise HTTPException(status_code=400, detail=str(ve))
    except Exception as e:
        handle_api_exception("创建用户策略", e)

@router.post("/user/{user_strategy_id}/start", response_model=ApiResponse)
async def start_strategy(
    user_strategy_id: int,
    strategy_service: StrategyService = Depends(get_strategy_service)
):
    """启动用户策略实例"""
    try:
        success = strategy_service.start_strategy(user_strategy_id)
        if not success:
            raise HTTPException(status_code=400, detail=f"策略 {user_strategy_id} 启动失败")
        return {"success": True, "message": f"策略 {user_strategy_id} 启动成功"}
    except Exception as e:
        handle_api_exception("启动策略", e)

@router.post("/user/{user_strategy_id}/stop", response_model=ApiResponse)
async def stop_strategy(
    user_strategy_id: int,
    strategy_service: StrategyService = Depends(get_strategy_service)
):
    """停止用户策略实例"""
    try:
        success = strategy_service.stop_strategy(user_strategy_id)
        if not success:
            raise HTTPException(status_code=400, detail=f"策略 {user_strategy_id} 停止失败")
        return {"success": True, "message": f"策略 {user_strategy_id} 停止成功"}
    except Exception as e:
        handle_api_exception("停止策略", e)

# ---------------- 回测API ----------------

@router.post("/backtest", response_model=ApiResponse)
async def run_backtest(
    request: BacktestRequest,
    backtest_service: BacktestService = Depends(get_backtest_service)
):
    """运行策略回测"""
    try:
        result = backtest_service.run_backtest(
            strategy_id=request.strategy_id,
            symbol=request.symbol,
            exchange=request.exchange,
            interval=request.interval,
            start_date=request.start_date,
            end_date=request.end_date,
            initial_capital=request.initial_capital,
            rate=request.rate,
            slippage=request.slippage,
            parameters=request.parameters,
            user_id=request.user_id
        )
        return {"success": True, "message": "回测运行成功", "data": result}
    except ValueError as ve:
        logger.warning(f"回测参数错误: {ve}")
        raise HTTPException(status_code=400, detail=str(ve))
    except Exception as e:
        handle_api_exception("运行回测", e)

@router.get("/backtest/records", response_model=ApiResponse)
async def get_backtest_records(
    user_id: Optional[int] = None,
    strategy_id: Optional[int] = None,
    backtest_service: BacktestService = Depends(get_backtest_service)
):
    """获取回测记录列表"""
    try:
        records = backtest_service.get_backtest_records(user_id, strategy_id)

        if not records:
            return {
                "success": True,
                "message": "没有找到符合条件的回测记录",
                "data": []
            }

        record_list = [
            {
                "id": r.id,
                "user_id": r.user_id,
                "strategy_id": r.strategy_id,
                "symbol": r.symbol,
                "exchange": r.exchange,
                "interval": r.interval,
                "start_date": r.start_date.isoformat() if r.start_date else None,
                "end_date": r.end_date.isoformat() if r.end_date else None,
                "initial_capital": float(r.initial_capital) if r.initial_capital is not None else None,
                "final_capital": float(r.final_capital) if r.final_capital is not None else None,
                "total_return": float(r.total_return) if r.total_return is not None else None,
                "annual_return": float(r.annual_return) if r.annual_return is not None else None,
                "max_drawdown": float(r.max_drawdown) if r.max_drawdown is not None else None,
                "sharpe_ratio": float(r.sharpe_ratio) if r.sharpe_ratio is not None else None,
                "results": r.results,
                "created_at": r.created_at.isoformat() if r.created_at else None
            } for r in records
        ]

        return {
            "success": True,
            "message": f"获取回测记录成功，共 {len(record_list)} 条",
            "data": record_list
        }
    except Exception as e:
        handle_api_exception("获取回测记录", e)

@router.get("/backtest/records/{record_id}", response_model=ApiResponse)
async def get_backtest_record(
    record_id: int,
    backtest_service: BacktestService = Depends(get_backtest_service)
):
    """获取单个回测记录详情"""
    try:
        record = backtest_service.get_backtest_record(record_id)
        if not record:
            raise HTTPException(status_code=404, detail="未找到指定的回测记录")

        record_dict = {
            "id": record.id,
            "user_id": record.user_id,
            "strategy_id": record.strategy_id,
            "symbol": record.symbol,
            "exchange": record.exchange,
            "interval": record.interval,
            "start_date": record.start_date.isoformat() if record.start_date else None,
            "end_date": record.end_date.isoformat() if record.end_date else None,
            "initial_capital": float(record.initial_capital) if record.initial_capital is not None else None,
            "final_capital": float(record.final_capital) if record.final_capital is not None else None,
            "total_return": float(record.total_return) if record.total_return is not None else None,
            "annual_return": float(record.annual_return) if record.annual_return is not None else None,
            "max_drawdown": float(record.max_drawdown) if record.max_drawdown is not None else None,
            "sharpe_ratio": float(record.sharpe_ratio) if record.sharpe_ratio is not None else None,
            "results": record.results,
            "created_at": record.created_at.isoformat() if record.created_at else None
        }

        return {"success": True, "message": "获取回测记录详情成功", "data": record_dict}
    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        handle_api_exception("获取回测记录详情", e)
```

### `/simpletrade/simpletrade/api/routers/analysis.py`
*(统计信息: 307 行, 11207 字符 [~1.60%])*
```python
"""
SimpleTrade分析API

提供数据分析功能的RESTful API接口。
直接使用vnpy的数据模型和数据管理功能。
"""

from datetime import datetime
from typing import List, Optional, Dict, Any, Union

from fastapi import APIRouter, Depends, HTTPException, Query, Path, Body
from pydantic import BaseModel, Field
import logging # Added logging

# 导入vnpy的数据模型和数据管理功能
from vnpy.trader.object import BarData as VnpyBarData, TickData
from vnpy.trader.constant import Exchange, Interval

# 导入分析功能和数据管理引擎 App
# TODO: Update imports after moving files and creating deps/schemas
from simpletrade.apps.st_datamanager.api.routes import get_data_manager_engine # 导入用于依赖注入的函数

logger = logging.getLogger(__name__) # Added logger instance

# 创建路由器
router = APIRouter(prefix="/api/analysis", tags=["analysis"])

# 数据模型
# TODO: Move these Pydantic models to simpletrade/api/schemas/analysis.py (or common)
class IndicatorRequest(BaseModel):
    """技术指标请求"""
    symbol: str
    exchange: str
    interval: str
    start_date: str
    end_date: Optional[str] = None
    indicators: List[Dict[str, Any]]

class BacktestRequest(BaseModel):
    """回测请求"""
    symbol: str
    exchange: str
    interval: str
    start_date: str
    end_date: Optional[str] = None
    strategy_name: str
    strategy_params: Dict[str, Any]
    indicators: Optional[List[Dict[str, Any]]] = None
    initial_capital: float = 100000.0

class ApiResponse(BaseModel):
    """API响应"""
    success: bool
    message: str
    data: Optional[Any] = None

# API路由
@router.get("/indicators", response_model=ApiResponse)
async def get_available_indicators():
    """获取可用的技术指标列表"""
    try:
        # 这里列出所有可用的技术指标
        available_indicators = [
            {
                "name": "SMA",
                "description": "简单移动平均线",
                "parameters": [
                    {"name": "period", "type": "int", "default": 20, "description": "周期"}
                ]
            },
            {
                "name": "EMA",
                "description": "指数移动平均线",
                "parameters": [
                    {"name": "period", "type": "int", "default": 20, "description": "周期"}
                ]
            },
            {
                "name": "RSI",
                "description": "相对强弱指数",
                "parameters": [
                    {"name": "period", "type": "int", "default": 14, "description": "周期"}
                ]
            },
            {
                "name": "MACD",
                "description": "平滑异同移动平均线",
                "parameters": [
                    {"name": "fast_period", "type": "int", "default": 12, "description": "快线周期"},
                    {"name": "slow_period", "type": "int", "default": 26, "description": "慢线周期"},
                    {"name": "signal_period", "type": "int", "default": 9, "description": "信号周期"}
                ]
            },
            {
                "name": "BOLL",
                "description": "布林线",
                "parameters": [
                    {"name": "period", "type": "int", "default": 20, "description": "周期"},
                    {"name": "std_dev", "type": "float", "default": 2.0, "description": "标准差倍数"}
                ]
            },
            {
                "name": "KDJ",
                "description": "KDJ随机指标",
                "parameters": [
                    {"name": "k_period", "type": "int", "default": 9, "description": "K线周期"},
                    {"name": "d_period", "type": "int", "default": 3, "description": "D线周期"},
                    {"name": "j_period", "type": "int", "default": 3, "description": "J线周期"}
                ]
            }
        ]

        return {
            "success": True,
            "message": f"获取可用指标成功，共 {len(available_indicators)} 个",
            "data": available_indicators
        }
    except Exception as e:
        logger.error(f"获取可用指标失败: {e}", exc_info=True) # Added logger
        return {
            "success": False,
            "message": f"获取可用指标失败: {str(e)}"
        }

@router.post("/indicators", response_model=ApiResponse)
async def calculate_technical_indicators(request: IndicatorRequest, engine = Depends(get_data_manager_engine)):
    """计算技术指标"""
    if not engine:
        logger.error("Data manager engine not available for indicator calculation.") # Updated log
        raise HTTPException(status_code=500, detail="数据管理引擎不可用")
    try:
        # 解析参数
        exchange_obj = Exchange(request.exchange)
        interval_obj = Interval(request.interval)
        start = datetime.strptime(request.start_date, "%Y-%m-%d")
        end = datetime.now()
        if request.end_date:
            end = datetime.strptime(request.end_date, "%Y-%m-%d")

        # 加载数据 (使用注入的引擎)
        logger.debug(f"Loading bars for {request.symbol} {request.exchange} {request.interval} from {start} to {end}")
        bars: List[VnpyBarData] = engine.get_bar_data(
            symbol=request.symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start=start,
            end=end
        )

        if not bars:
            logger.warning(f"No bar data found for indicator calculation: {request.symbol} {request.exchange} {request.interval}")
            return {
                "success": False,
                "message": "未找到符合条件的数据"
            }
        logger.debug(f"Loaded {len(bars)} bars.")

        # 计算技术指标
        logger.debug(f"Calculating indicators: {request.indicators}")
        df = calculate_indicators(bars, request.indicators)
        logger.debug(f"Indicator calculation complete. DataFrame shape: {df.shape}")

        # 转换为JSON可序列化格式
        # Consider optimizing this part if performance is critical
        result = []
        for index, row in df.iterrows():
            data = {
                "datetime": index.strftime("%Y-%m-%d %H:%M:%S"),
                "open": row["open"],
                "high": row["high"],
                "low": row["low"],
                "close": row["close"],
                "volume": row["volume"]
            }

            # 添加技术指标
            for col in df.columns:
                if col not in ["open", "high", "low", "close", "volume", "open_interest"]:
                    # Ensure NaN is converted to None for JSON compatibility
                    data[col] = None if pd.isna(row[col]) else row[col]

            result.append(data)

        return {
            "success": True,
            "message": f"计算技术指标成功，共 {len(result)} 条数据",
            "data": result
        }
    except ValueError as ve:
        logger.warning(f"Invalid parameters for indicator calculation: {ve}")
        raise HTTPException(status_code=400, detail=f"参数错误: {ve}")
    except Exception as e:
        logger.error(f"计算技术指标失败: {e}", exc_info=True) # Added logger
        return {
            "success": False,
            "message": f"计算技术指标失败: {str(e)}"
        }

@router.post("/backtest", response_model=ApiResponse)
async def run_strategy_backtest(request: BacktestRequest, engine = Depends(get_data_manager_engine)):
    """运行策略回测"""
    if not engine:
        logger.error("Data manager engine not available for backtest.") # Updated log
        raise HTTPException(status_code=500, detail="数据管理引擎不可用")
    try:
        # 解析参数
        exchange_obj = Exchange(request.exchange)
        interval_obj = Interval(request.interval)
        start = datetime.strptime(request.start_date, "%Y-%m-%d")
        end = datetime.now()
        if request.end_date:
            end = datetime.strptime(request.end_date, "%Y-%m-%d")

        # 加载数据 (使用注入的引擎)
        logger.debug(f"Loading bars for backtest: {request.symbol} {request.exchange} {request.interval} from {start} to {end}")
        bars: List[VnpyBarData] = engine.get_bar_data(
            symbol=request.symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start=start,
            end=end
        )

        if not bars:
            logger.warning(f"No bar data found for backtest: {request.symbol} {request.exchange} {request.interval}")
            return {
                "success": False,
                "message": "未找到符合条件的数据"
            }
        logger.debug(f"Loaded {len(bars)} bars for backtest.")

        # 运行回测 (Assuming backtest_strategy is defined in core.analysis)
        logger.debug(f"Running backtest for strategy '{request.strategy_name}' with params: {request.strategy_params}")
        result = backtest_strategy(
            bars=bars,
            strategy_name=request.strategy_name,
            strategy_params=request.strategy_params,
            indicators=request.indicators,
            initial_capital=request.initial_capital
        )

        if not result:
            logger.error(f"Backtest execution failed for strategy '{request.strategy_name}'.")
            return {
                "success": False,
                "message": "回测执行失败，未生成结果"
            }
        logger.debug("Backtest execution complete.")

        # 获取回测结果 (Assuming result has a to_dict() method)
        backtest_result = result.to_dict()

        # 获取交易记录
        trades = []
        # Check if 'position_change' column exists before iterating
        if "position_change" in result.df.columns:
            for index, row in result.df.iterrows():
                if row["position_change"] != 0:
                    trade = {
                        "datetime": index.strftime("%Y-%m-%d %H:%M:%S"),
                        "type": "买入" if row["position_change"] > 0 else "卖出",
                        "price": row["close"],
                        "profit": row["trade_profit"] if "trade_profit" in row and not pd.isna(row["trade_profit"]) else 0
                    }
                    trades.append(trade)
        else:
            logger.warning("'position_change' column not found in backtest result DataFrame. Cannot extract trades.")

        # 获取资金曲线
        equity_curve = []
        if "capital" in result.df.columns:
             for index, row in result.df.iterrows():
                if not pd.isna(row["capital"]):
                    point = {
                        "datetime": index.strftime("%Y-%m-%d %H:%M:%S"),
                        "value": row["capital"]
                    }
                    equity_curve.append(point)
        else:
            logger.warning("'capital' column not found in backtest result DataFrame. Cannot extract equity curve.")

        # Combine results
        response_data = {
            "statistics": backtest_result,
            "trades": trades,
            "equity_curve": equity_curve
        }

        return {
            "success": True,
            "message": "策略回测成功",
            "data": response_data
        }
    except ValueError as ve:
        logger.warning(f"Backtest failed due to invalid input: {ve}")
        raise HTTPException(status_code=400, detail=f"参数错误: {ve}")
    except Exception as e:
        logger.error(f"运行策略回测失败: {e}", exc_info=True) # Added logger
        return {
            "success": False,
            "message": f"运行策略回测失败: {str(e)}"
        }

# Placeholder for report generation endpoint if needed
# @router.post("/backtest/report", response_model=ApiResponse)
# async def generate_backtest_report_api(...):
#     ...
```

### `/simpletrade/simpletrade/api/routers/data.py`
*(统计信息: 173 行, 4765 字符 [~0.68%])*
```python
"""
数据相关API路由定义
"""

import logging
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from simpletrade.core.database import get_db
from simpletrade.models.database import DataImportLog
from simpletrade.api.schemas.common import ApiResponse

router = APIRouter(
    prefix="/api/data",
    tags=["data"],
)

logger = logging.getLogger(__name__)

@router.get("/available-symbols", response_model=ApiResponse)
async def get_available_symbols(
    exchange: Optional[str] = None,
    interval: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    获取系统中可用的合约代码列表

    Args:
        exchange: 可选，筛选特定交易所的合约
        interval: 可选，筛选特定周期的合约

    Returns:
        包含可用合约代码的响应对象
    """
    try:
        # 构建查询
        query = db.query(DataImportLog.symbol).distinct()

        # 根据参数筛选
        if exchange:
            query = query.filter(DataImportLog.exchange == exchange)
        if interval:
            query = query.filter(DataImportLog.interval == interval)

        # 获取所有唯一的合约代码
        symbols = [row[0] for row in query.all()]

        return {
            "success": True,
            "message": f"获取可用合约代码成功，共 {len(symbols)} 个",
            "data": symbols
        }
    except Exception as e:
        logger.error(f"获取可用合约代码失败: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"获取可用合约代码失败: {str(e)}")

@router.get("/available-exchanges", response_model=ApiResponse)
async def get_available_exchanges(
    symbol: Optional[str] = None,
    interval: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    获取系统中可用的交易所列表

    Args:
        symbol: 可选，筛选特定合约的交易所
        interval: 可选，筛选特定周期的交易所

    Returns:
        包含可用交易所的响应对象
    """
    try:
        # 构建查询
        query = db.query(DataImportLog.exchange).distinct()

        # 根据参数筛选
        if symbol:
            query = query.filter(DataImportLog.symbol == symbol)
        if interval:
            query = query.filter(DataImportLog.interval == interval)

        # 获取所有唯一的交易所
        exchanges = [row[0] for row in query.all()]

        return {
            "success": True,
            "message": f"获取可用交易所成功，共 {len(exchanges)} 个",
            "data": exchanges
        }
    except Exception as e:
        logger.error(f"获取可用交易所失败: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"获取可用交易所失败: {str(e)}")

@router.get("/available-intervals", response_model=ApiResponse)
async def get_available_intervals(
    symbol: Optional[str] = None,
    exchange: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    获取系统中可用的K线周期列表

    Args:
        symbol: 可选，筛选特定合约的周期
        exchange: 可选，筛选特定交易所的周期

    Returns:
        包含可用K线周期的响应对象
    """
    try:
        # 构建查询
        query = db.query(DataImportLog.interval).distinct()

        # 根据参数筛选
        if symbol:
            query = query.filter(DataImportLog.symbol == symbol)
        if exchange:
            query = query.filter(DataImportLog.exchange == exchange)

        # 获取所有唯一的K线周期
        intervals = [row[0] for row in query.all()]

        return {
            "success": True,
            "message": f"获取可用K线周期成功，共 {len(intervals)} 个",
            "data": intervals
        }
    except Exception as e:
        logger.error(f"获取可用K线周期失败: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"获取可用K线周期失败: {str(e)}")

@router.get("/available-data", response_model=ApiResponse)
async def get_available_data(db: Session = Depends(get_db)):
    """
    获取系统中所有可用的数据记录，包括合约、交易所和周期

    Returns:
        包含可用数据记录的响应对象
    """
    try:
        # 查询所有数据导入日志记录
        query = db.query(
            DataImportLog.symbol,
            DataImportLog.exchange,
            DataImportLog.interval,
            DataImportLog.last_begin_date,
            DataImportLog.last_end_date,
            DataImportLog.status
        )

        # 获取所有记录并格式化
        records = []
        for row in query.all():
            records.append({
                "symbol": row[0],
                "exchange": row[1],
                "interval": row[2],
                "start_date": row[3].isoformat() if row[3] else None,
                "end_date": row[4].isoformat() if row[4] else None,
                "status": row[5]
            })

        return {
            "success": True,
            "message": f"获取可用数据记录成功，共 {len(records)} 个",
            "data": records
        }
    except Exception as e:
        logger.error(f"获取可用数据记录失败: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"获取可用数据记录失败: {str(e)}")
```

### `/simpletrade/simpletrade/api/routers/misc.py`
*(统计信息: 33 行, 1013 字符 [~0.15%])*
```python
from fastapi import APIRouter

# Test Router
test_router = APIRouter(prefix="/api/test", tags=["test"])

@test_router.get("/hello")
async def hello():
    return {"message": "Hello from SimpleTrade API!"}

@test_router.get("/info")
async def info():
    return {
        "status": "ok",
        "version": "0.1.0", # Consider making version dynamic later
        "api": "SimpleTrade API",
        "time": "2024-04-17" # Consider making time dynamic later
    }

# Health Check Router
health_router = APIRouter(prefix="/api/health", tags=["health"])

@health_router.get("/")
async def health_check():
    return {"status": "ok", "message": "API服务正常运行"}

# Combine routers for easier import in server.py (optional but can be convenient)
# You could import test_router and health_router separately in server.py,
# or import this combined router. Let's export them separately for clarity.

# Export individual routers
# router = APIRouter()
# router.include_router(test_router)
# router.include_router(health_router)
```

### `/simpletrade/simpletrade/api/routers/__init__.py`
*(统计信息: 5 行, 32 字符 [~0.00%])*
```python
"""
API路由包

用于组织和管理各类API路由。
"""
```

### `/simpletrade/simpletrade/api/routers/wechat/auth.py`
*(统计信息: 186 行, 6652 字符 [~0.95%])*
```python
"""
SimpleTrade微信小程序认证接口

提供微信小程序认证接口，用于用户登录和授权。
"""

import os
import time
import json
import hashlib
import hmac
import base64
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List

import requests
from fastapi import APIRouter, Depends, HTTPException, Header, Query, Body
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel, Field
from jose import JWTError, jwt

# 创建路由器
# TODO: This router is likely imported as `auth_router` in server.py. Keep the name consistent?
router = APIRouter(prefix="/api/wechat/auth", tags=["wechat_auth"])

# 配置信息
# 注意：在实际应用中，这些信息应该存储在环境变量或配置文件中
# TODO: Move configuration loading to simpletrade/config/settings.py
WECHAT_APP_ID = os.getenv("WECHAT_APP_ID", "your_app_id")
WECHAT_APP_SECRET = os.getenv("WECHAT_APP_SECRET", "your_app_secret")
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "your_jwt_secret_key")
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24  # 1天

# 数据模型
# TODO: Move these schemas to simpletrade/api/schemas/wechat.py or common.py
class WechatLoginRequest(BaseModel):
    """微信登录请求"""
    code: str = Field(..., description="微信登录code")

class WechatLoginResponse(BaseModel):
    """微信登录响应"""
    access_token: str = Field(..., description="访问令牌")
    token_type: str = Field(..., description="令牌类型")
    expires_in: int = Field(..., description="过期时间（秒）")
    openid: str = Field(..., description="用户openid")
    session_key: str = Field(..., description="会话密钥")

class TokenData(BaseModel):
    """令牌数据"""
    openid: Optional[str] = None
    exp: Optional[int] = None

# 内存中的用户数据（实际应用中应该使用数据库）
# TODO: Replace in-memory DB with proper user service/repository
users_db = {}

# OAuth2密码流
# TODO: Move oauth2_scheme and get_current_user dependency to simpletrade/api/deps.py
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/wechat/auth/token") # Adjust tokenUrl if prefix changes

# 工具函数
# TODO: Move create_access_token helper to a utility module (e.g., simpletrade/utils/security.py)
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """创建访问令牌"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire.timestamp()})
    encoded_jwt = jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    """获取当前用户"""
    # TODO: Move this dependency function to simpletrade/api/deps.py
    credentials_exception = HTTPException(
        status_code=401,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])
        openid: str = payload.get("openid")
        if openid is None:
            raise credentials_exception
        token_data = TokenData(openid=openid, exp=payload.get("exp"))
    except JWTError:
        raise credentials_exception

    # TODO: Replace with actual user fetching from DB/Service
    user = users_db.get(openid)
    if user is None:
        raise credentials_exception
    return user

# API路由
@router.post("/login", response_model=WechatLoginResponse)
async def wechat_login(request: WechatLoginRequest):
    """微信登录"""
    # 调用微信登录API
    # TODO: Consider moving HTTP request logic to a service layer
    url = f"https://api.weixin.qq.com/sns/jscode2session?appid={WECHAT_APP_ID}&secret={WECHAT_APP_SECRET}&js_code={request.code}&grant_type=authorization_code"
    try:
        response = requests.get(url)
        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)
        data = response.json()
    except requests.exceptions.RequestException as e:
        # Log the error
        print(f"Error calling WeChat API: {e}")
        raise HTTPException(status_code=503, detail="无法连接微信服务")

    if "errcode" in data and data["errcode"] != 0:
        # Log the error from WeChat
        print(f"WeChat API error: {data}")
        raise HTTPException(status_code=400, detail=f"微信登录失败: {data.get('errmsg', '未知错误')}")

    openid = data.get("openid")
    session_key = data.get("session_key")

    if not openid or not session_key:
        # Log this unexpected situation
        print(f"WeChat API response missing openid or session_key: {data}")
        raise HTTPException(status_code=400, detail="微信登录失败: 未获取到openid或session_key")

    # 创建用户（如果不存在）- TODO: Replace with DB/Service logic
    if openid not in users_db:
        users_db[openid] = {
            "openid": openid,
            "session_key": session_key,
            "created_at": datetime.now().isoformat(),
            "last_login": datetime.now().isoformat()
        }
    else:
        users_db[openid]["session_key"] = session_key
        users_db[openid]["last_login"] = datetime.now().isoformat()

    # 创建访问令牌
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"openid": openid},
        expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "bearer",
        "expires_in": int(access_token_expires.total_seconds()), # Return seconds
        "openid": openid,
        "session_key": session_key # Note: Sending session_key back might be a security risk depending on usage
    }

@router.post("/token")
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    """获取访问令牌（用于OAuth2密码流）"""
    # 在实际应用中，这里应该验证用户名和密码
    # 但在微信小程序中，我们通常使用code登录，所以这里只是为了兼容OAuth2密码流

    # TODO: Replace with actual user validation logic if this endpoint is needed
    # 检查用户是否存在
    if form_data.username not in users_db: # Use form_data.username as openid placeholder
        raise HTTPException(
            status_code=401,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # 创建访问令牌
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"openid": form_data.username},
        expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "bearer"
    }

@router.get("/me")
async def read_users_me(current_user: dict = Depends(get_current_user)):
    """获取当前用户信息"""
    # Ensure the dependency function get_current_user is moved to deps.py
    return current_user
```

### `/simpletrade/simpletrade/api/routers/wechat/data.py`
*(统计信息: 163 行, 6202 字符 [~0.89%])*
```python
"""
SimpleTrade微信小程序数据接口

提供与微信小程序用户数据和交易数据相关的接口。
"""

from typing import Dict, Any, Optional, List
from datetime import date, datetime

from fastapi import APIRouter, Depends, HTTPException, Query, Body
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session

# TODO: Update imports after moving files and refactoring
from simpletrade.config.database import get_db # Will be moved to deps
from simpletrade.models.database import User, TradeRecord, Position # Assuming these models exist
from simpletrade.api.routers.wechat.auth import get_current_user # TODO: Move get_current_user to deps.py
from simpletrade.services import data_service # Assuming a data_service exists
from simpletrade.services.strategy_service import StrategyService # Maybe needed for strategy lists?

# TODO: This depends on auth.py - need to move get_current_user to deps.py
# from .auth import get_current_user

# 创建路由器
# TODO: This router is likely imported as `wechat_data_router` in server.py. Keep the name consistent?
router = APIRouter(prefix="/api/wechat/data", tags=["wechat_data"])

# 数据模型
# TODO: Move these schemas to simpletrade/api/schemas/wechat.py or common.py
class UserProfile(BaseModel):
    """用户资料"""
    openid: str
    nickname: Optional[str] = None
    avatar_url: Optional[str] = None
    # Add other relevant fields

class TradeRecordModel(BaseModel):
    """交易记录模型"""
    id: int
    user_id: int
    strategy_id: Optional[int] = None
    symbol: str
    exchange: str
    order_id: str
    trade_id: str
    direction: str
    offset: str
    price: float
    volume: int
    trade_time: datetime

class PositionModel(BaseModel):
    """持仓模型"""
    id: int
    user_id: int
    symbol: str
    exchange: str
    direction: str
    volume: int
    open_price: float
    current_price: Optional[float] = None # Maybe fetched live
    pnl: Optional[float] = None # Calculated

# API路由
@router.get("/profile", response_model=UserProfile)
async def get_user_profile(current_user: dict = Depends(get_current_user)):
    """获取当前用户资料"""
    # In a real app, fetch profile from database based on current_user['openid']
    # TODO: Implement user profile fetching via a UserService
    return UserProfile(
        openid=current_user.get("openid", "N/A"),
        nickname=current_user.get("nickname", "微信用户"), # Placeholder
        avatar_url=current_user.get("avatar_url") # Placeholder
    )

@router.put("/profile", response_model=UserProfile)
async def update_user_profile(profile_update: UserProfile, current_user: dict = Depends(get_current_user)):
    """更新用户资料"""
    # In a real app, update user profile in the database
    # TODO: Implement user profile updating via a UserService
    openid = current_user.get("openid")
    if not openid:
         raise HTTPException(status_code=401, detail="Invalid user token")

    # Placeholder update logic
    # users_db[openid].update(profile_update.dict(exclude_unset=True))
    print(f"Updating profile for {openid} with: {profile_update.dict(exclude_unset=True)}")

    # Return the updated profile (or fetch again from DB)
    return UserProfile(
        openid=openid,
        nickname=profile_update.nickname,
        avatar_url=profile_update.avatar_url
    )


@router.get("/trades", response_model=List[TradeRecordModel])
async def get_trade_records(
    current_user: dict = Depends(get_current_user),
    symbol: Optional[str] = Query(None, description="按标的物过滤"),
    start_date: Optional[date] = Query(None, description="按开始日期过滤"),
    end_date: Optional[date] = Query(None, description="按结束日期过滤"),
    limit: int = Query(100, description="返回记录数量", ge=1, le=1000),
    # TODO: Inject a DataService/TradeService
    db: Session = Depends(get_db) # TODO: Update import from deps
):
    """获取用户的交易记录"""
    openid = current_user.get("openid")
    if not openid:
        raise HTTPException(status_code=401, detail="Invalid user token")

    # TODO: Replace with actual user ID fetching based on openid
    user_id = 1 # Placeholder User ID

    # TODO: Fetch trades using a dedicated service
    try:
        # Placeholder: Querying DB directly, replace with service call
        query = db.query(TradeRecord).filter(TradeRecord.user_id == user_id)
        if symbol:
            query = query.filter(TradeRecord.symbol == symbol)
        if start_date:
            query = query.filter(TradeRecord.trade_time >= datetime.combine(start_date, datetime.min.time()))
        if end_date:
            query = query.filter(TradeRecord.trade_time <= datetime.combine(end_date, datetime.max.time()))

        trades = query.order_by(TradeRecord.trade_time.desc()).limit(limit).all()

        # Convert DB models to Pydantic models
        result = [TradeRecordModel.from_orm(trade) for trade in trades]
        return result
    except Exception as e:
        print(f"Error fetching trade records for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail="获取交易记录失败")


@router.get("/positions", response_model=List[PositionModel])
async def get_positions(
    current_user: dict = Depends(get_current_user),
    # TODO: Inject a DataService/PositionService
    db: Session = Depends(get_db) # TODO: Update import from deps
):
    """获取用户的当前持仓"""
    openid = current_user.get("openid")
    if not openid:
        raise HTTPException(status_code=401, detail="Invalid user token")

    # TODO: Replace with actual user ID fetching based on openid
    user_id = 1 # Placeholder User ID

    # TODO: Fetch positions using a dedicated service
    try:
        # Placeholder: Querying DB directly, replace with service call
        positions = db.query(Position).filter(Position.user_id == user_id, Position.volume != 0).all()

        # Convert DB models to Pydantic models
        # TODO: Add logic to fetch current_price and calculate PNL if needed
        result = [PositionModel.from_orm(pos) for pos in positions]
        return result
    except Exception as e:
         print(f"Error fetching positions for user {user_id}: {e}")
         raise HTTPException(status_code=500, detail="获取持仓信息失败")

# Add more data-related endpoints as needed, e.g., account balance, strategy performance, etc.
```

### `/simpletrade/simpletrade/api/wechat/data.py`
*(统计信息: 227 行, 6813 字符 [~0.98%])*
```python
"""
SimpleTrade微信小程序数据接口

提供微信小程序数据接口，用于数据查询和管理。
直接使用vnpy的数据模型和数据管理功能。
"""

from datetime import datetime
from typing import List, Optional, Dict, Any, Union

from fastapi import APIRouter, Depends, HTTPException, Query, Path, Body
from pydantic import BaseModel, Field

# 导入vnpy的数据模型和数据管理功能
from vnpy.trader.object import BarData, TickData
from vnpy.trader.constant import Exchange, Interval
# # Ensure consistent vnpy import path (should be vnpy.vnpy.*)
# # from vnpy.vnpy.trader.object import BarData, TickData
# # from vnpy.vnpy.trader.constant import Exchange, Interval
# # try:
# #     from vnpy.trader.object import BarData, TickData

# 导入我们的数据管理器和认证功能
# Remove import of deleted DataManager
# from simpletrade.core.data import DataManager
from .auth import get_current_user
# Import the engine getter for dependency injection
from simpletrade.apps.st_datamanager.api.routes import get_data_manager_engine

# 创建数据管理器实例
# data_manager = DataManager()
# Data manager engine will be injected via Depends

# 创建路由器
router = APIRouter(prefix="/api/wechat/data", tags=["wechat_data"])

# 数据模型
class BarDataModel(BaseModel):
    """K线数据模型"""
    datetime: str
    open: float = Field(..., alias="open_price")
    high: float = Field(..., alias="high_price")
    low: float = Field(..., alias="low_price")
    close: float = Field(..., alias="close_price")
    volume: float
    open_interest: float

    class Config:
        allow_population_by_field_name = True

class DataOverviewModel(BaseModel):
    """数据概览模型"""
    symbol: str
    exchange: str
    interval: Optional[str] = None
    count: int
    start: str
    end: str
    type: str

class ApiResponse(BaseModel):
    """API响应模型"""
    success: bool
    message: str
    data: Optional[Any] = None

# API路由
@router.get("/overview", response_model=ApiResponse)
async def get_data_overview(
    current_user: dict = Depends(get_current_user),
    engine = Depends(get_data_manager_engine) # Inject engine
):
    """获取数据概览"""
    if not engine:
        raise HTTPException(status_code=500, detail="数据管理引擎不可用")
    try:
        # Use engine to get data overview
        available_data = engine.get_available_data()

        # # 获取K线数据概览 (Old logic, replaced by get_available_data)
        # bar_overviews = data_manager.get_bar_overview()
        # # 获取Tick数据概览
        # tick_overviews = data_manager.get_tick_overview()
        #
        # # 转换为API模型
        # result = []
        #
        # for overview in bar_overviews:
        #     result.append({
        #         "symbol": overview.symbol,
        #         "exchange": overview.exchange.value,
        #         "interval": overview.interval.value,
        #         "count": overview.count,
        #         "start": overview.start.strftime("%Y-%m-%d %H:%M:%S"),
        #         "end": overview.end.strftime("%Y-%m-%d %H:%M:%S"),
        #         "type": "bar"
        #     })
        #
        # for overview in tick_overviews:
        #     result.append({
        #         "symbol": overview.symbol,
        #         "exchange": overview.exchange.value,
        #         "count": overview.count,
        #         "start": overview.start.strftime("%Y-%m-%d %H:%M:%S.%f"),
        #         "end": overview.end.strftime("%Y-%m-%d %H:%M:%S.%f"),
        #         "type": "tick"
        #     })

        return {
            "success": True,
            "message": "获取数据概览成功",
            "data": available_data # Return data from engine
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"获取数据概览失败: {str(e)}"
        }

@router.get("/bars", response_model=ApiResponse)
async def get_bars(
    symbol: str,
    exchange: str,
    interval: str,
    start_date: str,
    end_date: Optional[str] = None,
    current_user: dict = Depends(get_current_user),
    engine = Depends(get_data_manager_engine) # Inject engine
):
    """获取K线数据"""
    if not engine:
        raise HTTPException(status_code=500, detail="数据管理引擎不可用")
    try:
        # 解析参数
        exchange_obj = Exchange(exchange)
        interval_obj = Interval(interval)
        start = datetime.strptime(start_date, "%Y-%m-%d")
        end = datetime.now()
        if end_date:
            end = datetime.strptime(end_date, "%Y-%m-%d")

        # 查询数据 (Use engine)
        bars = engine.get_bar_data(
            symbol=symbol,
            exchange=exchange_obj,
            interval=interval_obj,
            start=start,
            end=end
        )

        # 转换为API模型
        result = []
        for bar in bars:
            result.append({
                "datetime": bar.datetime.strftime("%Y-%m-%d %H:%M:%S"),
                "open_price": bar.open_price,
                "high_price": bar.high_price,
                "low_price": bar.low_price,
                "close_price": bar.close_price,
                "volume": bar.volume,
                "open_interest": bar.open_interest
            })

        return {
            "success": True,
            "message": f"获取K线数据成功，共 {len(result)} 条",
            "data": result
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"获取K线数据失败: {str(e)}"
        }

@router.get("/ticks", response_model=ApiResponse)
async def get_ticks(
    symbol: str,
    exchange: str,
    start_date: str,
    end_date: Optional[str] = None,
    current_user: dict = Depends(get_current_user),
    engine = Depends(get_data_manager_engine) # Inject engine
):
    """获取Tick数据"""
    if not engine:
        raise HTTPException(status_code=500, detail="数据管理引擎不可用")
    try:
        # 解析参数
        exchange_obj = Exchange(exchange)
        start = datetime.strptime(start_date, "%Y-%m-%d")
        end = datetime.now()
        if end_date:
            end = datetime.strptime(end_date, "%Y-%m-%d")

        # 查询数据 (Use engine)
        ticks = engine.get_tick_data(
            symbol=symbol,
            exchange=exchange_obj,
            start=start,
            end=end
        )

        # 转换为API模型
        result = []
        for tick in ticks:
            result.append({
                "datetime": tick.datetime.strftime("%Y-%m-%d %H:%M:%S.%f"),
                "last_price": tick.last_price,
                "volume": tick.volume,
                "open_interest": tick.open_interest,
                "bid_price_1": tick.bid_price_1,
                "ask_price_1": tick.ask_price_1,
                "bid_volume_1": tick.bid_volume_1,
                "ask_volume_1": tick.ask_volume_1
            })

        return {
            "success": True,
            "message": f"获取Tick数据成功，共 {len(result)} 条",
            "data": result
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"获取Tick数据失败: {str(e)}"
        }

```

### `/simpletrade/simpletrade/api/wechat/auth.py`
*(统计信息: 166 行, 5097 字符 [~0.73%])*
```python
"""
SimpleTrade微信小程序认证接口

提供微信小程序认证接口，用于用户登录和授权。
"""

import os
import time
import json
import hashlib
import hmac
import base64
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List

import requests
from fastapi import APIRouter, Depends, HTTPException, Header, Query, Body
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel, Field
from jose import JWTError, jwt

# 创建路由器
router = APIRouter(prefix="/api/wechat/auth", tags=["wechat_auth"])

# 配置信息
# 注意：在实际应用中，这些信息应该存储在环境变量或配置文件中
WECHAT_APP_ID = os.getenv("WECHAT_APP_ID", "your_app_id")
WECHAT_APP_SECRET = os.getenv("WECHAT_APP_SECRET", "your_app_secret")
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "your_jwt_secret_key")
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24  # 1天

# 数据模型
class WechatLoginRequest(BaseModel):
    """微信登录请求"""
    code: str = Field(..., description="微信登录code")

class WechatLoginResponse(BaseModel):
    """微信登录响应"""
    access_token: str = Field(..., description="访问令牌")
    token_type: str = Field(..., description="令牌类型")
    expires_in: int = Field(..., description="过期时间（秒）")
    openid: str = Field(..., description="用户openid")
    session_key: str = Field(..., description="会话密钥")

class TokenData(BaseModel):
    """令牌数据"""
    openid: Optional[str] = None
    exp: Optional[int] = None

# 内存中的用户数据（实际应用中应该使用数据库）
users_db = {}

# OAuth2密码流
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/wechat/auth/token")

# 工具函数
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """创建访问令牌"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire.timestamp()})
    encoded_jwt = jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    """获取当前用户"""
    credentials_exception = HTTPException(
        status_code=401,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])
        openid: str = payload.get("openid")
        if openid is None:
            raise credentials_exception
        token_data = TokenData(openid=openid, exp=payload.get("exp"))
    except JWTError:
        raise credentials_exception

    user = users_db.get(openid)
    if user is None:
        raise credentials_exception
    return user

# API路由
@router.post("/login", response_model=WechatLoginResponse)
async def wechat_login(request: WechatLoginRequest):
    """微信登录"""
    # 调用微信登录API
    url = f"https://api.weixin.qq.com/sns/jscode2session?appid={WECHAT_APP_ID}&secret={WECHAT_APP_SECRET}&js_code={request.code}&grant_type=authorization_code"
    response = requests.get(url)
    data = response.json()

    if "errcode" in data and data["errcode"] != 0:
        raise HTTPException(status_code=400, detail=f"微信登录失败: {data.get('errmsg', '未知错误')}")

    openid = data.get("openid")
    session_key = data.get("session_key")

    if not openid or not session_key:
        raise HTTPException(status_code=400, detail="微信登录失败: 未获取到openid或session_key")

    # 创建用户（如果不存在）
    if openid not in users_db:
        users_db[openid] = {
            "openid": openid,
            "session_key": session_key,
            "created_at": datetime.now().isoformat(),
            "last_login": datetime.now().isoformat()
        }
    else:
        users_db[openid]["session_key"] = session_key
        users_db[openid]["last_login"] = datetime.now().isoformat()

    # 创建访问令牌
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"openid": openid},
        expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "bearer",
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        "openid": openid,
        "session_key": session_key
    }

@router.post("/token")
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    """获取访问令牌（用于OAuth2密码流）"""
    # 在实际应用中，这里应该验证用户名和密码
    # 但在微信小程序中，我们通常使用code登录，所以这里只是为了兼容OAuth2密码流

    # 检查用户是否存在
    if form_data.username not in users_db:
        raise HTTPException(
            status_code=401,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # 创建访问令牌
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"openid": form_data.username},
        expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "bearer"
    }

@router.get("/me")
async def read_users_me(current_user: dict = Depends(get_current_user)):
    """获取当前用户信息"""
    return current_user

```

### `/simpletrade/simpletrade/api/wechat/__init__.py`
*(统计信息: 9 行, 133 字符 [~0.02%])*
```python
"""
SimpleTrade微信小程序接口

提供微信小程序接口，用于与微信小程序进行交互。
"""

from .auth import router as auth_router
from .data import router as data_router

```

### `/simpletrade/simpletrade/api/schemas/strategy.py`
*(统计信息: 102 行, 2412 字符 [~0.35%])*
```python
"""
SimpleTrade 策略模块数据模型

定义策略相关的Pydantic数据模型，用于API请求和响应的验证和序列化。
"""

from datetime import date
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field

# 通用API响应模型
class ApiResponse(BaseModel):
    """API响应模型"""
    success: bool
    message: str
    data: Optional[Any] = None

# 策略参数模型
class StrategyParameter(BaseModel):
    """策略参数模型"""
    type: str
    default: Any
    min: Optional[Any] = None
    max: Optional[Any] = None
    options: Optional[List[str]] = None
    description: str

# 策略模型
class StrategyModel(BaseModel):
    """策略模型"""
    id: int
    name: str
    description: Optional[str] = None
    category: Optional[str] = None
    type: str
    complexity: int
    resource_requirement: int
    parameters: Dict[str, StrategyParameter]

# 创建策略请求模型
class CreateStrategyRequest(BaseModel):
    """创建策略请求模型"""
    name: str
    description: Optional[str] = None
    type: str
    category: Optional[str] = None
    parameters: Dict[str, Any]

# 创建用户策略请求模型
class CreateUserStrategyRequest(BaseModel):
    """创建用户策略请求模型"""
    user_id: int
    strategy_id: int
    name: str
    parameters: Dict[str, Any]

# 回测请求模型
class BacktestRequest(BaseModel):
    """运行回测请求模型"""
    user_id: int
    strategy_id: int
    symbol: str
    exchange: str
    interval: str
    start_date: date
    end_date: date
    initial_capital: float
    parameters: Optional[Dict[str, Any]] = Field(None, description="用户自定义策略参数，覆盖默认值")
    rate: float = Field(..., description="手续费率 (例如 0.0001 for 0.01%)")
    slippage: float = Field(..., description="滑点大小 (例如 0.2)")

# 用户策略详情模型
class UserStrategyDetail(BaseModel):
    """用户策略详情模型"""
    id: int
    user_id: int
    strategy_id: int
    name: str
    parameters: Dict[str, Any]
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    is_active: bool

# 回测记录模型
class BacktestRecord(BaseModel):
    """回测记录模型"""
    id: int
    user_id: int
    strategy_id: int
    symbol: str
    exchange: str
    interval: str
    start_date: Optional[str] = None
    end_date: Optional[str] = None
    initial_capital: Optional[float] = None
    final_capital: Optional[float] = None
    total_return: Optional[float] = None
    annual_return: Optional[float] = None
    max_drawdown: Optional[float] = None
    sharpe_ratio: Optional[float] = None
    results: Optional[Dict[str, Any]] = None
    created_at: Optional[str] = None
```

### `/simpletrade/simpletrade/api/schemas/backtest.py`
*(统计信息: 97 行, 3637 字符 [~0.52%])*
```python
"""
回测API Schema定义
"""

from datetime import datetime
from typing import Any, Dict, List, Optional, Union
from pydantic import BaseModel, Field, validator

class BacktestRequest(BaseModel):
    """回测请求模型"""
    strategy_id: int = Field(..., description="策略ID")
    symbol: str = Field(..., description="合约代码")
    exchange: str = Field(..., description="交易所")
    interval: str = Field(..., description="K线周期")
    start_date: str = Field(..., description="开始日期 (YYYY-MM-DD)")
    end_date: str = Field(..., description="结束日期 (YYYY-MM-DD)")
    initial_capital: float = Field(100000.0, description="初始资金")
    rate: float = Field(0.0, description="手续费率")
    slippage: float = Field(0.0, description="滑点")
    parameters: Optional[Dict[str, Any]] = Field(None, description="自定义策略参数")
    user_id: Optional[int] = Field(None, description="用户ID")

    @validator('start_date', 'end_date')
    def validate_date(cls, v):
        """验证日期格式"""
        try:
            datetime.strptime(v, "%Y-%m-%d")
            return v
        except ValueError:
            raise ValueError("日期格式必须为YYYY-MM-DD")

    class Config:
        json_schema_extra = {
            "example": {
                "strategy_id": 1,
                "symbol": "BTCUSDT",
                "exchange": "BINANCE",
                "interval": "1d",
                "start_date": "2022-01-01",
                "end_date": "2022-12-31",
                "initial_capital": 100000.0,
                "rate": 0.001,
                "slippage": 0.0,
                "parameters": {
                    "fast_window": 5,
                    "slow_window": 20
                },
                "user_id": 1
            }
        }

class BacktestResult(BaseModel):
    """回测结果模型"""
    id: int = Field(..., description="回测记录ID")
    strategy_id: int = Field(..., description="策略ID")
    symbol: str = Field(..., description="合约代码")
    exchange: str = Field(..., description="交易所")
    interval: str = Field(..., description="K线周期")
    start_date: str = Field(..., description="开始日期")
    end_date: str = Field(..., description="结束日期")
    initial_capital: float = Field(..., description="初始资金")
    final_capital: float = Field(..., description="最终资金")
    total_return: float = Field(..., description="总收益率")
    annual_return: float = Field(..., description="年化收益率")
    max_drawdown: float = Field(..., description="最大回撤")
    sharpe_ratio: float = Field(..., description="夏普比率")
    total_trades: int = Field(..., description="总交易次数")
    win_trades: int = Field(..., description="盈利交易次数")
    loss_trades: int = Field(..., description="亏损交易次数")
    win_rate: float = Field(..., description="胜率")
    trade_records: Optional[List[Dict[str, Any]]] = Field(None, description="交易记录")
    equity_curve: Optional[Dict[str, Any]] = Field(None, description="权益曲线")

    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "strategy_id": 1,
                "symbol": "BTCUSDT",
                "exchange": "BINANCE",
                "interval": "1d",
                "start_date": "2022-01-01",
                "end_date": "2022-12-31",
                "initial_capital": 100000.0,
                "final_capital": 120000.0,
                "total_return": 0.2,
                "annual_return": 0.3,
                "max_drawdown": 0.1,
                "sharpe_ratio": 1.5,
                "total_trades": 50,
                "win_trades": 30,
                "loss_trades": 20,
                "win_rate": 0.6,
                "trade_records": None,
                "equity_curve": None
            }
        }
```

### `/simpletrade/simpletrade/api/schemas/common.py`
*(统计信息: 65 行, 1805 字符 [~0.26%])*
```python
"""
通用API响应模型定义
"""

from typing import Any, Dict, Generic, List, Optional, TypeVar, Union
from pydantic import BaseModel, Field

# 用于泛型响应的类型变量
T = TypeVar('T')

class ApiResponse(BaseModel):
    """通用API响应模型"""
    success: bool = Field(..., description="操作是否成功")
    message: str = Field(..., description="响应消息")
    data: Optional[Any] = Field(None, description="响应数据")

    class Config:
        json_schema_extra = {
            "example": {
                "success": True,
                "message": "操作成功",
                "data": None
            }
        }

class PaginatedResponse(ApiResponse, Generic[T]):
    """分页响应模型"""
    data: Optional[List[T]] = Field(None, description="分页数据列表")
    total: int = Field(..., description="总记录数")
    page: int = Field(..., description="当前页码")
    size: int = Field(..., description="每页大小")
    pages: int = Field(..., description="总页数")

    class Config:
        json_schema_extra = {
            "example": {
                "success": True,
                "message": "查询成功",
                "data": [],
                "total": 100,
                "page": 1,
                "size": 10,
                "pages": 10
            }
        }

class ErrorResponse(BaseModel):
    """错误响应模型"""
    success: bool = Field(False, description="操作是否成功")
    message: str = Field(..., description="错误消息")
    code: str = Field(..., description="错误码")
    details: Optional[Dict[str, Any]] = Field(None, description="错误详情")

    class Config:
        json_schema_extra = {
            "example": {
                "success": False,
                "message": "操作失败",
                "code": "E1001",
                "details": {
                    "field": "username",
                    "reason": "已存在"
                }
            }
        }
```

### `/simpletrade/simpletrade/api/schemas/__init__.py`
*(统计信息: 5 行, 37 字符 [~0.01%])*
```python
"""
API Schema包

用于定义API请求和响应模型。
"""
```

### `/simpletrade/simpletrade/services/data_sync_service.py`
*(统计信息: 730 行, 31570 字符 [~4.52%])*
```python
"""
数据同步服务

负责根据配置，从不同的数据源同步历史数据到VnPy数据库。
"""

import logging
import os
import asyncio
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Any, Optional, Tuple, Set
import pandas as pd
from pandas.tseries.offsets import BDay

from simpletrade.config.settings import DATA_SYNC_TARGETS, DATA_SYNC_CONFIG, QLIB_DATA_PATH
from simpletrade.models.database import DataImportLog
from simpletrade.apps.st_datamanager.importers import ImporterFactory

from vnpy.trader.constant import Exchange, Interval
from vnpy.trader.database import BaseDatabase
from vnpy.trader.object import BarData

logger = logging.getLogger("simpletrade.services.data_sync_service")

class DataSyncService:
    """数据同步服务类

    负责根据配置从不同数据源同步历史数据到VnPy数据库。
    """

    def __init__(self, db_instance: BaseDatabase):
        """初始化数据同步服务

        Args:
            db_instance: 数据库实例
        """
        if not isinstance(db_instance, BaseDatabase):
            raise TypeError("DataSyncService requires a valid vnpy.trader.database.BaseDatabase instance.")

        self.db: BaseDatabase = db_instance
        logger.info(f"DataSyncService initialized with database instance: {type(self.db)}")
        self.targets = [target for target in DATA_SYNC_TARGETS if target.get("enabled", True)]
        logger.info(f"Found {len(self.targets)} enabled data sync targets")

    def _update_import_log(self, source: str, symbol: str, exchange: Exchange, interval: Interval,
                           success: bool, message: str, last_begin_date: Optional[datetime] = None,
                           last_end_date: Optional[datetime] = None):
        """更新数据导入日志

        Args:
            source: 数据源名称
            symbol: 品种代码
            exchange: 交易所
            interval: K线周期
            success: 是否导入成功
            message: 导入消息
            last_begin_date: 导入的数据开始日期
            last_end_date: 导入的数据结束日期
        """
        try:
            from sqlalchemy.orm import Session
            from sqlalchemy import create_engine
            from simpletrade.config.settings import DB_CONFIG

            # 创建数据库连接
            db_url = f"mysql+pymysql://{DB_CONFIG['DB_USER']}:{DB_CONFIG['DB_PASSWORD']}@{DB_CONFIG['DB_HOST']}:{DB_CONFIG['DB_PORT']}/{DB_CONFIG['DB_NAME']}"
            engine = create_engine(db_url)

            with Session(engine) as session:
                # 查找现有记录
                log_entry = session.query(DataImportLog).filter_by(
                    source=source,
                    symbol=symbol,
                    exchange=exchange.value,
                    interval=interval.value
                ).first()

                # 更新或创建记录
                current_time = datetime.now()
                if log_entry:
                    log_entry.last_attempt_time = current_time
                    log_entry.status = 'success' if success else 'failed'
                    log_entry.message = message
                    if last_begin_date and success:
                        log_entry.last_begin_date = last_begin_date
                    if last_end_date and success:
                        log_entry.last_end_date = last_end_date
                else:
                    log_entry = DataImportLog(
                        source=source,
                        symbol=symbol,
                        exchange=exchange.value,
                        interval=interval.value,
                        last_attempt_time=current_time,
                        status='success' if success else 'failed',
                        message=message,
                        last_begin_date=last_begin_date if success else None,
                        last_end_date=last_end_date if success else None
                    )
                    session.add(log_entry)

                session.commit()
                logger.info(f"Updated import log for {symbol} from {source}. Status: {'success' if success else 'failed'}")
        except Exception as e:
            logger.error(f"Error updating import log: {e}", exc_info=True)

    def _get_last_import_date(self, source: str, symbol: str, exchange: str, interval: str) -> Optional[datetime]:
        """获取上次导入的结束日期

        Args:
            source: 数据源名称
            symbol: 品种代码
            exchange: 交易所
            interval: K线周期

        Returns:
            上次导入的结束日期，如果没有记录则返回None
        """
        try:
            from sqlalchemy.orm import Session
            from sqlalchemy import create_engine
            from simpletrade.config.settings import DB_CONFIG

            # 创建数据库连接
            db_url = f"mysql+pymysql://{DB_CONFIG['DB_USER']}:{DB_CONFIG['DB_PASSWORD']}@{DB_CONFIG['DB_HOST']}:{DB_CONFIG['DB_PORT']}/{DB_CONFIG['DB_NAME']}"
            engine = create_engine(db_url)

            with Session(engine) as session:
                # 查找现有记录
                log_entry = session.query(DataImportLog).filter_by(
                    source=source,
                    symbol=symbol,
                    exchange=exchange,
                    interval=interval
                ).first()

                if log_entry and log_entry.last_end_date:
                    logger.info(f"Found previous import record for {symbol} ({source}): last end date {log_entry.last_end_date}")
                    return log_entry.last_end_date

                logger.info(f"No previous import record found for {symbol} ({source})")
                return None

        except Exception as e:
            logger.error(f"Error retrieving last import date: {e}", exc_info=True)
            return None

    def _get_last_begin_date(self, source: str, symbol: str, exchange: str, interval: str) -> Optional[datetime]:
        """获取上次导入的开始日期

        Args:
            source: 数据源名称
            symbol: 品种代码
            exchange: 交易所
            interval: K线周期

        Returns:
            上次导入的开始日期，如果没有记录则返回None
        """
        try:
            from sqlalchemy.orm import Session
            from sqlalchemy import create_engine
            from simpletrade.config.settings import DB_CONFIG

            # 创建数据库连接
            db_url = f"mysql+pymysql://{DB_CONFIG['DB_USER']}:{DB_CONFIG['DB_PASSWORD']}@{DB_CONFIG['DB_HOST']}:{DB_CONFIG['DB_PORT']}/{DB_CONFIG['DB_NAME']}"
            engine = create_engine(db_url)

            with Session(engine) as session:
                # 查找现有记录
                log_entry = session.query(DataImportLog).filter_by(
                    source=source,
                    symbol=symbol,
                    exchange=exchange,
                    interval=interval
                ).first()

                if log_entry and log_entry.last_begin_date:
                    logger.info(f"Found previous import record for {symbol} ({source}): last begin date {log_entry.last_begin_date}")
                    return log_entry.last_begin_date

                logger.info(f"No previous import record found for {symbol} ({source})")
                return None

        except Exception as e:
            logger.error(f"Error retrieving last begin date: {e}", exc_info=True)
            return None

    def _get_db_date_range(self, symbol: str, exchange: Exchange, interval: Interval) -> Tuple[Optional[datetime], Optional[datetime]]:
        """从数据库获取K线数据的日期范围

        Args:
            symbol: 品种代码
            exchange: 交易所
            interval: K线周期

        Returns:
            (最早日期, 最晚日期) 元组，如果没有数据则返回 (None, None)
        """
        if not self.db:
            logger.warning("Cannot check database for bar date range: database connection not available")
            return None, None

        try:
            # 使用数据库查询函数获取日期范围
            bars = self.db.load_bar_data(
                symbol=symbol,
                exchange=exchange,
                interval=interval,
                start=datetime(1970, 1, 1),  # 从最早日期开始
                end=datetime.now(timezone.utc)  # 到当前日期
            )

            if not bars:
                logger.info(f"No existing data in database for {symbol}")
                return None, None

            earliest_date = min(bar.datetime for bar in bars)
            latest_date = max(bar.datetime for bar in bars)
            logger.info(f"Data range in database for {symbol}: {earliest_date} to {latest_date}")
            return earliest_date, latest_date

        except Exception as e:
            logger.error(f"Error querying database for bar date range: {e}", exc_info=True)
            return None, None

    def _get_db_existing_dates(self, symbol: str, exchange: Exchange, interval: Interval) -> Set[datetime.date]:
        """获取数据库中指定品种已有数据的日期集合

        Args:
            symbol: 品种代码
            exchange: 交易所
            interval: K线周期

        Returns:
            已有数据的日期集合（只包含日期部分，不含时间）
        """
        if not self.db:
            logger.warning("Cannot check database for existing dates: database connection not available")
            return set()

        try:
            # 使用数据库查询函数获取现有数据
            bars = self.db.load_bar_data(
                symbol=symbol,
                exchange=exchange,
                interval=interval,
                start=datetime(1970, 1, 1),  # 从最早日期开始
                end=datetime.now(timezone.utc)  # 到当前日期
            )

            if not bars:
                logger.info(f"No existing data in database for {symbol}")
                return set()

            # 获取所有日期（只保留日期部分，不含时间）
            existing_dates = {bar.datetime.date() for bar in bars}
            logger.info(f"Found {len(existing_dates)} existing dates in database for {symbol}")
            return existing_dates

        except Exception as e:
            logger.error(f"Error querying database for existing dates: {e}", exc_info=True)
            return set()

    def _get_trading_dates(self, start_date: datetime, end_date: datetime, exchange: Exchange) -> List[datetime.date]:
        """根据交易所获取指定日期范围内的所有交易日

        Args:
            start_date: 开始日期
            end_date: 结束日期
            exchange: 交易所

        Returns:
            交易日列表（只包含日期部分，不含时间）
        """
        try:
            # 1. 基本方法：使用pandas生成交易日历（不含周末）
            # 使用 business days 作为基础，但不考虑节假日
            date_range = pd.date_range(start=start_date.date(), end=end_date.date(), freq=BDay())

            # 2. 未来可以考虑更复杂的方法：
            # a) 根据交易所区分不同市场的交易日历（包括节假日）
            # b) 使用专门的交易日历库或API
            # c) 维护自己的交易日历数据库

            # 转换为日期列表
            trading_dates = [d.date() for d in date_range]

            logger.info(f"Generated {len(trading_dates)} trading dates from {start_date.date()} to {end_date.date()}")
            return trading_dates

        except Exception as e:
            logger.error(f"Error generating trading dates: {e}", exc_info=True)
            # 如果生成失败，返回从起始日期到结束日期的全部日期（包括周末和节假日）
            all_dates = [(start_date + timedelta(days=i)).date() for i in range((end_date - start_date).days + 1)]
            logger.warning(f"Falling back to all calendar dates: {len(all_dates)} dates")
            return all_dates

    def _group_dates_into_ranges(self, dates: List[datetime.date], max_gap: int = 5) -> List[Tuple[datetime, datetime]]:
        """将日期列表分组成连续区间

        Args:
            dates: 日期列表（已排序）
            max_gap: 允许的最大日期间隔，超过此值会分为不同区间

        Returns:
            日期区间列表，每个元素为 (开始日期, 结束日期) 元组
        """
        if not dates:
            return []

        # 对日期进行排序
        sorted_dates = sorted(dates)

        # 初始化区间列表和当前区间
        ranges = []
        current_range_start = sorted_dates[0]
        current_range_end = sorted_dates[0]

        # 遍历日期列表，将连续的日期合并为区间
        for i in range(1, len(sorted_dates)):
            date = sorted_dates[i]
            prev_date = sorted_dates[i-1]

            # 计算与前一天的差距（天数）
            gap = (date - prev_date).days

            # 如果差距小于等于允许的最大间隔，扩展当前区间
            if gap <= max_gap:
                current_range_end = date
            # 否则，结束当前区间并开始新区间
            else:
                # 将当前区间转换为datetime对象添加到结果中
                ranges.append((
                    datetime.combine(current_range_start, datetime.min.time()),
                    datetime.combine(current_range_end, datetime.min.time())
                ))
                # 开始新区间
                current_range_start = date
                current_range_end = date

        # 添加最后一个区间
        ranges.append((
            datetime.combine(current_range_start, datetime.min.time()),
            datetime.combine(current_range_end, datetime.min.time())
        ))

        logger.info(f"Grouped {len(dates)} dates into {len(ranges)} continuous ranges")
        for i, (start, end) in enumerate(ranges):
            logger.debug(f"Range {i+1}: {start.date()} to {end.date()}")

        return ranges

    async def sync_all_targets(self):
        """同步所有配置的目标数据"""
        if not self.targets:
            logger.warning("No data synchronization targets configured or enabled.")
            return

        if not self.db:
            logger.error("Database instance not available in sync_all_targets.")
            return

        tasks = [self.sync_target(target) for target in self.targets]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # 记录每个任务的结果
        for i, result in enumerate(results):
            target = self.targets[i]
            if isinstance(result, Exception):
                logger.error(f"Error syncing target {target}: {result}", exc_info=result)

        logger.info("Finished sync_all_targets run.")

    async def sync_target(self, target: dict):
        """同步单个目标数据

        Args:
            target: 目标配置字典
        """
        # 提取源和基本符号信息（用于日志记录）
        source = target.get("source")
        symbol = target.get("symbol")

        if not all([source, symbol]):
            logger.warning(f"Skipping invalid target (missing source or symbol): {target}")
            return

        try:
            # 获取交易所和周期（仅用于日志记录）
            exchange_str = target.get("exchange", "")
            interval_str = target.get("interval", "")

            try:
                exchange = Exchange(exchange_str)
                interval = Interval(interval_str)
            except ValueError as e:
                logger.error(f"Invalid exchange or interval in target {target}: {e}")
                return

            logger.info(f"Starting data import for {symbol} from {source}...")

            # 使用工厂创建导入器
            importer = ImporterFactory.create_importer(source)
            if not importer:
                message = f"Unsupported data source: {source}"
                logger.warning(message)
                self._update_import_log(source, symbol, exchange, interval, False, message)
                return

            # 让导入器从目标配置中提取并验证所需参数
            try:
                params = importer.extract_and_validate_params(target)

                # 从参数中获取基本信息
                symbol = params.pop("symbol")
                exchange_name = params.pop("exchange")
                interval_name = params.pop("interval")
                start_date_str = params.pop("start_date", None)
                end_date_str = params.pop("end_date", None)

                # 转换类型
                exchange = Exchange(exchange_name)
                interval = Interval(interval_name)

                # 转换日期
                configured_start_dt = datetime.strptime(start_date_str, '%Y-%m-%d') if start_date_str else None
                end_dt = datetime.strptime(end_date_str, '%Y-%m-%d') if end_date_str else datetime.now()

                # 如果没有配置开始日期，尝试从导入日志获取
                if not configured_start_dt:
                    last_end_date = self._get_last_import_date(
                        source=source,
                        symbol=symbol,
                        exchange=exchange_name,
                        interval=interval_name
                    )

                    if last_end_date:
                        # 有导入记录，设置开始日期为最后导入日期的下一天
                        configured_start_dt = last_end_date + timedelta(days=1)
                        logger.info(f"Using start date based on import log: {configured_start_dt}")
                    else:
                        # 默认使用较早的开始日期
                        configured_start_dt = datetime(2010, 1, 1)
                        logger.info(f"No start date configured or found in logs. Using default: {configured_start_dt}")

                # 精确到日的智能数据导入
                if interval == Interval.DAILY and self.db:
                    # 1. 获取数据库中已有的日期
                    existing_dates = self._get_db_existing_dates(symbol, exchange, interval)

                    # 2. 获取应该有的交易日期
                    all_trading_dates = self._get_trading_dates(configured_start_dt, end_dt, exchange)

                    # 3. 计算缺失的日期
                    missing_dates = [d for d in all_trading_dates if d not in existing_dates]

                    if not missing_dates:
                        logger.info(f"No missing dates found for {symbol} between {configured_start_dt.date()} and {end_dt.date()}")
                        self._update_import_log(
                            source=source,
                            symbol=symbol,
                            exchange=exchange,
                            interval=interval,
                            success=True,
                            message=f"No missing dates to import",
                            last_begin_date=configured_start_dt,
                            last_end_date=end_dt
                        )
                        return

                    logger.info(f"Found {len(missing_dates)} missing dates for {symbol}")

                    # 4. 将缺失日期分组为连续区间
                    missing_ranges = self._group_dates_into_ranges(missing_dates)

                    # 5. 针对每个缺失区间导入数据
                    all_bars = []
                    for start_range, end_range in missing_ranges:
                        logger.info(f"Importing data for missing range: {start_range.date()} to {end_range.date()}")
                        success, message, bars = importer.import_data(
                            symbol=symbol,
                            exchange=exchange,
                            interval=interval,
                            start_date=start_range,
                            end_date=end_range,
                            **params  # 传递其他提取的参数
                        )

                        if success and bars:
                            # 筛选只包含缺失日期的数据
                            filtered_bars = []
                            for bar in bars:
                                if bar.datetime.date() in missing_dates:
                                    filtered_bars.append(bar)

                            logger.info(f"Retrieved {len(bars)} bars, {len(filtered_bars)} are for missing dates")
                            all_bars.extend(filtered_bars)
                        else:
                            logger.warning(f"Failed to import data for range {start_range.date()} to {end_range.date()}: {message}")

                    # 保存所有导入的数据
                    if all_bars:
                        logger.info(f"Saving {len(all_bars)} bars for missing dates from {source} importer to database...")
                        count = self.db.save_bar_data(all_bars)
                        logger.info(f"Saved {count} bars for {symbol} from {source} importer.")

                        # 找出最新日期（改为记录整个范围）
                        if all_bars:
                            earliest_date = min(bar.datetime for bar in all_bars)
                            latest_date = max(bar.datetime for bar in all_bars)
                            logger.info(f"Imported data range: {earliest_date} to {latest_date}")
                        else:
                            earliest_date = None
                            latest_date = None

                        # 更新消息以反映保存结果
                        message = f"Successfully imported and saved {count} bars for missing dates from {source} data."

                        # 导入成功，记录到导入日志
                        self._update_import_log(source, symbol, exchange, interval, True, message, earliest_date, latest_date)
                    else:
                        logger.warning(f"No data was imported for missing dates of {symbol}.")
                        self._update_import_log(source, symbol, exchange, interval, True, "No data available for missing dates", None, None)

                    return

                # 如果不是日线数据或没有数据库连接，使用区间导入方式
                # 获取数据库中已有数据的日期范围
                db_earliest_date, db_latest_date = self._get_db_date_range(symbol, exchange, interval)

                if db_earliest_date and db_latest_date:
                    # 数据库中已有数据，判断是否需要补充历史数据和更新新数据

                    # 计算需要导入的日期区间（可能有多个）
                    date_ranges = []

                    # 1. 检查是否需要补充历史数据（配置的开始日期早于数据库中最早的记录）
                    if configured_start_dt < db_earliest_date:
                        # 需要补充历史数据
                        history_end = db_earliest_date - timedelta(days=1)  # 避免重叠
                        logger.info(f"Need to import historical data from {configured_start_dt} to {history_end}")
                        date_ranges.append((configured_start_dt, history_end))

                    # 2. 检查是否需要更新最新数据（数据库最新日期之后有新数据）
                    if db_latest_date < end_dt:
                        # 需要更新最新数据
                        latest_start = db_latest_date + timedelta(days=1)  # 避免重叠
                        logger.info(f"Need to import new data from {latest_start} to {end_dt}")
                        date_ranges.append((latest_start, end_dt))

                    # 如果没有需要导入的区间，跳过导入
                    if not date_ranges:
                        logger.info(f"Skipping import: database already has complete data from {db_earliest_date} to {db_latest_date}")
                        self._update_import_log(
                            source=source,
                            symbol=symbol,
                            exchange=exchange,
                            interval=interval,
                            success=True,
                            message=f"Skipped import: database already has complete data",
                            last_begin_date=db_earliest_date,
                            last_end_date=db_latest_date
                        )
                        return

                    # 处理各个需要导入的日期区间
                    all_bars = []
                    for start_range, end_range in date_ranges:
                        # 导入数据
                        logger.info(f"Importing data for range: {start_range} to {end_range}")
                        success, message, bars = importer.import_data(
                            symbol=symbol,
                            exchange=exchange,
                            interval=interval,
                            start_date=start_range,
                            end_date=end_range,
                            **params  # 传递其他提取的参数
                        )

                        if success and bars:
                            all_bars.extend(bars)
                            logger.info(f"Successfully imported {len(bars)} bars for range {start_range} to {end_range}")
                        else:
                            logger.warning(f"Failed to import data for range {start_range} to {end_range}: {message}")

                    # 保存所有导入的数据
                    if all_bars:
                        logger.info(f"Saving {len(all_bars)} bars from {source} importer to database...")
                        count = self.db.save_bar_data(all_bars)
                        logger.info(f"Saved {count} bars for {symbol} from {source} importer.")

                        # 找出日期范围（改为记录整个范围）
                        if all_bars:
                            earliest_date = min(bar.datetime for bar in all_bars)
                            latest_date = max(bar.datetime for bar in all_bars)
                            logger.info(f"Imported data range: {earliest_date} to {latest_date}")
                        else:
                            earliest_date = db_earliest_date
                            latest_date = db_latest_date

                        # 更新消息以反映保存结果
                        message = f"Successfully imported and saved {count} bars from {source} data."

                        # 导入成功，记录到导入日志
                        self._update_import_log(source, symbol, exchange, interval, True, message, earliest_date, latest_date)
                    else:
                        logger.warning(f"No new data was imported for {symbol}.")
                        self._update_import_log(source, symbol, exchange, interval, True, "No new data available", db_earliest_date, db_latest_date)

                    return

                # 如果数据库中没有数据，使用配置的日期范围导入所有数据
                logger.info(f"No existing data found. Importing full range from {configured_start_dt} to {end_dt}")
                success, message, bars = importer.import_data(
                    symbol=symbol,
                    exchange=exchange,
                    interval=interval,
                    start_date=configured_start_dt,
                    end_date=end_dt,
                    **params  # 传递其他提取的参数
                )

                logger.info(f"Importer result for {symbol}: Success={success}, Msg='{message}', Bars obtained: {len(bars)}")

                # 处理数据保存
                if success and bars:
                    if not self.db:
                        message += " (Error: Cannot save bars, database connection not available.)"
                        logger.error(message)
                        self._update_import_log(source, symbol, exchange, interval, False, message, None, None)
                    else:
                        logger.info(f"Saving {len(bars)} bars from {source} importer to database...")
                        count = self.db.save_bar_data(bars)
                        logger.info(f"Saved {count} bars for {symbol} from {source} importer.")

                        # 找出日期范围
                        earliest_date = None
                        latest_date = None
                        if bars:
                            earliest_date = min(bar.datetime for bar in bars)
                            latest_date = max(bar.datetime for bar in bars)
                            logger.info(f"Imported data range: {earliest_date} to {latest_date}")

                        # 更新消息以反映保存结果
                        message = f"Successfully imported and saved {count} bars from {source} data."

                        # 导入成功，记录到导入日志
                        self._update_import_log(source, symbol, exchange, interval, True, message, earliest_date, latest_date)
                elif success and not bars:
                    logger.warning(f"Import reported success but returned no bars for {symbol} (Message: '{message}'). Nothing to save.")
                    # 记录到导入日志（成功但无数据）
                    self._update_import_log(source, symbol, exchange, interval, True, message, None, None)
                elif not success:
                    logger.error(f"Import failed for {symbol} (Message: '{message}'). Nothing saved.")
                    # 记录到导入日志（失败）
                    self._update_import_log(source, symbol, exchange, interval, False, message, None, None)

            except ValueError as param_err:
                message = f"Parameter validation failed: {param_err}"
                logger.error(message)
                self._update_import_log(source, symbol, exchange, interval, False, message, None, None)
                return

        except Exception as e:
            error_message = f"Error during sync_target execution for {target}: {e}"
            logger.error(error_message, exc_info=True)

            # 尝试从异常中恢复交易所和周期信息（可能未初始化）
            try:
                exchange = Exchange(target.get("exchange", ""))
                interval = Interval(target.get("interval", ""))
            except:
                # 最差情况下使用字符串值
                exchange = target.get("exchange", "UNKNOWN")
                interval = target.get("interval", "UNKNOWN")

            # 记录异常到导入日志
            self._update_import_log(source, symbol, exchange, interval, False, error_message, None, None)
            # Re-raise the exception so asyncio.gather logs it properly
            raise e


async def run_initial_data_sync(db_instance: BaseDatabase):
    """初始化数据同步服务并运行同步

    Args:
        db_instance: 数据库实例
    """
    logger.info("Starting initial data sync process...")
    try:
        data_sync_service = DataSyncService(db_instance=db_instance)

        logger.info("DataSyncService initialized. Calling sync_all_targets...")
        await data_sync_service.sync_all_targets()
        logger.info("Initial data sync process finished.")

    except Exception as e:
        logger.error(f"Error during initial data sync execution: {e}", exc_info=True)


async def run_periodic_data_sync(db_instance: BaseDatabase):
    """周期性运行数据同步

    Args:
        db_instance: 数据库实例
    """
    logger.info("Starting periodic data sync service...")

    # 从配置中获取同步间隔时间（秒）
    sync_interval = DATA_SYNC_CONFIG.get("SYNC_INTERVAL", 86400)  # 默认每天同步一次

    try:
        data_sync_service = DataSyncService(db_instance=db_instance)

        # 无限循环，定期执行同步
        while True:
            try:
                logger.info(f"Running scheduled data synchronization...")
                await data_sync_service.sync_all_targets()
                logger.info(f"Scheduled data synchronization completed. Next sync in {sync_interval} seconds.")
            except Exception as sync_error:
                logger.error(f"Error during scheduled data sync: {sync_error}", exc_info=True)

            # 等待下一次同步
            await asyncio.sleep(sync_interval)

    except Exception as e:
        logger.error(f"Fatal error in periodic data sync service: {e}", exc_info=True)
```

### `/simpletrade/simpletrade/services/strategy_service.py`
*(统计信息: 496 行, 16926 字符 [~2.42%])*
```python
"""
策略管理服务

提供策略的加载、初始化、启动、停止等功能。
"""

import logging
from typing import Dict, List, Optional, Any, Union
from sqlalchemy.orm import Session, joinedload
from pathlib import Path

from simpletrade.core.engine import STMainEngine
from simpletrade.api.deps import get_db
from simpletrade.models.database import Strategy, UserStrategy
from simpletrade.strategies import get_strategy_class, get_strategy_class_names, get_strategy_class_details
from vnpy_ctastrategy.template import CtaTemplate

logger = logging.getLogger("simpletrade.services.strategy_service")

class StrategyService:
    """策略管理服务"""

    def __init__(self, main_engine: STMainEngine):
        """
        初始化

        参数:
            main_engine (STMainEngine): 主引擎实例
        """
        self.main_engine = main_engine
        self.cta_engine = main_engine.get_cta_engine()

    def get_strategy_types(self, db: Session) -> List[str]:
        """
        获取数据库中所有活跃策略的不重复类型列表

        参数:
            db (Session): 数据库会话
        返回:
            List[str]: 策略类型列表
        """
        # 查询数据库获取不重复的 type
        query = db.query(Strategy.type).filter(Strategy.is_active == True).distinct()
        # SQLAlchemy 返回的是元组列表，例如 [('DoubleMaStrategy',), ('AtrRsiStrategy',)]
        # 需要将其转换为字符串列表
        types = [item[0] for item in query.all() if item[0]] # 确保类型不是 None 或空字符串
        return types

    def get_strategy_details(self) -> List[Dict[str, Any]]:
        """
        获取所有策略类的详细信息

        返回:
            List[Dict[str, Any]]: 策略类详细信息列表
        """
        return get_strategy_class_details()

    def get_strategies(self, db: Session, type: Optional[str] = None, category: Optional[str] = None) -> List[Strategy]:
        """
        获取所有策略记录 (使用传入的 db session)

        参数:
            db (Session): 数据库会话
            type (str, optional): 策略类型
            category (str, optional): 策略分类

        返回:
            List[Strategy]: 策略记录列表
        """
        query = db.query(Strategy).filter(Strategy.is_active == True)

        # 应用过滤条件
        if type:
            query = query.filter(Strategy.type == type)
        if category:
            query = query.filter(Strategy.category == category)

        return query.all()

    def get_strategy(self, db: Session, strategy_id: int) -> Optional[Strategy]:
        """
        获取策略记录 (使用传入的 db session)

        参数:
            db (Session): 数据库会话
            strategy_id (int): 策略ID

        返回:
            Strategy: 策略记录，如果不存在则返回None
        """
        strategy = db.query(Strategy).filter(Strategy.id == strategy_id, Strategy.is_active == True).first()
        if strategy:
            logger.info(f"StrategyService.get_strategy: Found strategy ID {strategy_id}. Name: {strategy.name}, Identifier from DB object: {getattr(strategy, 'identifier', '[identifier attribute not found]')}")
        else:
            logger.info(f"StrategyService.get_strategy: Strategy ID {strategy_id} not found in DB.")
        return strategy

    def load_strategy_code(self, strategy: Strategy) -> Optional[str]:
        """
        从文件加载策略代码

        参数:
            strategy (Strategy): 策略记录

        返回:
            Optional[str]: 策略代码，如果无法加载则返回None
        """
        if not strategy:
            return None

        strategy_code = None
        file_path_str = ""

        if hasattr(strategy, 'identifier') and strategy.identifier:
            try:
                # 找到策略目录
                current_file_path = Path(__file__).resolve()  # 服务文件的绝对路径
                # simpletrade/services/strategy_service.py -> simpletrade/services/ -> simpletrade/
                simpletrade_root = current_file_path.parent.parent
                strategies_dir = simpletrade_root / "strategies"

                file_path = strategies_dir / f"{strategy.identifier}.py"
                file_path_str = str(file_path)

                if file_path.is_file():
                    strategy_code = file_path.read_text(encoding='utf-8')
                    logger.info(f"成功加载策略代码文件: {file_path_str}")
                else:
                    logger.warning(f"策略代码文件未找到: {file_path_str}")
            except FileNotFoundError:
                logger.warning(f"策略代码文件未找到 (FileNotFoundError): {file_path_str}")
            except Exception as e:
                logger.error(f"读取策略代码文件失败 ({file_path_str}): {e}")
        else:
            logger.warning(f"策略 {strategy.id} ({strategy.name}) 没有有效的 identifier 字段，无法加载代码。")

        return strategy_code

    def get_user_strategies(self, db: Session, user_id: int) -> List[Dict[str, Any]]:
        """
        获取用户策略记录列表，并包含实时状态和创建时间

        参数:
            db (Session): 数据库会话
            user_id (int): 用户ID

        返回:
            List[Dict[str, Any]]: 包含策略信息、状态和创建时间字典的列表
        """
        user_strategies_orm = db.query(UserStrategy).filter(
            UserStrategy.user_id == user_id,
            UserStrategy.is_active == True
        ).options(joinedload(UserStrategy.strategy)).all() # 预加载关联的 Strategy

        result_list = []
        for us in user_strategies_orm:
            strategy_template = us.strategy # 从预加载中获取关联的 Strategy
            if not strategy_template:
                # 如果关联的 Strategy 被删除了或不存在，跳过这个用户策略
                logger.warning(f"UserStrategy {us.id} ({us.name}) references a non-existent Strategy {us.strategy_id}. Skipping.")
                continue

            # 尝试从 cta_engine 获取策略实例和状态
            strategy_instance = self.cta_engine.strategies.get(us.name)

            status = "已停止" # 默认状态
            if strategy_instance:
                if strategy_instance.trading:
                    status = "运行中"
                elif strategy_instance.inited:
                    status = "已初始化"
                # else: status remains "已停止" (or could be '未初始化' if needed)
            else:
                 # 如果 cta_engine 中没有实例，也认为是停止状态
                 status = "未加载"

            strategy_dict = {
                "id": us.id,
                "name": us.name,
                "strategy_id": strategy_template.id,
                "strategy_name": strategy_template.name,
                "category": strategy_template.category,
                "type": strategy_template.type,
                # 假设 UserStrategy 模型有 created_at 字段
                "createTime": us.created_at.strftime("%Y-%m-%d %H:%M:%S") if us.created_at else None,
                "status": status, # 添加状态字段
                "parameters": us.parameters,
                # 可以选择性添加其他需要的字段
                # "complexity": strategy_template.complexity,
                # "resource_requirement": strategy_template.resource_requirement,
            }
            result_list.append(strategy_dict)

        return result_list

    def get_user_strategy(self, db: Session, user_strategy_id: int) -> Optional[UserStrategy]:
        """
        获取用户策略记录 (使用传入的 db session)

        参数:
            db (Session): 数据库会话
            user_strategy_id (int): 用户策略ID

        返回:
            UserStrategy: 用户策略记录，如果不存在则返回None
        """
        return db.query(UserStrategy).filter(
            UserStrategy.id == user_strategy_id,
            UserStrategy.is_active == True
        ).first()

    def create_strategy(self, name: str, description: str, type: str,
                       category: str, parameters: Dict[str, Any]) -> Optional[Strategy]:
        """
        创建策略

        参数:
            name (str): 策略名称
            description (str): 策略描述
            type (str): 策略类型
            category (str): 策略分类
            parameters (Dict[str, Any]): 策略参数

        返回:
            Strategy: 创建的策略记录，如果失败则返回None
        """
        # 验证策略类型是否存在
        if type not in get_strategy_class_names():
            logger.error(f"Strategy type {type} not found")
            return None

        try:
            db = next(get_db())  # 获取数据库会话
            try:
                strategy = Strategy(
                    name=name,
                    description=description,
                    type=type,
                    category=category,
                    parameters=parameters,
                    is_active=True
                )
                db.add(strategy)
                db.commit()
                db.refresh(strategy)
                logger.info(f"Strategy {name} created successfully")
                return strategy
            finally:
                db.close()  # 确保会话被关闭
        except Exception as e:
            logger.error(f"Failed to create strategy: {e}")
            return None

    def create_user_strategy(self, user_id: int, strategy_id: int, name: str,
                           parameters: Dict[str, Any]) -> Optional[UserStrategy]:
        """
        创建用户策略

        参数:
            user_id (int): 用户ID
            strategy_id (int): 策略ID
            name (str): 策略名称
            parameters (Dict[str, Any]): 策略参数

        返回:
            UserStrategy: 创建的用户策略记录，如果失败则返回None
        """
        try:
            db = next(get_db())  # 获取数据库会话
            try:
                # 检查策略是否存在
                strategy = db.query(Strategy).filter(
                    Strategy.id == strategy_id,
                    Strategy.is_active == True
                ).first()

                if not strategy:
                    logger.error(f"Strategy {strategy_id} not found")
                    return None

                # 创建用户策略
                user_strategy = UserStrategy(
                    user_id=user_id,
                    strategy_id=strategy_id,
                    name=name,
                    parameters=parameters,
                    is_active=True
                )
                db.add(user_strategy)
                db.commit()
                db.refresh(user_strategy)
                logger.info(f"User strategy {name} created successfully")
                return user_strategy
            finally:
                db.close()  # 确保会话被关闭
        except Exception as e:
            logger.error(f"Failed to create user strategy: {e}")
            return None

    def update_user_strategy(self, user_strategy_id: int, name: str,
                           parameters: Dict[str, Any]) -> Optional[UserStrategy]:
        """
        更新用户策略

        参数:
            user_strategy_id (int): 用户策略ID
            name (str): 策略名称
            parameters (Dict[str, Any]): 策略参数

        返回:
            UserStrategy: 更新后的用户策略记录，如果失败则返回None
        """
        try:
            db = next(get_db())  # 获取数据库会话
            try:
                user_strategy = db.query(UserStrategy).filter(
                    UserStrategy.id == user_strategy_id,
                    UserStrategy.is_active == True
                ).first()

                if not user_strategy:
                    logger.error(f"User strategy {user_strategy_id} not found")
                    return None

                user_strategy.name = name
                user_strategy.parameters = parameters
                db.commit()
                db.refresh(user_strategy)
                logger.info(f"User strategy {name} updated successfully")
                return user_strategy
            finally:
                db.close()  # 确保会话被关闭
        except Exception as e:
            logger.error(f"Failed to update user strategy: {e}")
            return None

    def delete_user_strategy(self, user_strategy_id: int) -> bool:
        """
        删除用户策略

        参数:
            user_strategy_id (int): 用户策略ID

        返回:
            bool: 是否删除成功
        """
        try:
            db = next(get_db())  # 获取数据库会话
            try:
                user_strategy = db.query(UserStrategy).filter(
                    UserStrategy.id == user_strategy_id,
                    UserStrategy.is_active == True
                ).first()

                if not user_strategy:
                    logger.error(f"User strategy {user_strategy_id} not found")
                    return False

                user_strategy.is_active = False
                db.commit()
                logger.info(f"User strategy {user_strategy_id} deleted successfully")
                return True
            finally:
                db.close()  # 确保会话被关闭
        except Exception as e:
            logger.error(f"Failed to delete user strategy: {e}")
            return False

    def load_strategy(self, strategy_id: int) -> Dict[str, Any]:
        """
        加载策略配置

        参数:
            strategy_id (int): 策略ID

        返回:
            Dict[str, Any]: 策略配置，包含策略名称、类型和参数
        """
        strategy = self.get_strategy(strategy_id)
        if not strategy:
            logger.error(f"Strategy {strategy_id} not found")
            return {}

        # 获取策略类
        strategy_class = get_strategy_class(strategy.type)
        if not strategy_class:
            logger.error(f"Strategy class {strategy.type} not found")
            return {}

        # 构建策略配置
        strategy_config = {
            "strategy_name": strategy.name,
            "strategy_class": strategy.type,
            "setting": strategy.parameters
        }

        return strategy_config

    def load_user_strategy(self, user_strategy_id: int) -> Dict[str, Any]:
        """
        加载用户策略配置

        参数:
            user_strategy_id (int): 用户策略ID

        返回:
            Dict[str, Any]: 策略配置，包含策略名称、Python类对象和参数
        """
        # 使用 with get_db() 来确保会话关闭
        db = next(get_db()) # 获取 db 会话
        try:
            user_strategy = db.query(UserStrategy).filter(
                UserStrategy.id == user_strategy_id,
                UserStrategy.is_active == True
            ).options(joinedload(UserStrategy.strategy)).first() # 预加载 Strategy

            if not user_strategy:
                logger.error(f"User strategy {user_strategy_id} not found")
                return {}

            strategy = user_strategy.strategy # 使用预加载的 Strategy
            if not strategy:
                logger.error(f"Strategy {user_strategy.strategy_id} associated with user strategy {user_strategy_id} not found")
                return {}

            # --- 修正获取策略类的逻辑 ---
            # 检查 strategy 对象是否有 identifier 属性
            if not hasattr(strategy, 'identifier') or not strategy.identifier:
                logger.error(f"Strategy {strategy.id} ({strategy.name}) is missing a valid identifier.")
                return {}

            # 使用 identifier 获取策略类
            strategy_class_object = get_strategy_class(strategy.identifier)
            if not strategy_class_object:
                logger.error(f"Strategy class for identifier '{strategy.identifier}' not found")
                return {}
            # --------------------------

            # 构建策略配置
            strategy_config = {
                "strategy_name": user_strategy.name,
                # "strategy_class": strategy.type, # <-- 不再使用 type
                "strategy_class": strategy_class_object, # <-- 使用获取到的类对象
                "setting": user_strategy.parameters
            }

            return strategy_config
        finally:
            db.close() # 确保关闭会话

    def start_strategy(self, user_strategy_id: int) -> bool:
        """
        启动策略

        参数:
            user_strategy_id (int): 用户策略ID

        返回:
            bool: 是否启动成功
        """
        strategy_config = self.load_user_strategy(user_strategy_id)
        if not strategy_config:
            return False

        try:
            # 启动策略
            self.cta_engine.start_strategy(strategy_config["strategy_name"])
            logger.info(f"Strategy {strategy_config['strategy_name']} started successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to start strategy: {e}")
            return False

    def stop_strategy(self, user_strategy_id: int) -> bool:
        """
        停止策略

        参数:
            user_strategy_id (int): 用户策略ID

        返回:
            bool: 是否停止成功
        """
        strategy_config = self.load_user_strategy(user_strategy_id)
        if not strategy_config:
            return False

        try:
            # 停止策略
            self.cta_engine.stop_strategy(strategy_config["strategy_name"])
            logger.info(f"Strategy {strategy_config['strategy_name']} stopped successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to stop strategy: {e}")
            return False

```

### `/simpletrade/simpletrade/services/monitor_service.py`
*(统计信息: 312 行, 9763 字符 [~1.40%])*
```python
"""
策略监控服务

提供对运行中策略的实时监控功能。
"""

import logging
import time
from datetime import datetime
from typing import Dict, List, Optional, Any, Union, Tuple
from threading import Thread
from sqlalchemy.orm import Session
# from simpletrade.config.database import get_db # Old incorrect path
from simpletrade.api.deps import get_db # Correct path for dependency injection
from simpletrade.core.engine import STMainEngine
# from simpletrade.models.database import Strategy, UserStrategy, StrategyRun, TradeRecord # Old import with missing models
from simpletrade.models.database import Strategy, UserStrategy # Corrected import

logger = logging.getLogger("simpletrade.services.monitor_service")

class StrategyMonitor:
    """策略监控类，用于监控单个策略的运行状态"""

    def __init__(self, strategy_name: str, user_strategy_id: int):
        """
        初始化

        参数:
            strategy_name (str): 策略名称
            user_strategy_id (int): 用户策略ID
        """
        self.strategy_name = strategy_name
        self.user_strategy_id = user_strategy_id
        self.start_time = datetime.now()
        self.last_update_time = datetime.now()
        self.status = "running"  # running, stopped, error
        self.error_message = ""
        self.performance = {
            "total_profit": 0.0,
            "total_trades": 0,
            "win_trades": 0,
            "loss_trades": 0,
            "win_rate": 0.0,
            "max_drawdown": 0.0,
            "current_drawdown": 0.0
        }
        self.positions = []
        self.trades = []
        self.logs = []

    def update_status(self, status: str, error_message: str = ""):
        """
        更新策略状态

        参数:
            status (str): 策略状态
            error_message (str, optional): 错误信息
        """
        self.status = status
        self.error_message = error_message
        self.last_update_time = datetime.now()

    def update_performance(self, performance: Dict[str, Any]):
        """
        更新策略绩效

        参数:
            performance (Dict[str, Any]): 策略绩效
        """
        self.performance.update(performance)
        self.last_update_time = datetime.now()

    def update_positions(self, positions: List[Dict[str, Any]]):
        """
        更新策略持仓

        参数:
            positions (List[Dict[str, Any]]): 策略持仓
        """
        self.positions = positions
        self.last_update_time = datetime.now()

    def update_trades(self, trades: List[Dict[str, Any]]):
        """
        更新策略交易记录

        参数:
            trades (List[Dict[str, Any]]): 策略交易记录
        """
        self.trades = trades
        self.last_update_time = datetime.now()

    def add_log(self, log: str):
        """
        添加策略日志

        参数:
            log (str): 策略日志
        """
        self.logs.append({
            "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "message": log
        })
        self.last_update_time = datetime.now()

        # 只保留最近100条日志
        if len(self.logs) > 100:
            self.logs = self.logs[-100:]

    def to_dict(self) -> Dict[str, Any]:
        """
        转换为字典

        返回:
            Dict[str, Any]: 策略监控信息
        """
        return {
            "strategy_name": self.strategy_name,
            "user_strategy_id": self.user_strategy_id,
            "start_time": self.start_time.strftime("%Y-%m-%d %H:%M:%S"),
            "last_update_time": self.last_update_time.strftime("%Y-%m-%d %H:%M:%S"),
            "status": self.status,
            "error_message": self.error_message,
            "performance": self.performance,
            "positions": self.positions,
            "trades": self.trades,
            "logs": self.logs
        }

class MonitorService:
    """策略监控服务"""

    def __init__(self, main_engine: STMainEngine):
        """
        初始化

        参数:
            main_engine (STMainEngine): 主引擎实例
        """
        self.main_engine = main_engine
        self.cta_engine = main_engine.get_cta_engine()
        self.monitors: Dict[int, StrategyMonitor] = {}  # user_strategy_id -> StrategyMonitor
        self.running = False
        self.monitor_thread = None

    def start_monitor(self, user_strategy_id: int, strategy_name: str) -> bool:
        """
        开始监控策略

        参数:
            user_strategy_id (int): 用户策略ID
            strategy_name (str): 策略名称

        返回:
            bool: 是否成功
        """
        if user_strategy_id in self.monitors:
            logger.warning(f"策略 {strategy_name} 已经在监控中")
            return False

        # 创建策略监控
        monitor = StrategyMonitor(strategy_name, user_strategy_id)
        self.monitors[user_strategy_id] = monitor

        logger.info(f"开始监控策略 {strategy_name}")
        return True

    def stop_monitor(self, user_strategy_id: int) -> bool:
        """
        停止监控策略

        参数:
            user_strategy_id (int): 用户策略ID

        返回:
            bool: 是否成功
        """
        if user_strategy_id not in self.monitors:
            logger.warning(f"策略 {user_strategy_id} 不在监控中")
            return False

        # 移除策略监控
        monitor = self.monitors.pop(user_strategy_id)

        logger.info(f"停止监控策略 {monitor.strategy_name}")
        return True

    def get_monitor(self, user_strategy_id: int) -> Optional[StrategyMonitor]:
        """
        获取策略监控

        参数:
            user_strategy_id (int): 用户策略ID

        返回:
            Optional[StrategyMonitor]: 策略监控
        """
        return self.monitors.get(user_strategy_id)

    def get_all_monitors(self) -> List[Dict[str, Any]]:
        """
        获取所有策略监控

        返回:
            List[Dict[str, Any]]: 策略监控列表
        """
        return [monitor.to_dict() for monitor in self.monitors.values()]

    def start(self):
        """启动监控服务"""
        if self.running:
            logger.warning("监控服务已经在运行中")
            return

        self.running = True
        self.monitor_thread = Thread(target=self._monitor_loop)
        self.monitor_thread.daemon = True
        self.monitor_thread.start()

        logger.info("监控服务已启动")

    def stop(self):
        """停止监控服务"""
        if not self.running:
            logger.warning("监控服务未在运行")
            return

        self.running = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=1)
            self.monitor_thread = None

        logger.info("监控服务已停止")

    def _monitor_loop(self):
        """监控循环"""
        while self.running:
            try:
                self._update_monitors()
            except Exception as e:
                logger.error(f"监控循环异常: {e}")

            # 每5秒更新一次
            time.sleep(5)

    def _update_monitors(self):
        """更新所有策略监控"""
        # 获取所有策略状态
        strategy_infos = self.cta_engine.get_all_strategy_class_names()
        strategy_status = {}

        for strategy_name in strategy_infos:
            # 获取策略状态
            status = self.cta_engine.get_strategy_status(strategy_name)
            strategy_status[strategy_name] = status

        # 更新监控状态
        for user_strategy_id, monitor in list(self.monitors.items()):
            strategy_name = monitor.strategy_name

            # 检查策略是否存在
            if strategy_name not in strategy_status:
                monitor.update_status("error", "策略不存在")
                continue

            # 更新策略状态
            status = strategy_status[strategy_name]
            if status:
                monitor.update_status("running")

                # 获取策略实例
                strategy = self.cta_engine.strategies.get(strategy_name)
                if strategy:
                    # 更新策略绩效
                    performance = {
                        "total_profit": getattr(strategy, "total_profit", 0.0),
                        "total_trades": getattr(strategy, "total_trades", 0),
                        "win_trades": getattr(strategy, "win_trades", 0),
                        "loss_trades": getattr(strategy, "loss_trades", 0),
                        "win_rate": getattr(strategy, "win_rate", 0.0),
                        "max_drawdown": getattr(strategy, "max_drawdown", 0.0),
                        "current_drawdown": getattr(strategy, "current_drawdown", 0.0)
                    }
                    monitor.update_performance(performance)

                    # 更新策略持仓
                    positions = []
                    pos = getattr(strategy, "pos", 0)
                    if pos != 0:
                        positions.append({
                            "symbol": getattr(strategy, "vt_symbol", ""),
                            "direction": "多" if pos > 0 else "空",
                            "volume": abs(pos)
                        })
                    monitor.update_positions(positions)

                    # 更新策略交易记录
                    trades = getattr(strategy, "trades", [])
                    trade_list = []
                    for trade in trades[-10:]:  # 只取最近10条
                        trade_list.append({
                            "time": trade.time.strftime("%Y-%m-%d %H:%M:%S"),
                            "symbol": trade.vt_symbol,
                            "direction": trade.direction.value,
                            "offset": trade.offset.value,
                            "price": trade.price,
                            "volume": trade.volume
                        })
                    monitor.update_trades(trade_list)
            else:
                monitor.update_status("stopped")

```

### `/simpletrade/simpletrade/services/README.md`
*(统计信息: 242 行, 4344 字符 [~0.62%])*
```markdown
# SimpleTrade Services 包

SimpleTrade 的 services 包包含了一系列服务类，这些服务提供了交易平台的核心业务逻辑，连接底层引擎和上层应用。services 目录中的服务类通常不直接与用户交互，而是被 API 或应用调用。

## 主要服务模块

### 1. backtest_service.py - 回测服务

`BacktestService` 提供策略回测功能，使用 vnpy 的回测引擎进行策略回测。

**主要功能**：

- 运行策略回测
- 计算回测结果和统计数据
- 保存回测记录到数据库
- 获取回测历史记录

**核心方法**：

```python
def run_backtest(self,
                strategy_id: int,
                symbol: str,
                exchange: str,
                interval: str,
                start_date: date,
                end_date: date,
                initial_capital: float,
                rate: float,
                slippage: float,
                parameters: Optional[Dict[str, Any]] = None,
                user_id: int = 1,
                size: float = 1.0,
                pricetick: float = 0.01) -> Dict[str, Any]:
    """运行回测"""
    # ...
```

### 2. data_sync_service.py - 数据同步服务

`DataSyncService` 负责从不同的数据源同步历史数据到 VnPy 数据库。

**主要功能**：

- 根据配置同步数据
- 支持多种数据源（目前主要是 Qlib）
- 记录数据导入日志
- 定期自动同步数据

**核心方法**：

```python
async def sync_all_targets(self):
    """同步所有配置的目标数据"""
    # ...

async def sync_target(self, target: Dict[str, Any]):
    """同步单个目标数据"""
    # ...
```

### 3. monitor_service.py - 策略监控服务

`MonitorService` 提供对运行中策略的实时监控功能。

**主要功能**：

- 监控策略运行状态
- 跟踪策略性能指标
- 记录策略交易和持仓
- 收集策略日志

**核心类和方法**：

```python
class StrategyMonitor:
    """策略监控类，用于监控单个策略的运行状态"""
    # ...

class MonitorService:
    """策略监控服务"""

    def start_monitor(self, user_strategy_id: int, strategy_name: str) -> bool:
        """开始监控策略"""
        # ...

    def stop_monitor(self, user_strategy_id: int) -> bool:
        """停止监控策略"""
        # ...

    def get_all_monitors(self) -> List[Dict[str, Any]]:
        """获取所有策略监控"""
        # ...
```

### 4. strategy_service.py - 策略管理服务

`StrategyService` 提供策略的加载、初始化、启动、停止等功能。

**主要功能**：

- 获取可用策略列表
- 加载和初始化策略
- 启动和停止策略
- 管理策略参数

**核心方法**：

```python
def get_strategy_types(self, db: Session) -> List[str]:
    """获取数据库中所有活跃策略的不重复类型列表"""
    # ...

def get_strategy_details(self) -> List[Dict[str, Any]]:
    """获取所有策略类的详细信息"""
    # ...
```

## 服务架构设计

SimpleTrade 的服务层采用了以下设计原则：

1. **单一职责原则**：
   - 每个服务类专注于一个特定的功能领域
   - 例如，回测服务只负责回测，策略服务只负责策略管理

2. **依赖注入**：
   - 服务类通常依赖于主引擎（`STMainEngine`）
   - 通过构造函数注入依赖，便于测试和扩展

3. **异步支持**：
   - 部分服务（如数据同步服务）支持异步操作
   - 使用 `async/await` 语法进行异步编程

4. **数据库集成**：
   - 服务类通常与数据库交互，保存和读取数据
   - 使用 SQLAlchemy ORM 进行数据库操作

## 与其他模块的关系

1. **与 core 包的关系**：
   - 服务类依赖于 core 包中的主引擎和事件引擎
   - 使用 core 包提供的基础功能

2. **与 apps 包的关系**：
   - 服务类可能被 apps 包中的应用调用
   - 例如，数据管理应用可能使用数据同步服务

3. **与 api 包的关系**：
   - 服务类通常被 API 路由调用
   - API 路由将用户请求转发给相应的服务

4. **与 models 包的关系**：
   - 服务类使用 models 包中的数据模型
   - 通过数据模型与数据库交互

## 使用示例

以下是使用服务类的简单示例：

```python
# 初始化服务
from simpletrade.services.backtest_service import BacktestService
from simpletrade.services.strategy_service import StrategyService

# 创建服务实例
backtest_service = BacktestService(main_engine)
strategy_service = StrategyService(main_engine)

# 获取策略列表
strategies = strategy_service.get_strategy_details()

# 运行回测
result = backtest_service.run_backtest(
    strategy_id=1,
    symbol="AAPL",
    exchange="SMART",
    interval="1d",
    start_date=date(2023, 1, 1),
    end_date=date(2023, 12, 31),
    initial_capital=100000.0,
    rate=0.0003,
    slippage=0.01
)
```

## 服务扩展

如果需要添加新的服务，可以按照以下步骤进行：

1. 在 `simpletrade/services` 目录下创建新的服务文件，如 `new_service.py`
2. 定义服务类，通常需要依赖主引擎
3. 实现服务的核心功能
4. 在需要使用该服务的地方导入并实例化

例如，创建一个新的风控服务：

```python
# simpletrade/services/risk_service.py
from typing import Dict, List, Optional, Any
from simpletrade.core.engine import STMainEngine

class RiskService:
    """风控服务"""

    def __init__(self, main_engine: STMainEngine):
        """初始化"""
        self.main_engine = main_engine

    def check_order_risk(self, order_data: Dict[str, Any]) -> bool:
        """检查订单风险"""
        # 实现风控逻辑
        return True

    def set_risk_limits(self, limits: Dict[str, Any]) -> bool:
        """设置风控限制"""
        # 实现设置风控限制的逻辑
        return True
```

## 最佳实践

1. **保持服务类的专注性**：
   - 每个服务类应该只负责一个特定的功能领域
   - 避免在一个服务类中混合不相关的功能

2. **使用依赖注入**：
   - 通过构造函数注入依赖，而不是在服务类内部创建依赖
   - 这样可以方便测试和替换依赖

3. **异步处理长时间运行的任务**：
   - 对于可能长时间运行的任务，使用异步方法
   - 避免阻塞主线程

4. **错误处理和日志记录**：
   - 在服务类中妥善处理异常
   - 使用日志记录关键操作和错误

5. **数据验证**：
   - 在服务方法中验证输入参数
   - 返回明确的错误信息

```

### `/simpletrade/simpletrade/core/config.py`
*(统计信息: 244 行, 7427 字符 [~1.06%])*
```python
"""
SimpleTrade 配置管理模块

提供统一的配置管理，支持从环境变量和配置文件加载。
"""

import os
import json
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional, Type, TypeVar, Union, cast
from pydantic import BaseModel, Field, validator

# 获取项目根目录
ROOT_DIR = Path(__file__).parent.parent.parent.absolute()

# 配置模型
class DatabaseConfig(BaseModel):
    """数据库配置模型"""
    host: str = Field("localhost", description="数据库主机地址")
    port: int = Field(3306, description="数据库端口")
    username: str = Field("root", description="数据库用户名")
    password: str = Field("", description="数据库密码")
    database: str = Field("simpletrade", description="数据库名称")
    driver: str = Field("mysql+pymysql", description="数据库驱动")
    pool_size: int = Field(5, description="连接池大小")
    max_overflow: int = Field(10, description="最大溢出连接数")
    pool_timeout: int = Field(30, description="连接池超时时间")
    pool_recycle: int = Field(1800, description="连接回收时间")
    echo: bool = Field(False, description="是否打印SQL语句")

    def get_connection_url(self) -> str:
        """获取数据库连接URL"""
        return f"{self.driver}://{self.username}:{self.password}@{self.host}:{self.port}/{self.database}"

class CORSConfig(BaseModel):
    """CORS配置模型"""
    allow_origins: List[str] = Field(["*"], description="允许的源")
    allow_methods: List[str] = Field(["*"], description="允许的方法")
    allow_headers: List[str] = Field(["*"], description="允许的头部")
    allow_credentials: bool = Field(True, description="是否允许凭证")

class ServerConfig(BaseModel):
    """服务器配置模型"""
    host: str = Field("0.0.0.0", description="服务器主机地址")
    port: int = Field(8000, description="服务器端口")
    debug: bool = Field(False, description="是否开启调试模式")
    reload: bool = Field(False, description="是否开启热重载")
    workers: int = Field(1, description="工作进程数")
    cors: CORSConfig = Field(default_factory=CORSConfig, description="CORS配置")

class LoggingConfig(BaseModel):
    """日志配置模型"""
    level: str = Field("INFO", description="日志级别")
    format: str = Field("%(asctime)s | %(levelname)-8s | %(name)s | %(message)s", description="日志格式")
    date_format: str = Field("%Y-%m-%d %H:%M:%S", description="日期格式")
    directory: str = Field("logs", description="日志目录")
    file_output: bool = Field(True, description="是否输出到文件")
    console_output: bool = Field(True, description="是否输出到控制台")
    colored_console: bool = Field(True, description="控制台是否使用颜色")
    rotation: str = Field("midnight", description="轮换时间")
    backup_count: int = Field(30, description="备份文件数量")

class AppConfig(BaseModel):
    """应用配置模型"""
    debug: bool = Field(False, description="调试模式")
    environment: str = Field("production", description="运行环境")
    server: ServerConfig = Field(default_factory=ServerConfig, description="服务器配置")
    database: DatabaseConfig = Field(default_factory=DatabaseConfig, description="数据库配置")
    logging: LoggingConfig = Field(default_factory=LoggingConfig, description="日志配置")

    @validator('environment')
    def validate_environment(cls, v):
        """验证环境变量"""
        allowed = ["development", "testing", "production"]
        if v not in allowed:
            raise ValueError(f"环境必须是以下之一: {', '.join(allowed)}")
        return v

# 配置管理器单例
class ConfigManager:
    """配置管理器类

    负责加载和管理应用配置。
    """
    _instance = None
    _config: Optional[AppConfig] = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(ConfigManager, cls).__new__(cls)
            cls._config = None
        return cls._instance

    def load_from_file(self, config_path: Union[str, Path]) -> None:
        """从文件加载配置

        Args:
            config_path: 配置文件路径
        """
        path = Path(config_path)
        if not path.exists():
            raise FileNotFoundError(f"配置文件不存在: {path}")

        with open(path, "r", encoding="utf-8") as f:
            config_data = json.load(f)

        self._config = AppConfig.parse_obj(config_data)

    def load_from_env(self) -> None:
        """从环境变量加载配置"""
        # 数据库配置
        db_config = {
            "host": os.getenv("DB_HOST", "localhost"),
            "port": int(os.getenv("DB_PORT", "3306")),
            "username": os.getenv("DB_USER", "root"),
            "password": os.getenv("DB_PASSWORD", ""),
            "database": os.getenv("DB_NAME", "simpletrade"),
        }

        # 服务器配置
        server_config = {
            "host": os.getenv("SERVER_HOST", "0.0.0.0"),
            "port": int(os.getenv("SERVER_PORT", "8000")),
            "debug": os.getenv("SERVER_DEBUG", "").lower() in ("true", "1", "yes"),
            "reload": os.getenv("SERVER_RELOAD", "").lower() in ("true", "1", "yes"),
            "workers": int(os.getenv("SERVER_WORKERS", "1")),
        }

        # 日志配置
        log_config = {
            "level": os.getenv("LOG_LEVEL", "INFO"),
            "directory": os.getenv("LOG_DIR", "logs"),
        }

        # 应用配置
        app_config = {
            "debug": os.getenv("APP_DEBUG", "").lower() in ("true", "1", "yes"),
            "environment": os.getenv("APP_ENV", "production"),
            "server": server_config,
            "database": db_config,
            "logging": log_config,
        }

        self._config = AppConfig.parse_obj(app_config)

    def set_config(self, config: AppConfig) -> None:
        """设置配置

        Args:
            config: 配置对象
        """
        self._config = config

    def get_config(self) -> AppConfig:
        """获取配置

        Returns:
            AppConfig: 配置对象

        Raises:
            RuntimeError: 如果配置未初始化
        """
        if self._config is None:
            raise RuntimeError("配置未初始化，请先调用 load_from_file/load_from_env/set_config")
        return self._config

    def get_server_config(self) -> ServerConfig:
        """获取服务器配置

        Returns:
            ServerConfig: 服务器配置对象
        """
        return self.get_config().server

    def get_database_config(self) -> DatabaseConfig:
        """获取数据库配置

        Returns:
            DatabaseConfig: 数据库配置对象
        """
        return self.get_config().database

    def get_logging_config(self) -> LoggingConfig:
        """获取日志配置

        Returns:
            LoggingConfig: 日志配置对象
        """
        return self.get_config().logging

# 全局配置管理器实例
_config_manager = ConfigManager()

def initialize_config(config_path: Optional[Union[str, Path]] = None) -> AppConfig:
    """初始化配置

    如果提供了配置文件路径，则从文件加载；
    否则尝试从环境变量加载。

    Args:
        config_path: 配置文件路径

    Returns:
        AppConfig: 配置对象
    """
    if config_path:
        _config_manager.load_from_file(config_path)
    else:
        _config_manager.load_from_env()

    return _config_manager.get_config()

def get_config() -> AppConfig:
    """获取配置对象

    Returns:
        AppConfig: 配置对象
    """
    return _config_manager.get_config()

def get_server_config() -> ServerConfig:
    """获取服务器配置对象

    Returns:
        ServerConfig: 服务器配置对象
    """
    return _config_manager.get_server_config()

def get_database_config() -> DatabaseConfig:
    """获取数据库配置对象

    Returns:
        DatabaseConfig: 数据库配置对象
    """
    return _config_manager.get_database_config()

def get_logging_config() -> LoggingConfig:
    """获取日志配置对象

    Returns:
        LoggingConfig: 日志配置对象
    """
    return _config_manager.get_logging_config()
```

### `/simpletrade/simpletrade/core/README.md`
*(统计信息: 225 行, 4460 字符 [~0.64%])*
```markdown
# SimpleTrade Core 包

SimpleTrade 的 core 包是整个项目的核心，包含了基础组件和核心功能。它扩展了 vnpy 的核心功能，并提供了 SimpleTrade 特有的功能。

## 主要模块

### engine.py - 主引擎模块

`engine.py` 定义了 `STMainEngine` 类，继承自 vnpy 的 `MainEngine`，是整个系统的核心。

**主要功能**：

- 管理所有功能模块，包括交易接口和应用模块
- 添加了 SimpleTrade 特有的功能，如 `st_engines` 字典
- 处理日志事件
- 提供获取引擎实例的方法

**核心方法**：

```python
class STMainEngine(MainEngine):
    def __init__(self, event_engine=None):
        # 初始化

    def register_event(self):
        # 注册事件处理函数

    def process_log_event(self, event):
        # 处理日志事件

    def add_st_engine(self, engine_name, engine):
        # 添加SimpleTrade引擎

    def get_st_engine(self, engine_name):
        # 获取SimpleTrade引擎

    def connect(self, setting, gateway_name):
        # 连接交易接口

    def get_cta_engine(self):
        # 获取CTA策略引擎
```

### app.py - 应用基类模块

`app.py` 定义了 `STBaseApp` 和 `STBaseEngine` 类，是所有 SimpleTrade 应用和引擎的基类。

**主要功能**：

- 提供应用和引擎的基本结构和接口
- 定义应用和引擎的通用属性和方法
- 与 vnpy 的应用框架集成

**核心类**：

```python
class STBaseApp(BaseApp):
    app_type = "st"  # SimpleTrade应用类型
    app_name = ""    # 应用名称
    app_module = ""  # 应用模块
    app_path = ""    # 应用路径
    display_name = ""  # 显示名称
    engine_class = None  # 引擎类
    widget_class = None  # 界面类

    def __init__(self, main_engine, event_engine):
        # 初始化

class STBaseEngine(BaseEngine):
    def __init__(self, main_engine, event_engine, app_name):
        # 初始化
```

### initialization.py - 初始化模块

`initialization.py` 提供了系统初始化的功能，包括初始化事件引擎、主引擎、网关和应用。

**主要功能**：

- 初始化核心组件
- 加载网关和应用
- 配置系统参数

**核心函数**：

```python
def initialize_core_components():
    """初始化核心组件"""
    # 创建事件引擎和主引擎
    event_engine = EventEngine()
    main_engine = STMainEngine(event_engine)

    # 添加网关
    # ...

    # 添加应用
    main_engine.add_app(STMessageApp)
    main_engine.add_app(STTraderApp)
    main_engine.add_app(STDataManagerApp)
    main_engine.add_app(STAnalysisApp)

    # 添加vnpy原生应用
    if DataManagerApp:
        main_engine.add_app(DataManagerApp)
    # ...

    return main_engine, event_engine
```

## 与 vnpy 的关系

SimpleTrade 的 core 包主要是对 vnpy 的扩展和增强：

1. **继承关系**：
   - `STMainEngine` 继承自 vnpy 的 `MainEngine`
   - `STBaseApp` 继承自 vnpy 的 `BaseApp`
   - `STBaseEngine` 继承自 vnpy 的 `BaseEngine`

2. **功能复用**：
   - 直接使用 vnpy 的数据模型（如 `BarData`、`TickData`）
   - 直接使用 vnpy 的常量（如 `Exchange`、`Interval`）
   - 直接使用 vnpy 的数据库功能

3. **功能扩展**：
   - 添加了消息处理功能
   - 添加了 API 接口
   - 添加了更多的数据分析功能

## 设计说明

SimpleTrade 的 core 包采用了模块化设计，主要特点包括：

1. **分层架构**：
   - 核心层：提供基础功能和接口
   - 应用层：提供具体功能实现
   - 接口层：提供与外部系统的交互

2. **插件机制**：
   - 通过 `add_app` 方法加载应用
   - 应用可以独立开发和维护
   - 应用之间通过事件和引擎实例交互

3. **事件驱动**：
   - 使用 vnpy 的事件引擎
   - 通过事件实现模块间的松耦合
   - 支持异步处理

4. **配置灵活**：
   - 支持通过环境变量配置
   - 支持通过配置文件配置
   - 支持运行时动态配置

5. **职责分离**：
   - core 包只提供核心功能和基础接口
   - 具体功能实现在 apps 包中
   - 避免功能重复和职责不清

## 架构改进说明

为了使架构更加清晰和合理，我们进行了以下改进：

1. **移除了 core/data 目录**：
   - 数据管理功能完全由 `apps/st_datamanager` 提供
   - 避免了功能重复和职责不清

2. **移除了 core/message 目录**：
   - 消息处理功能完全由 `apps/st_message` 提供
   - 基础接口和具体实现都在同一个应用中

3. **移除了 core/analysis 目录**：
   - 分析功能完全由 `apps/st_analysis` 提供
   - 提供了完整的分析功能，包括技术指标计算、策略回测和可视化分析

4. **创建了 apps/st_analysis 应用**：
   - 将分析功能从 core 包移动到 apps 包中
   - 添加了 API 接口和消息指令处理功能

## 使用示例

```python
# 初始化核心组件
from simpletrade.core.initialization import initialize_core_components
main_engine, event_engine = initialize_core_components()

# 获取应用引擎
data_engine = main_engine.get_engine("st_datamanager")
message_engine = main_engine.get_engine("st_message")
trader_engine = main_engine.get_engine("st_trader")
analysis_engine = main_engine.get_engine("st_analysis")

# 使用数据管理功能
bars = data_engine.get_bar_data(
    symbol="AAPL",
    exchange=Exchange.SMART,
    interval=Interval.DAILY,
    start=datetime(2023, 1, 1),
    end=datetime(2023, 12, 31)
)

# 使用分析功能
df = analysis_engine.calculate_indicators(bars, ["ma", "macd", "rsi"])
results = analysis_engine.backtest_strategy(bars, {"ma_cross": {"fast": 5, "slow": 20}})

# 使用消息处理功能
message_engine.process_message("/data query bar AAPL SMART 1d 2023-01-01")
message_engine.process_message("/analysis indicator AAPL SMART 1d 2023-01-01 2023-12-31 ma macd")

# 使用交易功能
trader_engine.send_order(
    symbol="AAPL",
    exchange=Exchange.SMART,
    direction=Direction.LONG,
    offset=Offset.OPEN,
    price=150.0,
    volume=100,
    gateway_name="TIGER"
)
```

## 依赖关系

- 依赖 vnpy 及其相关包
- 依赖 pandas、numpy 等数据处理库
- 依赖 FastAPI、uvicorn 等 Web 框架

```

### `/simpletrade/simpletrade/core/initialization.py`
*(统计信息: 216 行, 10008 字符 [~1.43%])*
```python
import logging
import json
from pathlib import Path

from vnpy.event import EventEngine
from vnpy.trader.setting import SETTINGS # Needed for reading config for connect
from vnpy.trader.gateway import BaseGateway

# --- Import project specific config ---
from simpletrade.config.settings import DB_CONFIG, API_CONFIG, LOG_CONFIG # Import needed configs

# Import Core Engine
from simpletrade.core.engine import STMainEngine

# Import SimpleTrade Apps
from simpletrade.apps.st_message import STMessageApp
from simpletrade.apps.st_trader import STTraderApp
from simpletrade.apps.st_datamanager import STDataManagerApp
from simpletrade.apps.st_analysis import STAnalysisApp
from simpletrade.apps.st_backtest import STBacktestApp

# Import Optional External/VnPy Apps & Gateways with Error Handling
logger = logging.getLogger(__name__)

try:
    from vnpy_datamanager import DataManagerApp
    logger.info("Optional app 'vnpy_datamanager' imported successfully.")
except ImportError:
    logger.warning("Optional app 'vnpy_datamanager' not found.")
    DataManagerApp = None

try:
    from vnpy_ib import IbGateway
    logger.info("Optional gateway 'vnpy_ib' imported successfully.")
except ImportError:
    logger.warning("Optional gateway 'vnpy_ib' not found.")
    IbGateway = None

try:
    from vnpy_tiger import TigerGateway
    logger.info("Optional gateway 'vnpy_tiger' imported successfully.")
except ImportError as e:
    logger.error(f"Optional gateway 'vnpy_tiger' not found. Error: {e}")
    TigerGateway = None

# Import VnPy built-in Apps (might require vnpy installation)
try:
    from vnpy_ctastrategy import CtaStrategyApp # Import CtaStrategyApp
    logger.info("CtaStrategyApp imported successfully.")
except ImportError:
    logger.warning("Could not import CtaStrategyApp (might be intended to load by name).")

def _configure_vnpy_settings():
    """Helper function to configure VnPy global SETTINGS."""
    logger.info("Configuring VnPy global SETTINGS...")
    try:
        # Database Configuration
        logger.debug("Applying database settings...")
        SETTINGS["database.name"] = "mysql"
        SETTINGS["database.host"] = DB_CONFIG["DB_HOST"]
        SETTINGS["database.port"] = int(DB_CONFIG["DB_PORT"])
        SETTINGS["database.database"] = DB_CONFIG["DB_NAME"]
        SETTINGS["database.user"] = DB_CONFIG["DB_USER"]
        SETTINGS["database.password"] = DB_CONFIG["DB_PASSWORD"]
        logger.info("Database settings applied (using mysql).")
        logger.debug(f"  DB Name: {SETTINGS.get('database.name')}")
        logger.debug(f"  DB Host: {SETTINGS.get('database.host')}")
        # Add more debug logs if needed, avoid logging password

        # Datafeed Placeholder Configuration (to suppress warning)
        logger.debug("Applying dummy datafeed settings...")
        SETTINGS["datafeed.name"] = "dummy"
        SETTINGS["datafeed.username"] = ""
        SETTINGS["datafeed.password"] = ""
        logger.info("Dummy datafeed settings applied.")

        # You could potentially configure other SETTINGS here if needed
        # e.g., SETTINGS["log.active"] = True
        #       SETTINGS["log.level"] = LOG_CONFIG["LEVEL"]

        logger.info("VnPy global SETTINGS configuration complete.")

    except KeyError as e:
        logger.error(f"FATAL: Missing key in DB_CONFIG during SETTINGS configuration: {e}. Exiting.")
        # Depending on desired behavior, you might exit or raise the error
        raise e # Re-raise to be caught by the caller
    except Exception as e:
        logger.error(f"FATAL: Error during VnPy SETTINGS configuration: {e}. Exiting.", exc_info=True)
        raise e # Re-raise

def initialize_core_components():
    """
    Initializes the core components of SimpleTrade: EventEngine, STMainEngine,
    loads standard Apps and Gateways.
    Applies necessary configurations to VnPy SETTINGS.
    Returns main_engine, event_engine, and the configured database instance.
    """
    logger.info("Initializing core components...")
    db_instance = None # Initialize db_instance

    # +++ Configure VnPy SETTINGS first +++
    try:
        _configure_vnpy_settings()
        # 使用get_database()而不是直接实例化MysqlDatabase
        logger.info("Getting database instance after configuration...")
        from vnpy.trader.database import get_database
        db_instance = get_database()
        logger.info(f"Successfully obtained database instance: {type(db_instance)}")

        # 注释掉直接实例化MysqlDatabase的代码
        # logger.info("Attempting to import and instantiate vnpy_mysql.MysqlDatabase...")
        # try:
        #     from vnpy_mysql.mysql_database import MysqlDatabase
        #     db_instance = MysqlDatabase()
        #     logger.info(f"Successfully instantiated MysqlDatabase: {type(db_instance)}")
        # except ImportError as import_err:
        #     logger.critical(f"Failed to import vnpy_mysql: {import_err}. MySQL database cannot be used.")
        #     db_instance = None
        # except Exception as init_err:
        #     logger.critical(f"Failed to instantiate MysqlDatabase: {init_err}", exc_info=True)
        #     db_instance = None
        # +++ End explicit instantiation +++

    except Exception as config_e:
        logger.critical(f"Core component initialization failed due to SETTINGS configuration error: {config_e}")
        # Ensure db_instance is None if settings config itself failed
        db_instance = None
        raise RuntimeError(f"Failed to configure VnPy settings: {config_e}") from config_e

    # Ensure db_instance is valid before proceeding
    if not db_instance:
         logger.critical("Database instance (MySQL) could not be obtained/instantiated. Exiting.")
         # Decide how to handle - perhaps raise the RuntimeError again or a specific DB error
         raise RuntimeError("Failed to obtain/instantiate necessary MySQL database instance.")

    # 1. Create Engines (Now done after settings are configured)

    # 1. Create Engines (Now done after settings are configured)
    logger.debug("Creating EventEngine...")
    event_engine = EventEngine()
    logger.debug("Creating STMainEngine...")
    main_engine = STMainEngine(event_engine)
    logger.debug("Engines created.")

    # 2. Add Gateways
    logger.debug("Adding gateways...")
    if IbGateway:
        main_engine.add_gateway(IbGateway)
        logger.info("IB Gateway added.")
    if TigerGateway:
        main_engine.add_gateway(TigerGateway)
        logger.info("Tiger Gateway added.")
        # Attempt to connect Tiger Gateway automatically if config exists
        try:
            tiger_config_path = Path.home().joinpath(".vnpy", "connect_tiger.json")
            if tiger_config_path.exists():
                logger.info(f"Found Tiger connection config at {tiger_config_path}")
                with open(tiger_config_path, "r") as f:
                    tiger_configs = json.load(f)
                    if tiger_configs and isinstance(tiger_configs, list) and len(tiger_configs) > 0:
                        # Use the first config entry
                        tiger_config = tiger_configs[0]
                        logger.info(f"Attempting to connect Tiger: ID={tiger_config.get('tiger_id')}, Account={tiger_config.get('account')}")
                        # Construct setting dict carefully, handle potential missing keys
                        setting = {
                            "tiger_id": tiger_config.get("tiger_id", ""),
                            "account": tiger_config.get("account", ""),
                            "private_key": tiger_config.get("private_key", ""),
                            "server": tiger_config.get("server", "标准"), # Default to standard
                            "language": tiger_config.get("language", "中文") # Default to Chinese
                        }
                        # Filter out empty essential keys before connecting
                        if all([setting["tiger_id"], setting["account"], setting["private_key"]]):
                             main_engine.connect(setting, "TIGER")
                             # Note: Connection might happen asynchronously. We log the attempt here.
                             logger.info("Tiger Gateway connection initiated.")
                        else:
                            logger.warning("Tiger config found but missing essential keys (tiger_id, account, private_key). Connection skipped.")
            else:
                logger.info(f"Tiger connection config not found at {tiger_config_path}. Auto-connection skipped.")
        except Exception as e:
            logger.error(f"Error during automatic Tiger Gateway connection: {e}", exc_info=True)
    logger.debug("Gateways added.")

    # 3. Add Apps
    logger.debug("Adding applications...")
    # Add SimpleTrade Apps first (MessageApp often needs to be early)
    # 直接传递应用类，而不是应用实例
    main_engine.add_app(STMessageApp)
    logger.info("ST Message App added.")
    main_engine.add_app(STTraderApp)
    logger.info("ST Trader App added.")
    main_engine.add_app(STDataManagerApp)
    logger.info("ST Data Manager App added.")
    main_engine.add_app(STAnalysisApp)
    logger.info("ST Analysis App added.")
    main_engine.add_app(STBacktestApp)
    logger.info("ST Backtest App added.")

    # Add original VnPy DataManager App if available
    if DataManagerApp:
        main_engine.add_app(DataManagerApp)
        logger.info("Original VnPy DataManager App added.")

    # Add VnPy CTA Strategy App (using the class)
    try:
        main_engine.add_app(CtaStrategyApp) # 使用类名而不是字符串
        logger.info("VnPy CTA Strategy App added.")
    except Exception as e:
        # Catch potential errors if the app isn't found or fails to load
        logger.error(f"Failed to add CTA Strategy App: {e}", exc_info=True)
    logger.debug("Applications added.")

    logger.info("Core components initialization complete.")
    # +++ Return db_instance along with engines +++
    return main_engine, event_engine, db_instance
```

### `/simpletrade/simpletrade/core/engine.py`
*(统计信息: 173 行, 5162 字符 [~0.74%])*
```python
"""
SimpleTrade主引擎模块

本模块扩展了vnpy的MainEngine，添加了SimpleTrade特有的功能。
"""

from vnpy.trader.engine import MainEngine, BaseEngine
from vnpy.event import EventEngine, Event
from vnpy.trader.app import BaseApp
from vnpy_ctastrategy import CtaStrategyApp
import inspect  # 需要导入 inspect 模块

class STMainEngine(MainEngine):
    """
    SimpleTrade主引擎

    负责管理所有功能模块，包括交易接口、应用模块和SimpleTrade特有的引擎。
    """

    def __init__(self, event_engine=None):
        """
        初始化

        参数:
            event_engine (EventEngine, optional): 事件引擎，默认为None
        """
        if event_engine is None:
            event_engine = EventEngine()
        super().__init__(event_engine)

        # 添加SimpleTrade特有的功能
        self.st_engines = {}

        # 添加CTA策略应用
        self.add_app(CtaStrategyApp)

        # 注册事件处理函数
        self.register_event()

    def register_event(self):
        """注册事件处理函数"""
        self.event_engine.register("eLog", self.process_log_event)

    def process_log_event(self, event):
        """
        处理日志事件

        参数:
            event (Event): 日志事件
        """
        log = event.data
        # 可以添加自定义日志处理逻辑，如保存到数据库等

    def add_st_engine(self, engine_name, engine):
        """
        添加SimpleTrade引擎

        参数:
            engine_name (str): 引擎名称
            engine (object): 引擎实例
        """
        if engine_name in self.st_engines:
            return

        self.st_engines[engine_name] = engine

    def get_st_engine(self, engine_name):
        """
        获取SimpleTrade引擎

        参数:
            engine_name (str): 引擎名称

        返回:
            object: 引擎实例，如果不存在则返回None
        """
        return self.st_engines.get(engine_name, None)

    def connect(self, setting, gateway_name):
        """
        连接交易接口

        参数:
            setting (dict): 接口设置
            gateway_name (str): 接口名称

        返回:
            bool: 连接是否成功
        """
        # 添加前置处理，如连接日志记录
        print(f"Connecting to {gateway_name}...")

        # 调用原始连接方法
        result = super().connect(setting, gateway_name)

        # 添加后置处理，如连接状态检查
        if result:
            print(f"Connected to {gateway_name} successfully.")
        else:
            print(f"Failed to connect to {gateway_name}.")

        return result

    def add_app(self, app_class: type[BaseApp]) -> BaseEngine:
        """
        覆盖 VnPy 的 add_app 方法，并智能处理引擎初始化参数。
        Add app, handling different engine __init__ signatures.
        """
        app: BaseApp = app_class()
        self.apps[app.app_name] = app

        if hasattr(app, "init_engine"):
            app.init_engine(self, self.event_engine)

        if not hasattr(app, "engine_class") or not app.engine_class:
            self.write_log(f"App {app.app_name} does not have an associated engine_class.", source="STMainEngine")
            return None

        engine_class = app.engine_class
        engine_name = app.app_name

        # === 智能参数处理 ===
        try:
            # Inspect the engine's __init__ method signature
            sig = inspect.signature(engine_class.__init__)
            params = sig.parameters
            num_params = len(params) # 获取参数总数 (包括 self)

            # 根据 __init__ 的参数数量调用构造函数
            if num_params == 4:  # 期望 __init__(self, main_engine, event_engine, engine_name)
                engine: BaseEngine = engine_class(self, self.event_engine, engine_name)
            elif num_params == 3:  # 期望 __init__(self, main_engine, event_engine)，例如 CtaEngine
                engine: BaseEngine = engine_class(self, self.event_engine)
                # 由于 BaseEngine.__init__ 需要 engine_name，而这里没有传递
                # 尝试在实例化后手动设置 engine_name (如果引擎实例允许)
                if hasattr(engine, 'engine_name') and not engine.engine_name:
                     try:
                         engine.engine_name = engine_name
                     except AttributeError:
                         self.write_log(f"Warning: Could not set engine_name on {engine_class.__name__} instance after initialization.", source="STMainEngine")

            else: # 处理非预期的参数数量
                raise TypeError(f"Engine class {engine_class.__name__}.__init__ has an unexpected signature with {num_params} parameters.")

        except Exception as e:
            self.write_log(f"Failed to inspect or initialize engine {engine_name} for app {app.app_name}. Error: {e}", source="STMainEngine")
            raise e

        # 确保 engine_name 被设置 (如果可能)
        if not hasattr(engine, 'engine_name') or not engine.engine_name:
            self.write_log(f"Warning: Engine {engine.__class__.__name__} instance created but 'engine_name' attribute might be missing or incorrect.", source="STMainEngine")
            try:
                if not getattr(engine, 'engine_name', None):
                    engine.engine_name = engine_name
            except AttributeError:
                pass

        self.engines[engine_name] = engine # 使用 app_name 作为 key 存储

        if hasattr(app, "init_app"):
            app.init_app()

        return engine

    def get_cta_engine(self):
        """
        获取CTA策略引擎

        返回:
            CtaEngine: CTA策略引擎实例
        """
        return self.get_engine("CtaStrategy")

```

### `/simpletrade/simpletrade/core/logging.py`
*(统计信息: 148 行, 4023 字符 [~0.58%])*
```python
"""
SimpleTrade 日志模块

提供统一的日志配置和管理功能。
"""

import os
import sys
import logging
import logging.handlers
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional, Union

# 默认配置
DEFAULT_LOG_FORMAT = "%(asctime)s | %(levelname)-8s | %(name)s | %(message)s"
DEFAULT_DATE_FORMAT = "%Y-%m-%d %H:%M:%S"
DEFAULT_LOG_LEVEL = logging.INFO
DEFAULT_LOG_DIR = "logs"
LOG_ROTATION = "midnight"  # 每天午夜轮换日志
LOG_BACKUP_COUNT = 30  # 保留30天的日志

# 颜色格式
COLORS = {
    "DEBUG": "\033[36m",  # 青色
    "INFO": "\033[32m",   # 绿色
    "WARNING": "\033[33m", # 黄色
    "ERROR": "\033[31m",  # 红色
    "CRITICAL": "\033[41m", # 红底
    "RESET": "\033[0m"    # 重置
}

class ColoredFormatter(logging.Formatter):
    """带颜色的日志格式化器"""

    def format(self, record):
        """格式化日志记录，为不同级别添加颜色"""
        levelname = record.levelname
        if levelname in COLORS and sys.stdout.isatty():  # 仅在终端输出时启用颜色
            record.levelname = f"{COLORS[levelname]}{levelname}{COLORS['RESET']}"
            if record.levelno >= logging.ERROR:
                record.msg = f"{COLORS[levelname]}{record.msg}{COLORS['RESET']}"
        return super().format(record)


# 全局日志配置状态
_logging_configured = False
_log_dir = Path(DEFAULT_LOG_DIR)

def configure_logging(
    log_level: Union[int, str] = DEFAULT_LOG_LEVEL,
    log_dir: Optional[str] = None,
    log_format: str = DEFAULT_LOG_FORMAT,
    date_format: str = DEFAULT_DATE_FORMAT,
    console_output: bool = True,
    file_output: bool = True,
    colored_console: bool = True
) -> None:
    """
    配置全局日志

    Args:
        log_level: 日志级别，可以是int或str
        log_dir: 日志文件目录
        log_format: 日志格式
        date_format: 日期格式
        console_output: 是否输出到控制台
        file_output: 是否输出到文件
        colored_console: 控制台输出是否带颜色
    """
    global _logging_configured, _log_dir

    if _logging_configured:
        return

    # 转换日志级别字符串为int
    if isinstance(log_level, str):
        numeric_level = getattr(logging, log_level.upper(), None)
        if not isinstance(numeric_level, int):
            raise ValueError(f"无效的日志级别: {log_level}")
        log_level = numeric_level

    # 设置日志目录
    if log_dir:
        _log_dir = Path(log_dir)

    # 创建日志目录（如果不存在）
    if file_output:
        _log_dir.mkdir(parents=True, exist_ok=True)

    # 配置根日志记录器
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)

    # 清除现有处理器
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    # 添加控制台处理器
    if console_output:
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(log_level)

        if colored_console:
            console_formatter = ColoredFormatter(log_format, date_format)
        else:
            console_formatter = logging.Formatter(log_format, date_format)

        console_handler.setFormatter(console_formatter)
        root_logger.addHandler(console_handler)

    # 添加文件处理器
    if file_output:
        log_file = _log_dir / f"simpletrade_{datetime.now().strftime('%Y%m%d')}.log"
        file_handler = logging.handlers.TimedRotatingFileHandler(
            filename=log_file,
            when=LOG_ROTATION,
            backupCount=LOG_BACKUP_COUNT,
            encoding="utf-8"
        )
        file_handler.setLevel(log_level)
        file_formatter = logging.Formatter(log_format, date_format)
        file_handler.setFormatter(file_formatter)
        root_logger.addHandler(file_handler)

    # 设置已配置标志
    _logging_configured = True

    # 记录初始日志消息
    logger = logging.getLogger(__name__)
    logger.info(f"日志系统初始化完成，级别: {logging.getLevelName(log_level)}, 目录: {_log_dir if file_output else 'None'}")

def get_logger(name: str) -> logging.Logger:
    """
    获取指定名称的日志记录器

    如果全局日志尚未配置，将自动使用默认配置初始化

    Args:
        name: 日志记录器名称

    Returns:
        logging.Logger: 日志记录器
    """
    if not _logging_configured:
        configure_logging()

    return logging.getLogger(name)
```

### `/simpletrade/simpletrade/core/server.py`
*(统计信息: 143 行, 3707 字符 [~0.53%])*
```python
"""
SimpleTrade 核心服务器模块

提供RESTful API服务器初始化和配置功能。
"""

import logging
import traceback
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from simpletrade.config.database import engine, Base

# 创建FastAPI应用实例
app = FastAPI(title="SimpleTrade API", version="0.1.0")

# 获取日志记录器
logger = logging.getLogger("simpletrade.core.server")
logger.setLevel(logging.DEBUG)

def configure_server(main_engine=None, event_engine=None):
    """
    配置FastAPI应用实例

    Args:
        main_engine: 主引擎实例
        event_engine: 事件引擎实例
    """
    logger.debug("开始配置FastAPI应用...")

    # 初始化数据库表
    _initialize_database()

    # 配置CORS中间件
    _configure_cors()

    # 存储引擎实例
    _setup_engines(main_engine, event_engine)

    # 注册API路由
    _register_routes()

    logger.info("FastAPI应用配置完成")

def _initialize_database():
    """初始化数据库表"""
    try:
        logger.info("创建数据库表...")
        Base.metadata.create_all(bind=engine)
        logger.info("数据库表创建/检查完成")
    except Exception as e:
        logger.error(f"创建数据库表失败: {e}", exc_info=True)
        # 这里不抛出异常，让应用继续启动，因为可能只是部分表创建失败

def _configure_cors():
    """配置CORS中间件"""
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # 允许所有来源，生产环境应该限制
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    logger.debug("CORS中间件配置完成")

def _setup_engines(main_engine, event_engine):
    """
    设置引擎实例到app.state

    Args:
        main_engine: 主引擎实例
        event_engine: 事件引擎实例
    """
    # 存储主引擎
    if main_engine:
        logger.debug(f"使用主引擎: {main_engine}")
        app.state.main_engine = main_engine

        # 检查可用网关
        try:
            all_gateways = main_engine.get_all_gateway_names()
            logger.debug(f"可用网关: {all_gateways}")
        except Exception as e:
            logger.warning(f"无法获取网关名称: {e}")
    else:
        logger.warning("未提供主引擎!")
        app.state.main_engine = None

    # 存储事件引擎
    if event_engine:
        app.state.event_engine = event_engine
        logger.debug("事件引擎已存储")
    else:
        app.state.event_engine = None
        logger.warning("未提供事件引擎!")

def _register_routes():
    """注册所有API路由"""
    _register_data_routes()
    _register_wechat_routes()
    _register_analysis_routes()
    _register_strategy_routes()

def _register_data_routes():
    """注册数据管理API路由"""
    try:
        from simpletrade.apps.st_datamanager.api import router as data_router
        app.include_router(data_router)
        logger.debug("数据管理API路由已添加")
    except Exception as e:
        _log_router_error("数据管理API", e)

def _register_wechat_routes():
    """注册微信小程序API路由"""
    try:
        from simpletrade.api.wechat import auth_router, data_router as wechat_data_router
        app.include_router(auth_router)
        app.include_router(wechat_data_router)
        logger.debug("微信小程序API路由已添加")
    except Exception as e:
        _log_router_error("微信小程序API", e)

def _register_analysis_routes():
    """注册分析API路由"""
    try:
        from simpletrade.apps.st_analysis.api import router as analysis_router
        app.include_router(analysis_router)
        logger.debug("分析API路由已添加")
    except Exception as e:
        _log_router_error("分析API", e)

def _register_strategy_routes():
    """注册策略API路由"""
    try:
        from simpletrade.api.routers.strategies import router as strategies_router
        app.include_router(strategies_router)
        logger.debug("策略API路由已添加")
    except Exception as e:
        _log_router_error("策略API", e)

def _log_router_error(router_name, error):
    """记录路由器注册错误"""
    error_msg = f"{router_name}路由注册失败: {error}\n{traceback.format_exc()}"
    logger.error(error_msg)
```

### `/simpletrade/simpletrade/core/app.py`
*(统计信息: 88 行, 2366 字符 [~0.34%])*
```python
"""
SimpleTrade应用基础模块

本模块定义了SimpleTrade应用的基础类。
"""

import importlib
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional
from types import ModuleType

from vnpy.trader.app import BaseApp
from vnpy.trader.engine import BaseEngine

# 导入vnpy相关模块
# from vnpy.vnpy.trader.app import BaseApp
# from vnpy.vnpy.trader.engine import BaseEngine

class STBaseApp(BaseApp):
    """
    SimpleTrade基础应用类

    所有SimpleTrade应用都应继承此类。
    """

    app_type = "st"  # SimpleTrade应用类型
    app_name = ""    # 应用名称
    app_module = ""  # 应用模块
    app_path = ""    # 应用路径
    display_name = ""  # 显示名称
    engine_class = None  # 引擎类
    widget_class = None  # 界面类

    def __init__(self):
        """
        初始化 - 移除 main_engine 和 event_engine 参数
        """
        super().__init__() # 调用父类初始化
        self.main_engine = None
        self.event_engine = None
        self.engine = None

    def init_engine(self, main_engine, event_engine):
        """
        初始化引擎 - 由 MainEngine.add_app 调用
        """
        self.main_engine = main_engine
        self.event_engine = event_engine

        # 创建应用引擎实例 (如果 engine_class 已定义)
        if self.engine_class:
            self.engine = self.engine_class(main_engine, event_engine, self.app_name)

class STBaseEngine(BaseEngine):
    """
    SimpleTrade基础引擎类

    所有SimpleTrade引擎都应继承此类。
    """

    def __init__(self, main_engine, event_engine, app_name: Optional[str] = None):
        """
        初始化 - 使 app_name 可选以兼容 VnPy add_engine 的调用

        参数:
            main_engine (MainEngine): 主引擎
            event_engine (EventEngine): 事件引擎
            app_name (str, optional): 应用名称. Defaults to None.
        """
        resolved_app_name = app_name
        if resolved_app_name is None:
            # 如果 app_name 未被 add_engine 提供, 使用引擎类名作为后备
            # 这可能不是 App 类中定义的 app_name, 但 BaseEngine 可能需要一个字符串名称
            resolved_app_name = self.__class__.__name__

        # 使用解析出的名称调用父类 __init__
        # 注意: 这依赖于 vnpy.trader.engine.BaseEngine 的 __init__ 接受 engine_name
        super().__init__(main_engine, event_engine, resolved_app_name)

        # 将解析出的名称存储为 engine_name 供内部使用
        self.engine_name = resolved_app_name

        # 添加到主引擎的ST引擎列表
        if hasattr(main_engine, "add_st_engine"):
            # 使用存储的 engine_name
            main_engine.add_st_engine(self.engine_name, self)

```

### `/simpletrade/simpletrade/core/database.py`
*(统计信息: 64 行, 1359 字符 [~0.19%])*
```python
"""
SimpleTrade 数据库核心模块

提供数据库连接和会话管理功能。
"""

import logging
from typing import Generator
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session

# 后续会从配置模块导入
from simpletrade.config.settings import DB_CONFIG

logger = logging.getLogger(__name__)

# 创建数据库URL
db_url = f"mysql+pymysql://{DB_CONFIG['DB_USER']}:{DB_CONFIG['DB_PASSWORD']}@{DB_CONFIG['DB_HOST']}:{DB_CONFIG['DB_PORT']}/{DB_CONFIG['DB_NAME']}"

# 创建数据库引擎
try:
    engine = create_engine(
        db_url,
        pool_size=5,
        max_overflow=10,
        pool_timeout=30,
        pool_recycle=1800,
        echo=False
    )
    logger.info("数据库引擎创建成功")
except Exception as e:
    logger.error(f"创建数据库引擎失败: {e}", exc_info=True)
    raise

# 创建会话工厂
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 创建基类
Base = declarative_base()

def get_db() -> Generator[Session, None, None]:
    """
    获取数据库会话，完成后自动关闭

    Yields:
        Session: 数据库会话对象
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def init_db() -> None:
    """
    初始化数据库，创建所有表
    """
    try:
        Base.metadata.create_all(bind=engine)
        logger.info("数据库表初始化成功")
    except Exception as e:
        logger.error(f"数据库表初始化失败: {e}", exc_info=True)
        raise
```

### `/simpletrade/simpletrade/core/__init__.py`
*(统计信息: 6 行, 50 字符 [~0.01%])*
```python
"""
SimpleTrade核心模块

包含SimpleTrade的核心引擎和基础组件。
"""

```

### `/simpletrade/simpletrade/vendors/__init__.py`
*(统计信息: 0 行, 0 字符 [~0.00%])*
```python

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/README.md`
*(统计信息: 60 行, 882 字符 [~0.13%])*
```markdown
# VeighNa Tiger Gateway

老虎证券交易接口，用于对接老虎证券的行情和交易服务。

## 安装

安装环境推荐基于3.0.0版本以上的【[**VeighNa Studio**](https://www.vnpy.com)】。

直接使用pip命令：

```
pip install vnpy_tiger
```

或者下载源代码后，解压后在cmd中运行：

```
pip install .
```

## 使用

以脚本方式启动（script/run.py）：

```python
from vnpy.event import EventEngine
from vnpy.trader.engine import MainEngine
from vnpy.trader.ui import MainWindow, create_qapp

from vnpy_tiger import TigerGateway


def main():
    """主入口函数"""
    qapp = create_qapp()

    event_engine = EventEngine()
    main_engine = MainEngine(event_engine)
    main_engine.add_gateway(TigerGateway)

    main_window = MainWindow(main_engine, event_engine)
    main_window.showMaximized()

    qapp.exec()


if __name__ == "__main__":
    main()
```

## 配置

连接老虎证券接口时，需要填写以下字段：

- tiger_id：老虎证券开放平台ID
- account：交易账号
- private_key：私钥文件路径
- server：服务器类型（标准、环球、模拟）
- language：语言（中文、英文）

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/setup.py`
*(统计信息: 34 行, 1196 字符 [~0.17%])*
```python
from setuptools import setup, find_packages

setup(
    name="vnpy_tiger",
    version="1.0.0",
    author="Your Name",
    author_email="your.email@example.com",
    license="MIT",
    url="https://github.com/vnpy/vnpy_tiger",
    description="Tiger Securities gateway for VeighNa",
    packages=find_packages(include=["vnpy_tiger", "vnpy_tiger.*"]),
    install_requires=[
        "vnpy",
        "tigeropen",
    ],
    classifiers=[
        "Development Status :: 5 - Production/Stable",
        "Operating System :: Microsoft :: Windows",
        "Operating System :: Unix",
        "Operating System :: POSIX",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Topic :: Office/Business :: Financial :: Investment",
        "Programming Language :: Python :: Implementation :: CPython",
        "License :: OSI Approved :: MIT License",
        "Natural Language :: Chinese (Simplified)",
        "Natural Language :: Chinese (Traditional)",
        "Natural Language :: English"
    ]
)

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/requirements.txt`
*(统计信息: 3 行, 15 字符 [~0.00%])*
```
tigeropen
vnpy

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/__init__.py`
*(统计信息: 0 行, 0 字符 [~0.00%])*
```python

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/vnpy_tiger/tiger_gateway.py`
*(统计信息: 506 行, 16265 字符 [~2.33%])*
```python
"""
老虎证券交易接口
"""

import time
from copy import copy
from datetime import datetime, timedelta
from threading import Thread, Lock
from typing import Dict, List, Set, Any, Callable, Optional

from tigeropen.tiger_open_config import TigerOpenClientConfig
from tigeropen.common.consts import Language, Currency, Market
from tigeropen.quote.quote_client import QuoteClient
from tigeropen.trade.trade_client import TradeClient
from tigeropen.push.push_client import PushClient
from tigeropen.common.util.signature_utils import read_private_key

# 适配tigeropen 3.3.5版本
try:
    from tigeropen.quote.domain.market_status import MarketStatus
except ImportError:
    from tigeropen.quote.response.market_status_response import MarketStatus

# 注释掉有问题的导入
# try:
#     from tigeropen.quote.domain.quote_bar import QuoteBar
# except ImportError:
#     from tigeropen.quote.response.quote_bar_response import QuoteBar

# 定义一个简单的QuoteBar类来替代
class QuoteBar:
    def __init__(self, time=None, open=None, high=None, low=None, close=None, volume=None):
        self.time = time
        self.open = open
        self.high = high
        self.low = low
        self.close = close
        self.volume = volume

# 注释掉有问题的导入
# try:
#     from tigeropen.quote.domain.quote_tick import QuoteTick
# except ImportError:
#     from tigeropen.quote.response.tick_response import QuoteTick

# 定义一个简单的QuoteTick类来替代
class QuoteTick:
    def __init__(self, symbol=None, latest_price=None, latest_time=None, volume=None):
        self.symbol = symbol
        self.latest_price = latest_price
        self.latest_time = latest_time
        self.volume = volume

# 注释掉有问题的导入
# from tigeropen.quote.request.market_status_request import MarketStatusRequest
# from tigeropen.quote.request.quote_request import OpenApiRequest
# from tigeropen.quote.response.quote_bar_response import QuoteBarResponse
# from tigeropen.quote.request.quote_bar_request import QuoteBarRequest

# 定义简化的请求类
class MarketStatusRequest:
    def __init__(self, market=None):
        self.market = market

class OpenApiRequest:
    pass

class QuoteBarRequest:
    def __init__(self, symbol=None, period=None, begin_time=None, end_time=None):
        self.symbol = symbol
        self.period = period
        self.begin_time = begin_time
        self.end_time = end_time

from vnpy.event import EventEngine
from vnpy.trader.constant import (
    Direction,
    Exchange,
    OrderType,
    Product,
    Status,
    Interval
)
from vnpy.trader.gateway import BaseGateway
from vnpy.trader.object import (
    TickData,
    OrderData,
    TradeData,
    PositionData,
    AccountData,
    ContractData,
    BarData,
    OrderRequest,
    CancelRequest,
    SubscribeRequest,
    HistoryRequest
)

# 老虎证券交易所映射
# 检查Exchange类中是否有ASX属性
EXCHANGE_TIGER2VT: Dict[str, Exchange] = {
    "NYSE": Exchange.NYSE,
    "NASDAQ": Exchange.NASDAQ,
    "AMEX": Exchange.AMEX,
    "SEHK": Exchange.SEHK,
    "HKFE": Exchange.HKFE,
    "SGX": Exchange.SGX,
    # "ASX": Exchange.ASX,  # 注释掉不存在的属性
}
EXCHANGE_VT2TIGER: Dict[Exchange, str] = {v: k for k, v in EXCHANGE_TIGER2VT.items()}

# 老虎证券K线周期映射
INTERVAL_VT2TIGER: Dict[Interval, str] = {
    Interval.MINUTE: "min",
    Interval.HOUR: "hour",
    Interval.DAILY: "day",
    Interval.WEEKLY: "week",
}

# 老虎证券产品类型映射
PRODUCT_TIGER2VT: Dict[str, Product] = {
    "STK": Product.EQUITY,
    "OPT": Product.OPTION,
    "FUT": Product.FUTURES,
    "WAR": Product.WARRANT,
    "CASH": Product.FOREX
}

# 老虎证券订单类型映射
ORDERTYPE_VT2TIGER: Dict[OrderType, str] = {
    OrderType.LIMIT: "LMT",
    OrderType.MARKET: "MKT",
}
ORDERTYPE_TIGER2VT: Dict[str, OrderType] = {v: k for k, v in ORDERTYPE_VT2TIGER.items()}

# 老虎证券订单状态映射
STATUS_TIGER2VT: Dict[str, Status] = {
    "Submitted": Status.SUBMITTING,
    "Filled": Status.ALLTRADED,
    "Cancelled": Status.CANCELLED,
    "Inactive": Status.REJECTED,
    "PendingSubmit": Status.SUBMITTING,
    # "PendingCancel": Status.CANCELLING,  # 注释掉不存在的属性
    "PendingCancel": Status.CANCELLED,  # 使用CANCELLED替代
    "Partial": Status.PARTTRADED,
    "Rejected": Status.REJECTED,
}

# 老虎证券方向映射
DIRECTION_VT2TIGER: Dict[Direction, str] = {
    Direction.LONG: "BUY",
    Direction.SHORT: "SELL",
}
DIRECTION_TIGER2VT: Dict[str, Direction] = {v: k for k, v in DIRECTION_VT2TIGER.items()}


class TigerGateway(BaseGateway):
    """
    VeighNa用于对接老虎证券的交易接口。
    """

    default_name: str = "TIGER"

    default_setting: Dict[str, Any] = {
        "tiger_id": "",
        "account": "",
        "private_key": "",
        "server": ["标准", "环球", "模拟"],
        "language": ["中文", "英文"],
    }

    exchanges: List[Exchange] = list(EXCHANGE_VT2TIGER.keys())

    def __init__(self, event_engine: EventEngine, gateway_name: str) -> None:
        """构造函数"""
        super().__init__(event_engine, gateway_name)

        self.tiger_id: str = ""
        self.account: str = ""
        self.server: str = ""
        self.language: str = ""
        self.private_key: str = ""

        self.quote_client: Optional[QuoteClient] = None
        self.trade_client: Optional[TradeClient] = None
        self.push_client: Optional[PushClient] = None

        self.local_orderids: Set[str] = set()
        self.orderid_tiger2vt: Dict[str, str] = {}
        self.orderid_vt2tiger: Dict[str, str] = {}

        self.subscribed: Set[str] = set()
        self.symbol_exchange_map: Dict[str, Exchange] = {}

        self.thread_quote: Thread = Thread(target=self.query_quote)
        self.thread_quote_started: bool = False
        self.thread_quote_interval: int = 10

        self.thread_trade: Thread = Thread(target=self.query_trade)
        self.thread_trade_started: bool = False
        self.thread_trade_interval: int = 10

    def connect(self, setting: Dict[str, str]) -> None:
        """连接交易接口"""
        self.tiger_id = setting["tiger_id"]
        self.account = setting["account"]
        self.private_key = setting["private_key"]

        server = setting["server"]
        if server == "标准":
            self.server = "standard"
        elif server == "环球":
            self.server = "global"
        else:
            self.server = "paper"

        language = setting["language"]
        if language == "中文":
            self.language = Language.zh_CN
        else:
            self.language = Language.en_US

        # 创建老虎证券客户端
        config = TigerOpenClientConfig()
        config.tiger_id = self.tiger_id
        config.account = self.account
        config.private_key = read_private_key(self.private_key)
        config.language = self.language

        self.quote_client = QuoteClient(config)
        self.trade_client = TradeClient(config)
        self.push_client = PushClient(config)

        # 查询合约信息
        self.query_contract()

        # 查询账户资金
        self.query_account()

        # 查询持仓
        self.query_position()

        # 查询委托
        self.query_order()

        # 启动行情查询线程
        if not self.thread_quote_started:
            self.thread_quote_started = True
            self.thread_quote.start()

        # 启动交易查询线程
        if not self.thread_trade_started:
            self.thread_trade_started = True
            self.thread_trade.start()

        self.write_log("交易接口连接成功")

    def subscribe(self, req: SubscribeRequest) -> None:
        """订阅行情"""
        if req.symbol in self.subscribed:
            return

        # 缓存合约和交易所的映射关系
        self.symbol_exchange_map[req.symbol] = req.exchange

        # 订阅行情
        symbols = [req.symbol]
        self.quote_client.subscribe_quote(symbols)

        # 订阅推送
        self.push_client.subscribe_quote(symbols)
        self.push_client.quote_changed = self.on_quote_changed

        self.subscribed.add(req.symbol)

    def send_order(self, req: OrderRequest) -> str:
        """委托下单"""
        # 生成本地委托号
        orderid = req.symbol + "_" + str(time.time())
        self.local_orderids.add(orderid)

        # 创建委托请求
        tiger_req = {
            "account": self.account,
            "contract": {
                "symbol": req.symbol,
                "exchange": EXCHANGE_VT2TIGER[req.exchange],
                "sec_type": "STK"
            },
            "action": DIRECTION_VT2TIGER[req.direction],
            "order_type": ORDERTYPE_VT2TIGER[req.type],
            "quantity": req.volume,
            "limit_price": req.price
        }

        # 发送委托请求
        try:
            result = self.trade_client.place_order(tiger_req)
            tiger_orderid = str(result.order_id)
            self.orderid_tiger2vt[tiger_orderid] = orderid
            self.orderid_vt2tiger[orderid] = tiger_orderid
            return orderid
        except Exception as e:
            self.write_log(f"委托失败：{e}")
            return ""

    def cancel_order(self, req: CancelRequest) -> None:
        """委托撤单"""
        if req.orderid not in self.orderid_vt2tiger:
            self.write_log(f"撤单失败：找不到委托号{req.orderid}")
            return

        tiger_orderid = self.orderid_vt2tiger[req.orderid]

        try:
            self.trade_client.cancel_order(tiger_orderid)
        except Exception as e:
            self.write_log(f"撤单失败：{e}")

    def query_account(self) -> None:
        """查询账户资金"""
        try:
            assets = self.trade_client.get_assets()
            for asset in assets:
                account = AccountData(
                    accountid=self.account,
                    balance=asset.net_liquidation,
                    frozen=asset.net_liquidation - asset.available_funds,
                    gateway_name=self.gateway_name
                )
                self.on_account(account)
        except Exception as e:
            self.write_log(f"查询账户资金失败：{e}")

    def query_position(self) -> None:
        """查询持仓"""
        try:
            positions = self.trade_client.get_positions()
            for position in positions:
                pos = PositionData(
                    symbol=position.contract.symbol,
                    exchange=EXCHANGE_TIGER2VT.get(position.contract.exchange, Exchange.SMART),
                    direction=Direction.LONG if position.quantity > 0 else Direction.SHORT,
                    volume=abs(position.quantity),
                    price=position.average_cost,
                    gateway_name=self.gateway_name
                )
                self.on_position(pos)
        except Exception as e:
            self.write_log(f"查询持仓失败：{e}")

    def query_order(self) -> None:
        """查询委托"""
        try:
            orders = self.trade_client.get_orders()
            for order in orders:
                orderid = str(order.order_id)
                if orderid not in self.orderid_tiger2vt:
                    local_orderid = orderid
                    self.orderid_tiger2vt[orderid] = local_orderid
                    self.orderid_vt2tiger[local_orderid] = orderid
                else:
                    local_orderid = self.orderid_tiger2vt[orderid]

                order_data = OrderData(
                    symbol=order.contract.symbol,
                    exchange=EXCHANGE_TIGER2VT.get(order.contract.exchange, Exchange.SMART),
                    orderid=local_orderid,
                    type=ORDERTYPE_TIGER2VT.get(order.order_type, OrderType.LIMIT),
                    direction=DIRECTION_TIGER2VT.get(order.action, Direction.LONG),
                    price=order.limit_price,
                    volume=order.quantity,
                    traded=order.filled,
                    status=STATUS_TIGER2VT.get(order.status, Status.SUBMITTING),
                    datetime=datetime.fromtimestamp(order.order_time / 1000),
                    gateway_name=self.gateway_name
                )
                self.on_order(order_data)
        except Exception as e:
            self.write_log(f"查询委托失败：{e}")

    def query_contract(self) -> None:
        """查询合约"""
        # 查询美股合约
        try:
            symbols = self.quote_client.get_symbols(Market.ALL)
            for symbol in symbols:
                contract = ContractData(
                    symbol=symbol.symbol,
                    exchange=EXCHANGE_TIGER2VT.get(symbol.exchange, Exchange.SMART),
                    name=symbol.name,
                    product=PRODUCT_TIGER2VT.get(symbol.sec_type, Product.EQUITY),
                    size=1,
                    pricetick=0.01,
                    gateway_name=self.gateway_name
                )
                self.on_contract(contract)
            self.write_log("合约信息查询成功")
        except Exception as e:
            self.write_log(f"查询合约失败：{e}")

    def query_history(self, req: HistoryRequest) -> List[BarData]:
        """查询历史数据"""
        # 转换时间格式
        start_time = int(req.start.timestamp() * 1000)
        end_time = int(req.end.timestamp() * 1000)

        # 创建查询请求
        bar_req = QuoteBarRequest(
            symbol=req.symbol,
            period=INTERVAL_VT2TIGER[req.interval],
            begin_time=start_time,
            end_time=end_time
        )

        # 查询历史数据
        try:
            response = self.quote_client.get_bars(bar_req)
            bars = []

            # 适配tigeropen 3.3.5版本
            if hasattr(response, 'bars') and not response.bars.empty:
                for _, row in response.bars.iterrows():
                    dt = datetime.fromtimestamp(row['time'] / 1000)
                    bar_data = BarData(
                        symbol=req.symbol,
                        exchange=req.exchange,
                        datetime=dt,
                        interval=req.interval,
                        volume=row['volume'],
                        open_price=row['open'],
                        high_price=row['high'],
                        low_price=row['low'],
                        close_price=row['close'],
                        gateway_name=self.gateway_name
                    )
                    bars.append(bar_data)
            return bars
        except Exception as e:
            self.write_log(f"查询历史数据失败：{e}")
            return []

    def close(self) -> None:
        """关闭连接"""
        if self.thread_quote_started:
            self.thread_quote_started = False
            self.thread_quote.join()

        if self.thread_trade_started:
            self.thread_trade_started = False
            self.thread_trade.join()

    def query_quote(self) -> None:
        """查询行情"""
        while self.thread_quote_started:
            try:
                for symbol in self.subscribed:
                    exchange = self.symbol_exchange_map.get(symbol, Exchange.SMART)
                    tick = self.quote_client.get_latest_quote([symbol])
                    if not tick or not tick.items:
                        continue

                    for item in tick.items:
                        tick_data = TickData(
                            symbol=item.symbol,
                            exchange=exchange,
                            name=item.symbol,
                            volume=item.volume,
                            last_price=item.latest_price,
                            datetime=datetime.fromtimestamp(item.latest_time / 1000),
                            gateway_name=self.gateway_name
                        )
                        self.on_tick(tick_data)
            except Exception as e:
                self.write_log(f"查询行情失败：{e}")

            time.sleep(self.thread_quote_interval)

    def query_trade(self) -> None:
        """查询交易"""
        while self.thread_trade_started:
            try:
                self.query_account()
                self.query_position()
                self.query_order()
            except Exception as e:
                self.write_log(f"查询交易失败：{e}")

            time.sleep(self.thread_trade_interval)

    def on_quote_changed(self, tiger_tick: QuoteTick) -> None:
        """行情推送回调"""
        symbol = tiger_tick.symbol
        exchange = self.symbol_exchange_map.get(symbol, Exchange.SMART)

        tick = TickData(
            symbol=symbol,
            exchange=exchange,
            name=symbol,
            volume=tiger_tick.volume,
            last_price=tiger_tick.latest_price,
            datetime=datetime.fromtimestamp(tiger_tick.latest_time / 1000),
            gateway_name=self.gateway_name
        )
        self.on_tick(tick)

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/vnpy_tiger/__init__.py`
*(统计信息: 2 行, 40 字符 [~0.01%])*
```python
from .tiger_gateway import TigerGateway

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/vnpy_tiger.egg-info/PKG-INFO`
*(统计信息: 33 行, 1160 字符 [~0.17%])*
```
Metadata-Version: 2.4
Name: vnpy_tiger
Version: 1.0.0
Summary: Tiger Securities gateway for VeighNa
Home-page: https://github.com/vnpy/vnpy_tiger
Author: Your Name
Author-email: your.email@example.com
License: MIT
Classifier: Development Status :: 5 - Production/Stable
Classifier: Operating System :: Microsoft :: Windows
Classifier: Operating System :: Unix
Classifier: Operating System :: POSIX
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Topic :: Office/Business :: Financial :: Investment
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: License :: OSI Approved :: MIT License
Classifier: Natural Language :: Chinese (Simplified)
Classifier: Natural Language :: Chinese (Traditional)
Classifier: Natural Language :: English
Requires-Dist: vnpy
Requires-Dist: tigeropen
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: home-page
Dynamic: license
Dynamic: requires-dist
Dynamic: summary

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/vnpy_tiger.egg-info/SOURCES.txt`
*(统计信息: 9 行, 238 字符 [~0.03%])*
```
README.md
setup.py
vnpy_tiger/__init__.py
vnpy_tiger/tiger_gateway.py
vnpy_tiger.egg-info/PKG-INFO
vnpy_tiger.egg-info/SOURCES.txt
vnpy_tiger.egg-info/dependency_links.txt
vnpy_tiger.egg-info/requires.txt
vnpy_tiger.egg-info/top_level.txt
```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/vnpy_tiger.egg-info/requires.txt`
*(统计信息: 3 行, 15 字符 [~0.00%])*
```
vnpy
tigeropen

```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/vnpy_tiger.egg-info/dependency_links.txt`
*(统计信息: 2 行, 1 字符 [~0.00%])*
```


```

### `/simpletrade/simpletrade/vendors/vnpy_tiger/vnpy_tiger.egg-info/top_level.txt`
*(统计信息: 2 行, 11 字符 [~0.00%])*
```
vnpy_tiger

```

### `/simpletrade/simpletrade/config/README.md`
*(统计信息: 192 行, 4296 字符 [~0.62%])*
```markdown
# SimpleTrade 配置包 (config)

SimpleTrade 的配置包负责管理应用程序的全局配置参数，提供统一的配置接口和数据库连接管理。

## 主要文件

1. **settings.py** - 全局配置参数
2. **database.py** - 数据库连接配置和管理

## settings.py

`settings.py` 是配置包的核心文件，定义了应用程序的全局配置参数。它主要包含以下配置：

### 1. 数据库配置 (DB_CONFIG)

```python
DB_CONFIG = {
    # 数据库连接参数
    "DB_USER": os.environ.get("SIMPLETRADE_DB_USER", "root"),
    "DB_PASSWORD": os.environ.get("SIMPLETRADE_DB_PASSWORD", "Cz159csa"),
    "DB_HOST": os.environ.get("SIMPLETRADE_DB_HOST", "localhost"),
    "DB_PORT": os.environ.get("SIMPLETRADE_DB_PORT", "3306"),
    "DB_NAME": os.environ.get("SIMPLETRADE_DB_NAME", "simpletrade"),

    # 数据库连接池配置
    "POOL_SIZE": int(os.environ.get("SIMPLETRADE_DB_POOL_SIZE", "5")),
    "MAX_OVERFLOW": int(os.environ.get("SIMPLETRADE_DB_MAX_OVERFLOW", "10")),
    "POOL_RECYCLE": int(os.environ.get("SIMPLETRADE_DB_POOL_RECYCLE", "3600")),
    "ECHO": os.environ.get("SIMPLETRADE_DB_ECHO", "False").lower() == "true",
}
```

### 2. API 配置 (API_CONFIG)

```python
API_CONFIG = {
    "HOST": os.environ.get("SIMPLETRADE_API_HOST", "0.0.0.0"),
    "PORT": int(os.environ.get("SIMPLETRADE_API_PORT", "8003")),
    "DEBUG": os.environ.get("SIMPLETRADE_API_DEBUG", "True").lower() == "true",
}
```

### 3. 日志配置 (LOG_CONFIG)

```python
LOG_CONFIG = {
    "LEVEL": os.environ.get("SIMPLETRADE_LOG_LEVEL", "INFO"),
    "FORMAT": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
}
```

### 4. 数据同步目标配置 (DATA_SYNC_TARGETS)

```python
DATA_SYNC_TARGETS = [
    {
        "source": "qlib",        # 数据源为 qlib
        "symbol": "AAPL",       # 品种代码
        "exchange": "NASDAQ",   # 交易所
        "interval": "d"         # K线周期 (日线)
    },
    # 可以添加更多目标...
]
```

## database.py

`database.py` 负责数据库连接配置和管理，主要功能包括：

1. **导入配置**：从 `settings.py` 导入数据库配置
2. **创建数据库引擎**：使用 SQLAlchemy 创建数据库引擎
3. **创建会话工厂**：提供数据库会话管理
4. **提供 Base 类**：用于创建 ORM 模型

```python
# 构建数据库连接URL
DATABASE_URL = f"mysql+pymysql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

# 创建数据库引擎
engine = create_engine(
    DATABASE_URL,
    pool_size=POOL_SIZE,
    max_overflow=MAX_OVERFLOW,
    pool_recycle=POOL_RECYCLE,
    pool_pre_ping=True,
    echo=ECHO
)

# 创建会话工厂
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 创建Base类，用于创建模型类
Base = declarative_base()

def init_db():
    """初始化数据库，创建所有表"""
    Base.metadata.create_all(bind=engine)
```

## 配置的使用方式

SimpleTrade 项目中的配置使用方式主要有以下几种：

### 1. 环境变量配置

项目支持通过环境变量覆盖默认配置，环境变量前缀为 `SIMPLETRADE_`。项目提供了 `.env.example` 文件作为模板，可以复制为 `.env` 并根据需要修改。

```bash
# 复制环境变量配置示例文件
cp .env.example .env

# 编辑环境变量配置文件
vim .env  # 或使用其他编辑器
```

### 2. 在代码中使用配置

在代码中使用配置的方式如下：

```python
# 导入配置
from simpletrade.config.settings import DB_CONFIG, API_CONFIG, LOG_CONFIG

# 使用配置
db_host = DB_CONFIG["DB_HOST"]
api_port = API_CONFIG["PORT"]
log_level = LOG_CONFIG["LEVEL"]
```

### 3. 数据库配置的使用

数据库配置主要通过 `database.py` 中的对象使用：

```python
from simpletrade.config.database import engine, SessionLocal, Base

# 使用会话
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 创建模型
class MyModel(Base):
    __tablename__ = "my_table"
    # ...
```

### 4. 与 vnpy 配置的集成

在 `main.py` 中，SimpleTrade 将自己的数据库配置同步到 vnpy 的全局配置中：

```python
from vnpy.trader.setting import SETTINGS
from simpletrade.config.settings import DB_CONFIG

# 设置 vnpy 数据库配置
SETTINGS["database.driver"] = "mysql"
SETTINGS["database.host"] = DB_CONFIG["DB_HOST"]
SETTINGS["database.port"] = int(DB_CONFIG["DB_PORT"])
SETTINGS["database.database"] = DB_CONFIG["DB_NAME"]
SETTINGS["database.user"] = DB_CONFIG["DB_USER"]
SETTINGS["database.password"] = DB_CONFIG["DB_PASSWORD"]
```

## 配置在 Docker 环境中的使用

在 Docker 环境中，配置通常通过环境变量传递，如 `docker-compose.yml` 中所示：

```yaml
environment:
  - PYTHONPATH=/app
  - SIMPLETRADE_DB_HOST=mysql
  - SIMPLETRADE_DB_PORT=3306
  - SIMPLETRADE_DB_USER=${SIMPLETRADE_DB_USER:-root}
  - SIMPLETRADE_DB_PASSWORD=${SIMPLETRADE_DB_PASSWORD:-Cz159csa}
  - SIMPLETRADE_DB_NAME=${SIMPLETRADE_DB_NAME:-simpletrade}
  - SIMPLETRADE_API_PORT=8003
```

这种设计使得配置可以在不同环境（开发、测试、生产）之间灵活切换，同时保持代码的一致性。

## 最佳实践

1. **使用环境变量**：尽量使用环境变量来配置应用程序，避免在代码中硬编码配置
2. **保持默认值合理**：为配置项提供合理的默认值，使应用程序在没有特定配置的情况下也能正常运行
3. **配置分组**：将相关的配置项分组，如数据库配置、API配置等
4. **配置文档化**：为配置项提供清晰的文档，说明其用途和可能的值
5. **敏感信息保护**：避免将敏感信息（如密码、密钥）直接存储在代码中，使用环境变量或配置文件来存储

```

### `/simpletrade/simpletrade/config/settings.py`
*(统计信息: 103 行, 3807 字符 [~0.55%])*
```python
"""
SimpleTrade 配置文件

存储应用程序的全局配置参数。
"""

import os
from pathlib import Path

# 项目根目录
PROJECT_ROOT = Path(__file__).parent.parent.parent.absolute()

# 数据库配置
DB_CONFIG = {
    # 数据库连接参数
    "DB_USER": os.environ.get("SIMPLETRADE_DB_USER", "root"),
    "DB_PASSWORD": os.environ.get("SIMPLETRADE_DB_PASSWORD", "Cz159csa"),
    "DB_HOST": os.environ.get("SIMPLETRADE_DB_HOST", "127.0.0.1"),
    "DB_PORT": os.environ.get("SIMPLETRADE_DB_PORT", "3306"),
    "DB_NAME": os.environ.get("SIMPLETRADE_DB_NAME", "simpletrade"),

    # 数据库连接池配置
    "POOL_SIZE": int(os.environ.get("SIMPLETRADE_DB_POOL_SIZE", "5")),
    "MAX_OVERFLOW": int(os.environ.get("SIMPLETRADE_DB_MAX_OVERFLOW", "10")),
    "POOL_RECYCLE": int(os.environ.get("SIMPLETRADE_DB_POOL_RECYCLE", "3600")),
    "ECHO": os.environ.get("SIMPLETRADE_DB_ECHO", "False").lower() == "true",
}

# API 配置
API_CONFIG = {
    "ENABLED": os.environ.get("SIMPLETRADE_API_ENABLED", "True").lower() == "true",
    "HOST": os.environ.get("SIMPLETRADE_API_HOST", "0.0.0.0"),
    "PORT": int(os.environ.get("SIMPLETRADE_API_PORT", "8003")),
    "DEBUG": os.environ.get("SIMPLETRADE_API_DEBUG", "True").lower() == "true",
}

# 日志配置
LOG_CONFIG = {
    "LEVEL": os.environ.get("SIMPLETRADE_LOG_LEVEL", "INFO"),
    "FORMAT": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
}

# +++ Qlib 数据路径配置 +++
# 从环境变量读取，如果未设置，则使用默认路径
_default_qlib_path = "/Users/chengzheng/.qlib/qlib_data" # <<< 设置默认路径
QLIB_DATA_PATH = os.environ.get("SIMPLETRADE_QLIB_DATA_PATH", _default_qlib_path)

if QLIB_DATA_PATH == _default_qlib_path and not os.environ.get("SIMPLETRADE_QLIB_DATA_PATH"):
    print(f"[Config] Using default Qlib data path: {QLIB_DATA_PATH}")
    print(f"[Config] (Set SIMPLETRADE_QLIB_DATA_PATH environment variable to override)")
elif QLIB_DATA_PATH != _default_qlib_path:
    print(f"[Config] Qlib data path configured via environment variable: {QLIB_DATA_PATH}")
else: # Path matches default, but was set explicitly by env var
    print(f"[Config] Qlib data path explicitly set to default via environment variable: {QLIB_DATA_PATH}")

# 可以在这里添加路径存在性检查（可选）
# if not os.path.exists(QLIB_DATA_PATH):
#     print(f"[Config Warning] Qlib data path does not exist: {QLIB_DATA_PATH}")

# +++ 结束 Qlib 配置 +++

# 数据同步服务配置
DATA_SYNC_CONFIG = {
    "ENABLED": os.environ.get("SIMPLETRADE_DATA_SYNC_ENABLED", "False").lower() == "true",
    "SYNC_ON_STARTUP": os.environ.get("SIMPLETRADE_SYNC_ON_STARTUP", "True").lower() == "true",
    "SYNC_INTERVAL": int(os.environ.get("SIMPLETRADE_SYNC_INTERVAL", "86400")),  # 默认每天同步一次（单位：秒）
    "MAX_RETRIES": int(os.environ.get("SIMPLETRADE_SYNC_MAX_RETRIES", "3")),  # 同步失败最大重试次数
    "PERIODIC_SYNC": os.environ.get("SIMPLETRADE_PERIODIC_SYNC", "False").lower() == "true",  # 是否启用周期性同步
}

# 数据同步目标配置
# 列表中的每个字典定义一个同步目标
DATA_SYNC_TARGETS = [
    {
        "source": "qlib",        # 数据源类型
        "symbol": "AAPL",        # 品种代码
        "exchange": "NASDAQ",    # 交易所 (使用 VnPy 枚举值对应的字符串)
        "interval": "d",         # K线周期 (日线)
        "start_date": "1970-01-01",  # 开始日期 (可选，默认为 "2020-01-01")
        # "end_date": "2022-12-31",  # 结束日期 (可选，默认为当前日期)
        "market": "us",          # 市场标识 (qlib 特有参数)
        "enabled": True          # 是否启用 (可选，默认为 True)
    },
    # {
    #     "source": "qlib",
    #     "symbol": "600036",    # 招商银行
    #     "exchange": "SSE",     # 上海证券交易所
    #     "interval": "d",       # 日线
    #     "market": "cn",        # 市场标识
    #     "enabled": True
    # },
    # 其他数据源示例
    # {
    #     "source": "csv",
    #     "symbol": "EURUSD",
    #     "exchange": "OANDA",
    #     "interval": "1h",
    #     "csv_path": "/data/forex/eurusd_1h.csv",  # csv 特有参数
    #     "datetime_format": "%Y-%m-%d %H:%M:%S",   # csv 特有参数
    #     "enabled": False  # 禁用此目标
    # },
]

```

### `/simpletrade/simpletrade/config/database.py`
*(统计信息: 56 行, 1288 字符 [~0.18%])*
```python
"""
数据库配置模块

提供数据库连接配置和连接池管理。
"""

import os
import logging
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from contextlib import contextmanager

# 导入配置
from simpletrade.config.settings import DB_CONFIG

# 设置日志
logger = logging.getLogger("simpletrade.config.database")

# 从配置文件获取数据库连接参数
DB_USER = DB_CONFIG["DB_USER"]
DB_PASSWORD = DB_CONFIG["DB_PASSWORD"]
DB_HOST = DB_CONFIG["DB_HOST"]
DB_PORT = DB_CONFIG["DB_PORT"]
DB_NAME = DB_CONFIG["DB_NAME"]
POOL_SIZE = DB_CONFIG["POOL_SIZE"]
MAX_OVERFLOW = DB_CONFIG["MAX_OVERFLOW"]
POOL_RECYCLE = DB_CONFIG["POOL_RECYCLE"]
ECHO = DB_CONFIG["ECHO"]

# 构建数据库连接URL
DATABASE_URL = f"mysql+pymysql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

# 记录数据库连接信息
logger.info(f"Connecting to database: {DB_HOST}:{DB_PORT}/{DB_NAME} as {DB_USER}")

# 创建数据库引擎
engine = create_engine(
    DATABASE_URL,
    pool_size=POOL_SIZE,
    max_overflow=MAX_OVERFLOW,
    pool_recycle=POOL_RECYCLE,
    pool_pre_ping=True,
    echo=ECHO  # 设置为True可以查看SQL语句
)

# 创建会话工厂
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 创建Base类，用于创建模型类
Base = declarative_base()

def init_db():
    """初始化数据库，创建所有表"""
    Base.metadata.create_all(bind=engine)

```

### `/simpletrade/simpletrade/strategies/__init__.py`
*(统计信息: 196 行, 5268 字符 [~0.75%])*
```python
"""
策略注册模块

导入所有可用的策略类，并提供策略查找功能。
支持动态发现和注册策略。
"""

import os
import importlib
import inspect
import logging
from typing import Dict, List, Type, Any, Optional

# 导入 vnpy 内置策略
from vnpy_ctastrategy.strategies.atr_rsi_strategy import AtrRsiStrategy
from vnpy_ctastrategy.strategies.boll_channel_strategy import BollChannelStrategy
from vnpy_ctastrategy.strategies.double_ma_strategy import DoubleMaStrategy
from vnpy_ctastrategy.strategies.turtle_signal_strategy import TurtleSignalStrategy
from vnpy_ctastrategy.template import CtaTemplate

# 导入自定义策略
# 如果有自定义策略，可以在这里导入
# from .moving_average_strategy import MovingAverageStrategy

logger = logging.getLogger("simpletrade.strategies")

# 策略字典，用于查找策略类
STRATEGY_CLASS_MAP = {
    "AtrRsiStrategy": AtrRsiStrategy,
    "BollChannelStrategy": BollChannelStrategy,
    "DoubleMaStrategy": DoubleMaStrategy,
    "TurtleSignalStrategy": TurtleSignalStrategy,
    # 添加自定义策略
    # "MovingAverageStrategy": MovingAverageStrategy,
}

# 策略分类
STRATEGY_CATEGORIES = {
    "AtrRsiStrategy": "技术指标",
    "BollChannelStrategy": "通道突破",
    "DoubleMaStrategy": "均线",
    "TurtleSignalStrategy": "趋势跟踪",
}

# 策略描述
STRATEGY_DESCRIPTIONS = {
    "AtrRsiStrategy": "结合ATR和RSI指标的策略，ATR用于止损，RSI用于入场信号",
    "BollChannelStrategy": "布林通道策略，通道上轨突破做多，下轨突破做空",
    "DoubleMaStrategy": "双均线策略，快线上穿慢线做多，下穿做空",
    "TurtleSignalStrategy": "海龟交易法则，基于唐奇安通道的趋势跟踪策略",
}

def discover_strategies():
    """
    自动发现并注册策略类

    扫描当前目录下的所有Python文件，查找继承自CtaTemplate的类，并注册为策略

    Returns:
        Dict[str, Type]: 发现的策略类字典
    """
    discovered = {}

    # 获取当前目录
    current_dir = os.path.dirname(os.path.abspath(__file__))

    # 遍历当前目录下的所有Python文件
    for filename in os.listdir(current_dir):
        if filename.endswith(".py") and filename != "__init__.py":
            module_name = filename[:-3]  # 去掉.py后缀

            try:
                # 导入模块
                module = importlib.import_module(f"simpletrade.strategies.{module_name}")

                # 查找模块中的所有类
                for name, obj in inspect.getmembers(module, inspect.isclass):
                    # 检查是否是策略类（继承自CtaTemplate且不是CtaTemplate本身）
                    if (issubclass(obj, CtaTemplate) and
                        obj != CtaTemplate and
                        obj.__module__ == module.__name__):

                        discovered[name] = obj
                        logger.info(f"发现策略类: {name}")
            except Exception as e:
                logger.error(f"加载策略模块 {module_name} 失败: {e}")

    return discovered

def register_strategy(class_name: str, strategy_class: Type,
                     category: str = "未分类", description: str = ""):
    """
    注册策略类

    Args:
        class_name (str): 策略类名
        strategy_class (Type): 策略类
        category (str, optional): 策略分类. 默认为"未分类"
        description (str, optional): 策略描述. 默认为空字符串
    """
    STRATEGY_CLASS_MAP[class_name] = strategy_class
    STRATEGY_CATEGORIES[class_name] = category
    STRATEGY_DESCRIPTIONS[class_name] = description
    logger.info(f"注册策略类: {class_name}, 分类: {category}")

def get_strategy_class(class_name: str) -> Optional[Type]:
    """
    根据策略类名获取策略类

    Args:
        class_name (str): 策略类名

    Returns:
        Type: 策略类，如果找不到则返回None
    """
    return STRATEGY_CLASS_MAP.get(class_name)

def get_strategy_class_names() -> List[str]:
    """
    获取所有可用的策略类名

    Returns:
        List[str]: 策略类名列表
    """
    return list(STRATEGY_CLASS_MAP.keys())

def get_strategy_category(class_name: str) -> str:
    """
    获取策略分类

    Args:
        class_name (str): 策略类名

    Returns:
        str: 策略分类，如果找不到则返回"未分类"
    """
    return STRATEGY_CATEGORIES.get(class_name, "未分类")

def get_strategy_description(class_name: str) -> str:
    """
    获取策略描述

    Args:
        class_name (str): 策略类名

    Returns:
        str: 策略描述，如果找不到则返回空字符串
    """
    return STRATEGY_DESCRIPTIONS.get(class_name, "")

def get_strategy_class_details() -> List[Dict[str, Any]]:
    """
    获取所有策略类的详细信息

    Returns:
        List[Dict[str, Any]]: 策略类详细信息列表，每个元素包含类名、参数等信息
    """
    details = []
    for class_name, strategy_class in STRATEGY_CLASS_MAP.items():
        # 获取策略参数
        parameters = getattr(strategy_class, "parameters", [])
        # 获取策略变量
        variables = getattr(strategy_class, "variables", [])

        # 获取参数默认值
        param_values = {}
        param_types = {}
        param_descriptions = {}

        for param in parameters:
            # 获取默认值
            param_values[param] = getattr(strategy_class, param, None)

            # 尝试获取参数类型和描述（如果有的话）
            param_types[param] = "number"  # 默认类型
            param_descriptions[param] = f"{param}参数"  # 默认描述

        details.append({
            "class_name": class_name,
            "category": get_strategy_category(class_name),
            "description": get_strategy_description(class_name),
            "parameters": parameters,
            "variables": variables,
            "default_values": param_values,
            "param_types": param_types,
            "param_descriptions": param_descriptions
        })

    return details

# 自动发现并注册策略
discovered_strategies = discover_strategies()
for name, cls in discovered_strategies.items():
    if name not in STRATEGY_CLASS_MAP:
        register_strategy(name, cls)

```

### `/simpletrade/simpletrade/strategies/DoubleMaStrategy.py`
*(统计信息: 127 行, 2866 字符 [~0.41%])*
```python
"""
移动平均线策略

基于双均线的交易策略，当快速均线上穿慢速均线时做多，下穿时做空。
"""

# from vnpy.app.cta_strategy.template import CtaTemplate
from vnpy_ctastrategy.template import CtaTemplate
from vnpy.trader.object import BarData
from vnpy.trader.constant import Interval, Direction
from vnpy.trader.utility import ArrayManager


class DoubleMaStrategy(CtaTemplate):
    """
    移动平均线策略

    当快速均线上穿慢速均线时做多，下穿时做空。
    """

    author = "SimpleTrade"

    # 策略参数
    fast_window = 10
    slow_window = 20

    # 策略变量
    fast_ma0 = 0.0
    fast_ma1 = 0.0
    slow_ma0 = 0.0
    slow_ma1 = 0.0

    # 参数列表，用于UI显示
    parameters = ["fast_window", "slow_window"]

    # 变量列表，用于UI显示
    variables = ["fast_ma0", "fast_ma1", "slow_ma0", "slow_ma1"]

    def __init__(self, cta_engine, strategy_name, setting):
        """
        初始化

        参数:
            cta_engine (CtaEngine): CTA策略引擎
            strategy_name (str): 策略实例名称
            setting (dict): 策略参数设置
        """
        super().__init__(cta_engine, strategy_name, setting)

        # 确保参数为整数类型
        if "fast_window" in setting:
            self.fast_window = int(self.fast_window)
        if "slow_window" in setting:
            self.slow_window = int(self.slow_window)

        # 创建K线时间序列管理工具
        self.am = ArrayManager()

    def on_init(self):
        """
        策略初始化
        """
        self.write_log("策略初始化")

        # 加载历史数据，用于初始化指标
        self.load_bar(10)

    def on_start(self):
        """
        策略启动
        """
        self.write_log("策略启动")

    def on_stop(self):
        """
        策略停止
        """
        self.write_log("策略停止")

    def on_tick(self, tick):
        """
        Tick更新
        """
        self.bg.update_tick(tick)

    def on_bar(self, bar):
        """
        K线更新
        """
        am = self.am
        am.update_bar(bar)

        # 更新指标
        if not am.inited:
            return

        # 计算快速均线
        self.fast_ma1 = self.fast_ma0
        self.fast_ma0 = am.sma(int(self.fast_window))

        # 计算慢速均线
        self.slow_ma1 = self.slow_ma0
        self.slow_ma0 = am.sma(int(self.slow_window))

        # 判断是否完成了指标初始化
        if not self.fast_ma1 or not self.slow_ma1:
            return

        # 当前持仓
        pos = self.pos

        # 金叉做多
        if self.fast_ma0 > self.slow_ma0 and self.fast_ma1 < self.slow_ma1:
            # 如果当前持空仓，先平仓
            if pos < 0:
                self.cover(bar.close_price, abs(pos))
            # 做多
            self.buy(bar.close_price, 1)

        # 死叉做空
        elif self.fast_ma0 < self.slow_ma0 and self.fast_ma1 > self.slow_ma1:
            # 如果当前持多仓，先平仓
            if pos > 0:
                self.sell(bar.close_price, abs(pos))
            # 做空
            self.short(bar.close_price, 1)

```

### `/simpletrade/simpletrade/models/database.py`
*(统计信息: 148 行, 5751 字符 [~0.82%])*
```python
"""
数据库模型模块

定义SQLAlchemy ORM模型。
"""

import json
from datetime import datetime
from sqlalchemy import Column, Integer, String, Text, Boolean, Float, DateTime, ForeignKey, Date, Numeric, func, Index
from sqlalchemy.orm import relationship
from sqlalchemy.types import TypeDecorator, VARCHAR

from simpletrade.config.database import Base

class JSONType(TypeDecorator):
    """自定义JSON类型"""
    impl = VARCHAR(4096)  # 指定最大长度为4096字符

    def process_bind_param(self, value, dialect):
        if value is not None:
            value = json.dumps(value)
        return value

    def process_result_value(self, value, dialect):
        if value is not None:
            value = json.loads(value)
        return value

class Symbol(Base):
    """交易品种模型"""
    __tablename__ = "symbols"

    id = Column(Integer, primary_key=True, index=True)
    symbol = Column(String(20), nullable=False)
    exchange = Column(String(20), nullable=False)
    name = Column(String(100), nullable=False)
    category = Column(String(20))
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    __table_args__ = (
        {'mysql_charset': 'utf8mb4', 'mysql_collate': 'utf8mb4_unicode_ci'},
    )

class Strategy(Base):
    """策略模型"""
    __tablename__ = "strategies"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    description = Column(Text)
    category = Column(String(50))
    type = Column(String(50), nullable=False)  # 'basic', 'advanced', 'component'
    complexity = Column(Integer, default=1)    # 1-5 复杂度评分
    resource_requirement = Column(Integer, default=1)  # 1-5 资源需求评分
    code = Column(Text)
    parameters = Column(JSONType)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    identifier = Column(String(100), index=True, nullable=True)
    strategy_type = Column(String(10), index=True, nullable=True)

    user_strategies = relationship("UserStrategy", back_populates="strategy")
    backtest_records = relationship("BacktestRecord", back_populates="strategy")

    __table_args__ = (
        {'mysql_charset': 'utf8mb4', 'mysql_collate': 'utf8mb4_unicode_ci'},
    )

class UserStrategy(Base):
    """用户策略模型"""
    __tablename__ = "user_strategies"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False)
    strategy_id = Column(Integer, ForeignKey("strategies.id"), nullable=False)
    name = Column(String(100), nullable=False)
    parameters = Column(JSONType)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    strategy = relationship("Strategy", back_populates="user_strategies")

    __table_args__ = (
        {'mysql_charset': 'utf8mb4', 'mysql_collate': 'utf8mb4_unicode_ci'},
    )

class BacktestRecord(Base):
    """回测记录模型"""
    __tablename__ = "backtest_records"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False)
    strategy_id = Column(Integer, ForeignKey("strategies.id"), nullable=False)
    symbol = Column(String(20), nullable=False)
    exchange = Column(String(20), nullable=False)
    interval = Column(String(20), nullable=False)
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=False)
    initial_capital = Column(Numeric(20, 2), nullable=False)
    final_capital = Column(Numeric(20, 2), nullable=False)
    total_return = Column(Numeric(10, 4), nullable=False)
    annual_return = Column(Numeric(10, 4))
    max_drawdown = Column(Numeric(10, 4))
    sharpe_ratio = Column(Numeric(10, 4))
    results = Column(JSONType)
    created_at = Column(DateTime, default=datetime.utcnow)

    strategy = relationship("Strategy", back_populates="backtest_records")

    __table_args__ = (
        {'mysql_charset': 'utf8mb4', 'mysql_collate': 'utf8mb4_unicode_ci'},
    )

class DataImportLog(Base):
    """数据导入日志/状态表"""
    __tablename__ = "data_import_log"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    source = Column(String(50), nullable=False, index=True, comment="数据来源 (e.g., 'qlib', 'csv', 'yahoo')")
    symbol = Column(String(50), nullable=False, index=True)
    exchange = Column(String(50), nullable=False, index=True)
    interval = Column(String(10), nullable=False, index=True)
    # 记录从源导入到VnPy数据库的数据开始日期
    last_begin_date = Column(DateTime, nullable=True, comment="导入数据的开始日期")
    # 记录从源导入到VnPy数据库的数据结束日期
    last_end_date = Column(DateTime, nullable=True, comment="导入数据的结束日期")
    # 记录上次尝试同步的时间
    last_attempt_time = Column(DateTime, server_default=func.now(), onupdate=func.now(), comment="上次尝试同步时间")
    # 记录同步状态 (e.g., 'idle', 'syncing', 'success', 'failed')
    status = Column(String(20), nullable=False, default='idle', comment="同步状态")
    # 记录相关信息或错误消息
    message = Column(String(500), nullable=True, comment="同步消息或错误")

    __table_args__ = (
        # 创建联合唯一索引确保同一来源/品种/交易所/周期的记录唯一
        Index('uix_data_import_target', 'source', 'symbol', 'exchange', 'interval', unique=True),
        {'mysql_charset': 'utf8mb4', 'mysql_collate': 'utf8mb4_unicode_ci'},
    )

    def __repr__(self):
        return f"<DataImportLog(source='{self.source}', symbol='{self.symbol}', exchange='{self.exchange}', interval='{self.interval}', range='{self.last_begin_date} to {self.last_end_date}', status='{self.status}')>"

# 注意: 添加新模型后, 可能需要数据库迁移 (如果使用 Alembic) 或手动创建表。

```

### `/simpletrade/simpletrade/models/__init__.py`
*(统计信息: 2 行, 30 字符 [~0.00%])*
```python
# Data models for SimpleTrade

```

### `/simpletrade/web-frontend/README.md`
*(统计信息: 65 行, 875 字符 [~0.13%])*
```markdown
# SimpleTrade Web 前端

这是 SimpleTrade 的 Web 前端项目，使用 Vue.js 开发。

## 功能

- 数据管理：查看、导入、导出和删除交易数据
- 数据分析：计算技术指标和运行策略回测
- 可视化展示：K线图、技术指标图和回测结果

## 技术栈

- Vue.js 2.x
- Element UI
- ECharts
- Axios

## 安装与运行

### 安装依赖

```bash
cd web-frontend
npm install
```

### 开发模式运行

```bash
npm run serve
```

### 构建生产版本

```bash
npm run build
```

## 项目结构

```
web-frontend/
├── public/              # 静态资源
├── src/                 # 源代码
│   ├── api/             # API接口
│   ├── components/      # 组件
│   ├── views/           # 视图
│   ├── App.vue          # 根组件
│   ├── main.js          # 入口文件
│   ├── router/          # 路由配置
│   └── store/           # Vuex状态管理
└── package.json         # 项目配置
```

## 使用说明

1. 确保后端API服务已启动（默认地址：http://localhost:8000）
2. 启动前端开发服务器
3. 在浏览器中访问 http://localhost:8080

## 注意事项

- 本项目需要与SimpleTrade后端API配合使用
- 默认API地址为 http://localhost:8000，如需修改请更新 src/api 目录下的文件

```

### `/simpletrade/web-frontend/vue.config.js`
*(统计信息: 19 行, 431 字符 [~0.06%])*
```javascript
module.exports = {
  lintOnSave: false,
  devServer: {
    host: '0.0.0.0',
    port: 8080,
    public: 'http://localhost:8080',
    sockHost: 'localhost',
    sockPort: 8080,
    // 可选：如果需要代理 API 请求到后端容器，取消下面的注释并调整
    // proxy: {
    //   '/api': {
    //     target: 'http://api:8003', // 'api' 是后端服务名, 8003 是端口
    //     changeOrigin: true,
    //     // pathRewrite: { '^/api': '/api' } // 如果需要路径重写
    //   }
    // }
  }
}

```

### `/simpletrade/web-frontend/babel.config.js`
*(统计信息: 8 行, 140 字符 [~0.02%])*
```javascript
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ],
  plugins: [
    '@babel/plugin-transform-optional-chaining'
  ]
};
```

### `/simpletrade/web-frontend/src/App.vue`
*(统计信息: 51 行, 778 字符 [~0.11%])*
```
<template>
  <div id="app">
    <MainLayout>
      <router-view />
    </MainLayout>
  </div>
</template>

<script>
import MainLayout from '@/components/MainLayout.vue'

export default {
  name: 'App',
  components: {
    MainLayout
  }
}
</script>

<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#app {
  height: 100%;
  width: 100%;
  overflow: hidden;
}

/* 全局滚动条样式 */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-thumb {
  background: #c0c4cc;
  border-radius: 3px;
}

::-webkit-scrollbar-track {
  background: #f0f2f5;
}
</style>

```

### `/simpletrade/web-frontend/src/main.js`
*(统计信息: 19 行, 381 字符 [~0.05%])*
```javascript
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
import * as echarts from 'echarts'

Vue.use(ElementUI)
Vue.prototype.$echarts = echarts

Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')

```

### `/simpletrade/web-frontend/src/views/StrategyCenterView.vue`
*(统计信息: 1216 行, 51148 字符 [~7.32%])*
```
<template>
  <div>
    <!-- 顶部标签导航 -->
    <el-tabs v-model="activeTab" type="border-card" @tab-click="handleTabClick">
      <!-- 基础策略标签页 -->
      <el-tab-pane label="基础策略" name="basic-strategies" v-loading="strategiesLoading">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">基础策略</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-input
                placeholder="搜索策略..."
                prefix-icon="el-icon-search"
                style="width: 200px; margin-right: 10px;"
              ></el-input>
              <el-select
                placeholder="所有基础类型"
                style="width: 150px;"
                v-model="selectedBasicType"
                @change="filterBasicStrategies"
                clearable
              >
                <el-option label="所有基础类型" value="all"></el-option>
                <el-option
                  v-for="type in basicStrategyTypes"
                  :key="type"
                  :label="type"
                  :value="type"
                ></el-option>
              </el-select>
            </el-col>
          </el-row>
        </div>

        <!-- 策略卡片列表 - 遍历 filteredBasicStrategies -->
        <el-row :gutter="20" type="flex" style="flex-wrap: wrap;">
          <el-col v-if="filteredBasicStrategies.length === 0 && !strategiesLoading" :span="24" style="text-align: center; color: #909399; padding: 40px 0;">
             暂无符合条件的基础策略
          </el-col>
          <el-col v-for="strategy in filteredBasicStrategies" :key="strategy.id" :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
             <el-card shadow="hover" class="strategy-card">
               <div class="strategy-card-content">
                 <div class="strategy-card-header">
                   <h3 class="strategy-title">{{ strategy.name }}</h3>
                   <!-- Display category or type from API data -->
                   <el-tag size="small" type="primary" v-if="strategy.category">{{ strategy.category }}</el-tag>
                   <el-tag size="small" type="info" v-else-if="strategy.type">{{ strategy.type }}</el-tag>
                 </div>
                 <p class="strategy-description">{{ strategy.description || '暂无描述' }}</p>
                 <!-- Simplified display - metrics/complexity/resources from mock data are removed -->
                 <!-- Add back if API provides these -->
                <!-- <div class="strategy-metrics"> ... </div> -->
                <!-- <div class="strategy-complexity"> ... </div> -->
                <!-- <div class="strategy-resources"> ... </div> -->
                 <div class="strategy-actions">
                   <el-button type="primary" size="small" @click="navigateToDetail(strategy.id)">查看详情</el-button>
                   <!-- <el-button size="small">使用策略</el-button> --> <!-- 模板页不应有"使用" -->
                 </div>
               </div>
             </el-card>
          </el-col>
        </el-row>
      </el-tab-pane>

      <!-- 高级策略标签页 -->
      <el-tab-pane label="高级策略 (AI)" name="advanced-strategies" v-loading="strategiesLoading">
         <!-- ... (可以添加类似的搜索和过滤, 如果高级策略多的话) ... -->
         <div style="margin-bottom: 20px;">
            <el-row type="flex" justify="space-between" align="middle">
                 <el-col :span="12">
                    <h2 style="font-size: 20px; font-weight: 600; margin: 0;">高级策略 (AI)</h2>
                 </el-col>
                 <!-- Optional Filters -->
            </el-row>
         </div>
        <!-- 高级策略卡片列表 - 遍历 advancedStrategies -->
        <el-row :gutter="20" type="flex" style="flex-wrap: wrap;">
            <el-col v-if="advancedStrategies.length === 0 && !strategiesLoading" :span="24" style="text-align: center; color: #909399; padding: 40px 0;">
                 暂无高级策略数据
            </el-col>
           <el-col v-for="strategy in advancedStrategies" :key="strategy.id" :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
             <el-card shadow="hover" class="strategy-card">
               <div class="strategy-card-content">
                 <div class="strategy-card-header">
                   <h3 class="strategy-title">{{ strategy.name }}</h3>
                   <el-tag size="small" type="danger">{{ strategy.type }}</el-tag>
                 </div>
                 <p class="strategy-description">{{ strategy.description || '暂无描述' }}</p>
                 <div class="strategy-actions">
                   <el-button type="primary" size="small" @click="navigateToDetail(strategy.id)">查看详情</el-button>
                 </div>
               </div>
             </el-card>
          </el-col>
        </el-row>
      </el-tab-pane>

      <!-- 组件库标签页 -->
      <el-tab-pane label="组件库" name="component-library">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">组件库</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-input
                placeholder="搜索组件..."
                prefix-icon="el-icon-search"
                style="width: 200px; margin-right: 10px;"
              ></el-input>
            </el-col>
          </el-row>
        </div>

        <!-- 组件库子标签页 -->
        <el-tabs v-model="componentActiveTab" type="card" class="component-tabs">
          <el-tab-pane label="因子库" name="factor-library">
            <div style="margin-bottom: 20px;">
              <el-row type="flex" justify="space-between" align="middle">
                <el-col :span="12">
                  <h3 style="font-size: 18px; font-weight: 600; margin: 0;">因子库</h3>
                </el-col>
                <el-col :span="12" style="text-align: right;">
                  <el-select placeholder="因子类型" style="width: 150px;">
                    <el-option label="所有类型" value="all"></el-option>
                    <el-option label="技术因子" value="technical"></el-option>
                    <el-option label="基本面因子" value="fundamental"></el-option>
                    <el-option label="情绪因子" value="sentiment"></el-option>
                    <el-option label="AI因子" value="ai"></el-option>
                  </el-select>
                </el-col>
              </el-row>
            </div>

            <!-- 因子卡片列表 -->
            <el-row :gutter="20" type="flex" style="flex-wrap: wrap;">
              <el-col :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
                <el-card shadow="hover" class="strategy-card">
                  <div class="strategy-card-content">
                    <div class="strategy-card-header">
                      <h3 class="strategy-title">RSI动量因子</h3>
                      <el-tag size="small" type="success">技术因子</el-tag>
                    </div>
                    <p class="strategy-description">相对强弱指标(RSI)的动量因子，用于捕捉价格超买和超卖区域。</p>
                    <div class="strategy-metrics">
                      <span class="metric">信息比: <span class="metric-value positive">0.65</span></span>
                      <span class="metric">有效期: <span class="metric-value">3个月</span></span>
                    </div>
                    <div class="strategy-actions">
                      <el-button type="primary" size="small">查看详情</el-button>
                      <el-button size="small">使用因子</el-button>
                    </div>
                  </div>
                </el-card>
              </el-col>
            </el-row>
          </el-tab-pane>

          <el-tab-pane label="选股器" name="stock-picker">
            <div style="margin-bottom: 20px;">
              <el-row type="flex" justify="space-between" align="middle">
                <el-col :span="12">
                  <h3 style="font-size: 18px; font-weight: 600; margin: 0;">选股器</h3>
                </el-col>
                <el-col :span="12" style="text-align: right;">
                  <el-select placeholder="所有类型" style="width: 150px;">
                    <el-option label="所有类型" value="all"></el-option>
                    <el-option label="基本面选股" value="fundamental"></el-option>
                    <el-option label="技术面选股" value="technical"></el-option>
                    <el-option label="量化因子" value="factor"></el-option>
                    <el-option label="行业轮动" value="industry"></el-option>
                  </el-select>
                </el-col>
              </el-row>
            </div>

        <!-- 选股器卡片列表 -->
        <el-row :gutter="20" type="flex" style="flex-wrap: wrap;">
          <el-col :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
            <el-card shadow="hover" class="strategy-card">
              <div class="strategy-card-content">
                <div class="strategy-card-header">
                  <h3 class="strategy-title">价值低估选股</h3>
                  <el-tag size="small" type="success">基本面选股</el-tag>
                </div>
                <p class="strategy-description">基于市盈率、市净率等指标的低估值选股策略。</p>
                <div class="strategy-metrics">
                  <span class="metric">年化收益: <span class="metric-value positive">18.5%</span></span>
                  <span class="metric">最大回撤: <span class="metric-value negative">25.3%</span></span>
                </div>
                <div class="strategy-actions">
                  <el-button type="primary" size="small">查看详情</el-button>
                  <el-button size="small">使用选股器</el-button>
                </div>
              </div>
            </el-card>
          </el-col>

          <el-col :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
            <el-card shadow="hover" class="strategy-card">
              <div class="strategy-card-content">
                <div class="strategy-card-header">
                  <h3 class="strategy-title">动量突破选股</h3>
                  <el-tag size="small" type="warning">技术面选股</el-tag>
                </div>
                <p class="strategy-description">基于价格突破和成交量放大的技术面选股策略。</p>
                <div class="strategy-metrics">
                  <span class="metric">年化收益: <span class="metric-value positive">22.3%</span></span>
                  <span class="metric">最大回撤: <span class="metric-value negative">32.1%</span></span>
                </div>
                <div class="strategy-actions">
                  <el-button type="primary" size="small">查看详情</el-button>
                  <el-button size="small">使用选股器</el-button>
                </div>
              </div>
            </el-card>
          </el-col>

          <el-col :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
            <el-card shadow="hover" class="strategy-card">
              <div class="strategy-card-content">
                <div class="strategy-card-header">
                  <h3 class="strategy-title">多因子选股</h3>
                  <el-tag size="small" type="danger">量化因子</el-tag>
                </div>
                <p class="strategy-description">结合多个量化因子的综合选股策略，包括动量、价值、质量等。</p>
                <div class="strategy-metrics">
                  <span class="metric">年化收益: <span class="metric-value positive">25.8%</span></span>
                  <span class="metric">最大回撤: <span class="metric-value negative">28.5%</span></span>
                </div>
                <div class="strategy-actions">
                  <el-button type="primary" size="small">查看详情</el-button>
                  <el-button size="small">使用选股器</el-button>
                </div>
              </div>
            </el-card>
          </el-col>
        </el-row>
      </el-tab-pane>

      <el-tab-pane label="交易战法" name="trading-tactics">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h3 style="font-size: 18px; font-weight: 600; margin: 0;">交易战法</h3>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-select placeholder="所有类型" style="width: 150px;">
                <el-option label="所有类型" value="all"></el-option>
                <el-option label="缠论战法" value="chan"></el-option>
                <el-option label="道氏理论" value="dow"></el-option>
                <el-option label="波浪理论" value="wave"></el-option>
                <el-option label="古典技术分析" value="classic"></el-option>
              </el-select>
            </el-col>
          </el-row>
        </div>
        <!-- 交易战法卡片列表 -->
        <el-row :gutter="20" type="flex" style="flex-wrap: wrap;">
          <el-col :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
            <el-card shadow="hover" class="strategy-card">
              <div class="strategy-card-content">
                <div class="strategy-card-header">
                  <h3 class="strategy-title">缠论三买战法</h3>
                  <el-tag size="small" type="warning">缠论战法</el-tag>
                </div>
                <p class="strategy-description">基于缠论理论的三买点交易战法，精准把握底部买入时机。</p>
                <div class="strategy-metrics">
                  <span class="metric">胜率: <span class="metric-value positive">65%</span></span>
                  <span class="metric">年化收益: <span class="metric-value positive">28.5%</span></span>
                </div>
                <div class="strategy-actions">
                  <el-button type="primary" size="small">查看详情</el-button>
                  <el-button size="small">使用战法</el-button>
                </div>
              </div>
            </el-card>
          </el-col>

          <el-col :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
            <el-card shadow="hover" class="strategy-card">
              <div class="strategy-card-content">
                <div class="strategy-card-header">
                  <h3 class="strategy-title">道氏理论确认战法</h3>
                  <el-tag size="small" type="danger">道氏理论</el-tag>
                </div>
                <p class="strategy-description">基于道氏理论的价格与成交量相互确认的交易战法。</p>
                <div class="strategy-metrics">
                  <span class="metric">胜率: <span class="metric-value positive">58%</span></span>
                  <span class="metric">年化收益: <span class="metric-value positive">24.3%</span></span>
                </div>
                <div class="strategy-actions">
                  <el-button type="primary" size="small">查看详情</el-button>
                  <el-button size="small">使用战法</el-button>
                </div>
              </div>
            </el-card>
          </el-col>

          <el-col :xs="24" :sm="12" :md="8" :lg="8" :xl="8" style="margin-bottom: 20px;">
            <el-card shadow="hover" class="strategy-card">
              <div class="strategy-card-content">
                <div class="strategy-card-header">
                  <h3 class="strategy-title">波浪理论交易战法</h3>
                  <el-tag size="small" type="primary">波浪理论</el-tag>
                </div>
                <p class="strategy-description">基于艾略特波浪理论的交易战法，精准把握市场节奏。</p>
                <div class="strategy-metrics">
                  <span class="metric">胜率: <span class="metric-value positive">62%</span></span>
                  <span class="metric">年化收益: <span class="metric-value positive">26.7%</span></span>
                </div>
                <div class="strategy-actions">
                  <el-button type="primary" size="small">查看详情</el-button>
                  <el-button size="small">使用战法</el-button>
                </div>
              </div>
            </el-card>
          </el-col>
        </el-row>
      </el-tab-pane>
        </el-tabs>
      </el-tab-pane>

      <el-tab-pane label="策略构建器" name="builder">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">策略构建器</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-radio-group v-model="builderMode" size="small">
                <el-radio-button label="visual">可视化构建器</el-radio-button>
                <el-radio-button label="code">代码编辑器</el-radio-button>
              </el-radio-group>
            </el-col>
          </el-row>
        </div>

        <!-- 可视化构建器 -->
        <el-card shadow="hover" v-if="builderMode === 'visual'">
          <div slot="header">
            <h3 style="margin: 0; font-size: 18px; font-weight: 600;">可视化构建器</h3>
            <p style="margin: 10px 0 0; color: #606266;">使用可视化构建器创建自定义策略，无需编写代码。</p>
          </div>

          <el-form label-position="top" label-width="100px">
            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="选择策略类型">
                  <el-radio-group v-model="strategyType">
                    <el-radio label="cta">技术指标策略</el-radio>
                    <el-radio label="factor">因子策略</el-radio>
                    <el-radio label="ai">AI策略</el-radio>
                    <el-radio label="portfolio">组合策略</el-radio>
                  </el-radio-group>
                </el-form-item>

                <el-form-item label="选择指标/因子">
                  <el-checkbox-group v-model="indicators">
                    <el-checkbox label="ma">移动平均线 (MA)</el-checkbox>
                    <el-checkbox label="rsi">相对强弱指标 (RSI)</el-checkbox>
                    <el-checkbox label="macd">MACD</el-checkbox>
                    <el-checkbox label="bollinger">布林带 (Bollinger Bands)</el-checkbox>
                    <el-checkbox label="kdj">KDJ指标</el-checkbox>
                    <el-checkbox label="volume">成交量分析</el-checkbox>
                    <el-checkbox label="momentum" v-if="strategyType === 'factor'">动量因子</el-checkbox>
                    <el-checkbox label="value" v-if="strategyType === 'factor'">价值因子</el-checkbox>
                    <el-checkbox label="quality" v-if="strategyType === 'factor'">质量因子</el-checkbox>
                  </el-checkbox-group>
                </el-form-item>
              </el-col>

              <el-col :span="12">
                <el-form-item label="策略名称">
                  <el-input v-model="strategyName" placeholder="输入策略名称"></el-input>
                </el-form-item>

                <el-form-item label="MA周期" v-if="indicators.includes('ma')">
                  <el-input-number v-model="maPeriod" :min="1" :max="200"></el-input-number>
                </el-form-item>

                <el-form-item label="RSI周期" v-if="indicators.includes('rsi')">
                  <el-input-number v-model="rsiPeriod" :min="1" :max="100"></el-input-number>
                </el-form-item>

                <el-form-item label="仓位大小 (%)">
                  <el-slider v-model="positionSize" :min="1" :max="100" :step="1" show-input></el-slider>
                </el-form-item>

                <el-form-item>
                  <el-button type="primary">创建策略</el-button>
                  <el-button>预览代码</el-button>
                </el-form-item>
              </el-col>
            </el-row>
          </el-form>
        </el-card>

        <!-- 代码编辑器 -->
        <el-card shadow="hover" v-else>
          <div slot="header">
            <h3 style="margin: 0; font-size: 18px; font-weight: 600;">代码编辑器</h3>
            <p style="margin: 10px 0 0; color: #606266;">使用代码编辑器创建自定义策略，可实现更复杂的逻辑。</p>
          </div>

          <el-form label-position="top">
            <el-form-item label="策略名称">
              <el-input v-model="strategyName" placeholder="输入策略名称"></el-input>
            </el-form-item>

            <el-form-item label="策略代码">
              <div style="border: 1px solid #dcdfe6; border-radius: 4px; height: 400px; padding: 10px; background-color: #f5f7fa; font-family: monospace; overflow: auto;">
                <pre style="margin: 0;"># 策略模板
from vnpy.trader.constant import Direction
from vnpy.app.cta_strategy import (
    CtaTemplate,
    StopOrder,
    TickData,
    BarData,
    TradeData,
    OrderData
)

class MyStrategy(CtaTemplate):
    """自定义策略"""

    # 策略参数
    fast_window = 10
    slow_window = 20
    rsi_window = 14
    rsi_level = 30

    # 变量初始化
    fast_ma = 0.0
    slow_ma = 0.0
    ma_trend = 0
    rsi_value = 0.0

    def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
        super().__init__(cta_engine, strategy_name, vt_symbol, setting)

    def on_init(self):
        """Initialize strategy variables."""
        self.write_log("Strategy initialized")
        self.load_bar(10)

    def on_bar(self, bar: BarData):
        """Strategy logic on bar data update."""
        # 更新技术指标
        # 实现交易逻辑
        pass</pre>
              </div>
            </el-form-item>

            <el-form-item>
              <el-button type="primary">保存策略</el-button>
              <el-button>运行回测</el-button>
            </el-form-item>
          </el-form>
        </el-card>
      </el-tab-pane>

      <el-tab-pane label="我的策略" name="my-strategies" v-loading="myStrategiesLoading">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">我的策略</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-button type="primary" icon="el-icon-plus">新建策略</el-button>
            </el-col>
          </el-row>
        </div>

        <el-table :data="myStrategiesList" style="width: 100%" border>
          <el-table-column prop="name" label="策略名称" width="180"></el-table-column>
          <el-table-column prop="type" label="类型" width="120">
            <template slot-scope="scope">
              <el-tag size="small">{{ scope.row.type }}</el-tag>
            </template>
          </el-table-column>
          <el-table-column prop="createTime" label="创建时间" width="180"></el-table-column>
          <el-table-column prop="status" label="状态" width="120">
            <template slot-scope="scope">
              <el-tag
                :type="scope.row.status === '运行中' ? 'success' : scope.row.status === '已初始化' ? 'warning' : scope.row.status === '未加载' ? 'info' : 'danger'"
                size="small"
              >
                {{ scope.row.status }}
              </el-tag>
            </template>
          </el-table-column>
          <el-table-column label="操作">
            <template slot-scope="scope">
              <el-button size="mini" type="text" @click="handleView(scope.row)">查看</el-button> <!-- Keep View button -->
              <el-button size="mini" type="text" @click="handleBacktest(scope.row)">回测</el-button> <!-- This now triggers the new dialog -->
              <el-button size="mini" type="text" @click="handleOptimize(scope.row)">优化</el-button>
              <el-button
                size="mini"
                type="text"
                :style="{ color: scope.row.status === '运行中' ? '#F56C6C' : '#67C23A' }"
                @click="handleAction(scope.row)"
              >
                {{ scope.row.status === '运行中' ? '停止' : '启动' }}
              </el-button>
            </template>
          </el-table-column>
        </el-table>
      </el-tab-pane>
    </el-tabs>

    <!-- 策略详情对话框 (View Dialog) - REMOVE Backtest Tab -->
    <el-dialog :title="'策略详情: ' + (currentStrategy ? currentStrategy.name : '')" :visible.sync="strategyDetailVisible" width="80%">
      <el-tabs v-model="detailActiveTab">
        <!-- 策略信息标签页 -->
        <el-tab-pane label="策略信息" name="info">
          <el-descriptions :column="2" border>
            <el-descriptions-item label="策略名称">{{ currentStrategy ? currentStrategy.name : '' }}</el-descriptions-item>
            <el-descriptions-item label="策略类型">{{ currentStrategy ? currentStrategy.type : '' }}</el-descriptions-item>
            <el-descriptions-item label="创建时间">{{ currentStrategy ? currentStrategy.createTime : '' }}</el-descriptions-item>
            <el-descriptions-item label="状态">
              <el-tag :type="currentStrategy && currentStrategy.status === '运行中' ? 'success' : currentStrategy && currentStrategy.status === '待运行' ? 'warning' : 'info'" size="small">
                {{ currentStrategy ? currentStrategy.status : '' }}
              </el-tag>
            </el-descriptions-item>
          </el-descriptions>

          <div style="margin-top: 20px;">
            <h3>策略描述</h3>
            <p>这是一个基于技术指标的量化交易策略，使用移动平均线、RSI和其他指标来生成交易信号。</p>
          </div>

          <div style="margin-top: 20px;">
            <h3>策略参数</h3>
            <el-form :model="strategyParams" label-width="120px">
              <el-form-item label="短周期移动平均线">
                <el-input-number v-model="strategyParams.shortPeriod" :min="1" :max="100"></el-input-number>
              </el-form-item>
              <el-form-item label="长周期移动平均线">
                <el-input-number v-model="strategyParams.longPeriod" :min="10" :max="200"></el-input-number>
              </el-form-item>
              <el-form-item label="RSI周期">
                <el-input-number v-model="strategyParams.rsiPeriod" :min="1" :max="100"></el-input-number>
              </el-form-item>
              <el-form-item label="RSI超买线">
                <el-input-number v-model="strategyParams.rsiOverbought" :min="50" :max="100"></el-input-number>
              </el-form-item>
              <el-form-item label="RSI超卖线">
                <el-input-number v-model="strategyParams.rsiOversold" :min="0" :max="50"></el-input-number>
              </el-form-item>
              <el-form-item label="仓位大小 (%)">
                <el-slider v-model="strategyParams.positionSize" :min="1" :max="100" :step="1" show-input></el-slider>
              </el-form-item>
              <el-form-item label="止损比例 (%)">
                <el-input-number v-model="strategyParams.stopLoss" :min="0.5" :max="20" :step="0.5"></el-input-number>
              </el-form-item>
              <el-form-item label="止盈比例 (%)">
                <el-input-number v-model="strategyParams.takeProfit" :min="0.5" :max="50" :step="0.5"></el-input-number>
              </el-form-item>
              <el-form-item>
                <el-button type="primary" @click="saveStrategyParams">保存参数</el-button>
                <!-- Removed Backtest button from here -->
              </el-form-item>
            </el-form>
          </div>
        </el-tab-pane>

        <!-- Backtest标签页 - ENTIRELY REMOVED -->
        <!-- <el-tab-pane label="回测" name="backtest"> ... </el-tab-pane> -->

        <!-- 参数优化标签页 (Keep Optimize Tab for now) -->
        <el-tab-pane label="参数优化" name="optimize">
         <!-- ... (existing content for optimize tab) ... -->
        </el-tab-pane>

        <!-- 实盘交易标签页 (Keep Live Tab for now) -->
        <el-tab-pane label="实盘交易" name="live">
          <!-- ... (existing content for live tab) ... -->
        </el-tab-pane>
      </el-tabs>
       <span slot="footer" class="dialog-footer">
         <el-button @click="strategyDetailVisible = false">关闭</el-button>
      </span>
    </el-dialog>

    <!-- 新的回测配置对话框 (New Backtest Dialog) -->
    <el-dialog
      :title="'回测配置: ' + (currentBacktestStrategy ? currentBacktestStrategy.name : '')"
      :visible.sync="backtestDialogVisible"
      width="60%"
      :close-on-click-modal="false"
      v-loading="backtestDialogLoading">
      <el-form :model="backtestConfig" :inline="false" label-width="120px" class="demo-form-inline">
           <el-row :gutter="20">
               <el-col :span="12">
                   <el-form-item label="合约代码" required>
                       <el-select
                         v-model="backtestConfig.symbol"
                         filterable
                         placeholder="选择合约代码"
                         @change="onSymbolChange">
                           <el-option
                             v-for="symbol in availableSymbols"
                             :key="symbol"
                             :label="symbol"
                             :value="symbol">
                           </el-option>
                       </el-select>
                   </el-form-item>
               </el-col>
               <el-col :span="12">
                    <el-form-item label="交易所" required>
                       <el-select
                         v-model="backtestConfig.exchange"
                         filterable
                         placeholder="选择交易所"
                         @change="onExchangeChange">
                           <el-option
                             v-for="exchange in availableExchanges"
                             :key="exchange"
                             :label="exchange"
                             :value="exchange">
                           </el-option>
                       </el-select>
                   </el-form-item>
               </el-col>
           </el-row>
           <el-row :gutter="20">
                <el-col :span="12">
                   <el-form-item label="K线周期" required>
                       <el-select
                         v-model="backtestConfig.interval"
                         placeholder="选择周期"
                         @change="onIntervalChange">
                           <el-option
                             v-for="interval in availableIntervals"
                             :key="interval"
                             :label="getIntervalLabel(interval)"
                             :value="interval">
                           </el-option>
                       </el-select>
                   </el-form-item>
                </el-col>
                <el-col :span="12">
                   <el-form-item label="初始资金" required>
                       <el-input-number v-model="backtestConfig.initial_capital" :min="1000" :step="10000"></el-input-number>
                   </el-form-item>
               </el-col>
           </el-row>
            <el-row :gutter="20">
               <el-col :span="12">
                    <el-form-item label="起始日期" required>
                       <el-date-picker v-model="backtestConfig.start_date" type="date" placeholder="选择日期" value-format="yyyy-MM-dd"></el-date-picker>
                   </el-form-item>
               </el-col>
               <el-col :span="12">
                   <el-form-item label="结束日期" required>
                       <el-date-picker v-model="backtestConfig.end_date" type="date" placeholder="选择日期" value-format="yyyy-MM-dd"></el-date-picker>
                   </el-form-item>
               </el-col>
           </el-row>
           <el-row :gutter="20">
               <el-col :span="12">
                   <el-form-item label="手续费率">
                        <el-input-number v-model="backtestConfig.rate" :precision="5" :step="0.0001" :min="0"></el-input-number>
                   </el-form-item>
               </el-col>
                <el-col :span="12">
                   <el-form-item label="滑点">
                       <el-input-number v-model="backtestConfig.slippage" :precision="2" :step="0.1" :min="0"></el-input-number>
                   </el-form-item>
                </el-col>
           </el-row>
            <el-row>
               <el-col :span="24">
                   <el-form-item label="自定义参数(JSON)">
                       <el-input type="textarea" :rows="3" v-model="backtestConfig.parameters_json" placeholder='可选, 输入JSON覆盖策略默认参数, 例如: {"fast_window": 5, "slow_window": 15}'></el-input>
                   </el-form-item>
               </el-col>
           </el-row>
        </el-form>

        <!-- 回测结果展示区 -->
        <div v-if="backtestResultDisplay.hasResult" style="margin-top: 20px;">
            <el-divider content-position="left">回测结果 (记录 ID: {{ backtestResultDisplay.record_id }})</el-divider>
             <el-row :gutter="20" style="margin-bottom: 20px;">
               <el-col :span="6"><el-card shadow="hover"><div style="text-align: center;"><h3 class="result-title">总收益率</h3><p class="result-value" :class="getPerfClass(backtestResultDisplay.statistics.total_return)">{{ formatPercent(backtestResultDisplay.statistics.total_return) }}</p></div></el-card></el-col>
               <el-col :span="6"><el-card shadow="hover"><div style="text-align: center;"><h3 class="result-title">年化收益率</h3><p class="result-value" :class="getPerfClass(backtestResultDisplay.statistics.annual_return)">{{ formatPercent(backtestResultDisplay.statistics.annual_return) }}</p></div></el-card></el-col>
               <el-col :span="6"><el-card shadow="hover"><div style="text-align: center;"><h3 class="result-title">最大回撤率</h3><p class="result-value negative">{{ formatPercent(backtestResultDisplay.statistics.max_drawdown) }}</p></div></el-card></el-col>
               <el-col :span="6"><el-card shadow="hover"><div style="text-align: center;"><h3 class="result-title">胜率</h3><p class="result-value">{{ formatPercent(backtestResultDisplay.statistics.win_rate) }}</p></div></el-card></el-col>
               <el-col :span="6" style="margin-top: 20px;"><el-card shadow="hover"><div style="text-align: center;"><h3 class="result-title">夏普比率</h3><p class="result-value">{{ formatNumber(backtestResultDisplay.statistics.sharpe_ratio, 2) }}</p></div></el-card></el-col>
               <el-col :span="6" style="margin-top: 20px;"><el-card shadow="hover"><div style="text-align: center;"><h3 class="result-title">盈亏比</h3><p class="result-value">{{ formatNumber(backtestResultDisplay.statistics.profit_factor, 2) }}</p></div></el-card></el-col>
               <el-col :span="6" style="margin-top: 20px;"><el-card shadow="hover"><div style="text-align: center;"><h3 class="result-title">交易次数</h3><p class="result-value">{{ backtestResultDisplay.statistics.total_trade_count }}</p></div></el-card></el-col>
           </el-row>
             <!-- TODO: Add chart and trade list if needed -->
        </div>
         <div v-else-if="!backtestDialogLoading" style="text-align: center; padding: 30px 0; color: #909399;">
            请填写回测参数并开始回测。
        </div>

      <span slot="footer" class="dialog-footer">
        <el-button @click="backtestDialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="runBacktest" :disabled="backtestDialogLoading">开始回测</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
// 导入 API 函数 - 需要添加 runStrategyBacktest
import { getStrategies, getUserStrategies, getStrategyTypes, runStrategyBacktest } from '@/api/strategies';
import { getAvailableSymbols, getAvailableExchanges, getAvailableIntervals, getBarData } from '@/api/data';
import dayjs from 'dayjs'; // 引入 dayjs 用于日期处理

export default {
  name: 'StrategyCenterView',
  data() {
    // 设置默认回测日期
    const endDate = dayjs().format('YYYY-MM-DD');
    const startDate = dayjs().subtract(3, 'month').format('YYYY-MM-DD');

    return {
      // --- Restore missing data properties for general view ---
      strategiesLoading: false,
      allStrategies: [], // All strategies fetched
      basicStrategies: [], // Filtered basic strategies (non-AI)
      advancedStrategies: [], // Filtered advanced strategies (AI)
      filteredBasicStrategies: [], // Basic strategies currently displayed after filtering
      strategyTypes: [],
      selectedBasicType: 'all',
      activeTab: 'basic-strategies', // Default active tab
      myStrategiesLoading: false,
      myStrategiesList: [],
      currentUserId: 1,
      componentActiveTab: 'factor-library', // For component library sub-tabs
      builderMode: 'visual', // For builder tab
      // --- Restore missing data properties for builder tab ---
      strategyType: 'cta', // Default value for the radio group in builder
      indicators: [],     // Default value for the checkbox group in builder
      strategyName: '',    // Default value for the strategy name input in builder
      maPeriod: 20,       // Default value for MA period input in builder
      rsiPeriod: 14,      // Default value for RSI period input in builder
      positionSize: 10,   // Default value for position size slider in builder
      // --- Keep data for Strategy Detail Dialog (View Dialog) ---
      strategyDetailVisible: false,
      currentStrategy: null,
      detailActiveTab: 'info',
      strategyParams: {},
      // --- Keep data for the NEW Backtest Dialog ---
      backtestDialogVisible: false,
      backtestDialogLoading: false,
      currentBacktestStrategy: null,
      backtestConfig: {
        symbol: '',
        exchange: '',
        interval: 'd',
        start_date: startDate,
        end_date: endDate,
        initial_capital: 100000,
        rate: 0.0001,
        slippage: 0.2,
        parameters_json: '',
        parameters: null
      },
      backtestResultDisplay: {
        hasResult: false,
        record_id: null,
        statistics: {}
      },
      // --- Keep data for Optimize and Live tabs (if still needed) ---
      optimizeParams: {
        target: 'totalReturn',
        parameters: []
      },
      optimizeResult: {
        hasResult: false,
        bestParams: {},
        paramSets: []
      },
      liveTradeRecords: [],
      // --- Add new data properties for the new backtest dialog ---
      availableSymbols: [],
      availableExchanges: [],
      availableIntervals: ['1m', '5m', '15m', '30m', '1h', '4h', 'd', 'w']
    };
  },
  computed: {
      // --- Restore missing computed property ---
      basicStrategyTypes() {
          // Ensure strategyTypes is always an array before filtering
          // Use 'basic' types from allStrategies instead of the separate API call result
          const types = new Set(this.basicStrategies.map(s => s.name)); // Assuming type comes from name for basic dropdown filter?
          return Array.from(types);
      }
      // --- (Other computed properties if any) ---
  },
  created() {
    this.fetchAllStrategiesAndGroup();
    this.fetchMyStrategies();
    this.fetchStrategyTypes();
  },
  methods: {
    // --- Restore missing methods ---
    handleTabClick(tab) {
        console.log("Tab clicked:", tab.name);
    },
    filterBasicStrategies() {
        if (this.selectedBasicType === 'all') {
            this.filteredBasicStrategies = [...this.basicStrategies]; // Create a copy
        } else {
            this.filteredBasicStrategies = this.basicStrategies.filter(s => s.type === this.selectedBasicType);
        }
         console.log("Filtered Basic Strategies:", this.filteredBasicStrategies);
    },
    // --- Keep existing methods ---
    fetchAllStrategiesAndGroup() {
      this.strategiesLoading = true;
      getStrategies()
        .then(response => {
          if (response.data && response.data.success) {
            this.allStrategies = response.data.data || [];
            this.groupStrategies();
            this.filterBasicStrategies(); // Initial filter after grouping
          } else {
            this.$message.error(response.data.message || '加载策略列表失败');
            this.allStrategies = [];
            this.basicStrategies = [];
            this.advancedStrategies = [];
            this.filteredBasicStrategies = []; // Ensure reset on error
          }
        })
        .catch(error => {
          console.error('加载策略列表错误:', error);
          this.$message.error('网络错误，无法加载策略列表');
           this.allStrategies = [];
           this.basicStrategies = [];
           this.advancedStrategies = [];
           this.filteredBasicStrategies = []; // Ensure reset on error
        })
        .finally(() => {
          this.strategiesLoading = false;
        });
    },
    groupStrategies() {
        this.basicStrategies = this.allStrategies.filter(s => s.type === 'basic'); // Changed from !== 'AI策略'
        this.advancedStrategies = this.allStrategies.filter(s => s.type === 'advanced'); // Changed from === 'AI策略'
        console.log("Basic Strategies:", this.basicStrategies);
        console.log("Advanced Strategies:", this.advancedStrategies);
    },
    fetchStrategyTypes() {
      getStrategyTypes()
        .then(response => {
          if (response.data && response.data.success) {
            // Ensure strategyTypes is always an array
            this.strategyTypes = Array.isArray(response.data.data) ? response.data.data : [];
          } else {
            this.$message.error(response.data.message || '加载策略类型失败');
            this.strategyTypes = []; // Reset on error
          }
        })
        .catch(error => {
          console.error('加载策略类型错误:', error);
          this.$message.error('网络错误，无法加载策略类型');
           this.strategyTypes = []; // Reset on error
        });
    },
    fetchMyStrategies() {
      // ... (fetchMyStrategies logic remains the same) ...
       this.myStrategiesLoading = true;
      getUserStrategies(this.currentUserId)
        .then(response => {
          if (response.data && response.data.success) {
            this.myStrategiesList = response.data.data || [];
          } else {
            this.$message.error(response.data.message || '加载我的策略列表失败');
            this.myStrategiesList = [];
          }
        })
        .catch(error => {
          console.error('加载我的策略列表错误:', error);
          this.$message.error('网络错误，无法加载我的策略列表');
          this.myStrategiesList = [];
        })
        .finally(() => {
          this.myStrategiesLoading = false;
        });
    },
    navigateToDetail(strategyId) {
      // ... (navigateToDetail logic remains the same) ...
        const idToUse = typeof strategyId === 'object' ? strategyId.id : strategyId;
        this.$router.push(`/strategy/${idToUse}`);
    },
    handleView(row) {
      // ... (handleView logic remains the same) ...
        this.currentStrategy = JSON.parse(JSON.stringify(row));
        this.strategyParams = this.currentStrategy.parameters || {};
        this.strategyDetailVisible = true;
        this.detailActiveTab = 'info';
        this.optimizeResult.hasResult = false;
    },
    handleBacktest(row) {
      this.currentBacktestStrategy = row;
      const defaultParams = row.parameters || {};

      this.backtestConfig = {
        strategy_id: row.id,
        symbol: '',
        exchange: '',
        interval: 'd',
        start_date: dayjs().subtract(3, 'month').format('YYYY-MM-DD'),
        end_date: dayjs().format('YYYY-MM-DD'),
        initial_capital: 100000,
        rate: 0.0001,
        slippage: 0.2,
        parameters_json: '',
        parameters: null,
        user_id: this.currentUserId
      };

      this.backtestResultDisplay = { hasResult: false, record_id: null, statistics: {} };
      this.backtestDialogVisible = true;
      this.backtestDialogLoading = false;

      // 加载可用的交易所列表
      this.loadAvailableExchanges();
    },
    handleOptimize(row) {
      // ... (handleOptimize logic remains the same) ...
        this.handleView(row);
        this.detailActiveTab = 'optimize';
    },
    handleAction(row) {
      // ... (handleAction logic remains the same) ...
       if (row.status === '运行中') {
        this.$confirm('确定要停止该策略吗？', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          row.status = '待运行'; // TODO: Call stop API
          this.$message({
            type: 'success',
            message: `策略 ${row.name} 已停止`
          });
          this.fetchMyStrategies();
        }).catch(() => {});
      } else {
         this.$message({
            type: 'info',
            message: `正在启动策略 ${row.name}...`
          });
         setTimeout(() => {
            row.status = '运行中'; // TODO: Call start API
            this.$message.success(`策略 ${row.name} 已启动`);
            this.fetchMyStrategies();
         }, 1000);
      }
    },
    saveStrategyParams() {
      // ... (saveStrategyParams logic remains the same) ...
       this.$message({
        type: 'success',
        message: '策略参数保存成功 (模拟)'
      });
    },
    async runBacktest() {
      if (!this.backtestConfig.symbol || !this.backtestConfig.exchange || !this.backtestConfig.interval) {
        this.$message.error('请完整填写回测参数');
        return;
      }

      this.backtestDialogLoading = true;

      try {
        // 处理自定义参数
        if (this.backtestConfig.parameters_json) {
          try {
            this.backtestConfig.parameters = JSON.parse(this.backtestConfig.parameters_json);
          } catch (e) {
            this.$message.error('自定义参数JSON格式错误');
            this.backtestDialogLoading = false;
            return;
          }
        }

        // 发送回测请求
        const response = await runStrategyBacktest(this.backtestConfig);

        if (response.data && response.data.success) {
          const result = response.data.data;
          this.backtestResultDisplay = {
            hasResult: true,
            record_id: result.id || 'N/A',
            statistics: result.statistics || {}
          };
          this.$message.success('回测运行成功');
        } else {
          this.$message.error(response.data.message || '回测失败');
        }
      } catch (error) {
        console.error('运行回测时出错:', error);
        this.$message.error(error.response?.data?.message || '回测运行失败');
      } finally {
        this.backtestDialogLoading = false;
      }
    },
    formatPercent(value) {
      if (value === undefined || value === null) return 'N/A';
      return (value * 100).toFixed(2) + '%';
    },
    formatNumber(value, precision = 2) {
      if (value === undefined || value === null) return 'N/A';
      return Number(value).toFixed(precision);
    },
    getPerfClass(value) {
      if (value === undefined || value === null) return '';
      return value >= 0 ? 'positive' : 'negative';
    },
    // 加载可用交易所列表
    async loadAvailableExchanges() {
      try {
        const response = await getAvailableExchanges();
        if (response.data && response.data.success) {
          this.availableExchanges = response.data.data || [];
        } else {
          console.error('获取交易所列表失败:', response.data.message);
          this.$message.warning('无法加载交易所列表，请手动输入');
        }
      } catch (error) {
        console.error('获取交易所列表出错:', error);
        this.$message.warning('无法加载交易所列表，请手动输入');
      }
    },
    // 加载可用合约列表
    async loadAvailableSymbols(exchange) {
      if (!exchange) return;

      try {
        const response = await getAvailableSymbols(exchange);
        if (response.data && response.data.success) {
          this.availableSymbols = response.data.data || [];
        } else {
          console.error('获取合约列表失败:', response.data.message);
          this.$message.warning('无法加载合约列表，请手动输入');
        }
      } catch (error) {
        console.error('获取合约列表出错:', error);
        this.$message.warning('无法加载合约列表，请手动输入');
      }
    },
    // 加载可用周期列表
    async loadAvailableIntervals(exchange, symbol) {
      if (!exchange || !symbol) return;

      try {
        const response = await getAvailableIntervals(symbol, exchange);
        if (response.data && response.data.success) {
          this.availableIntervals = response.data.data || ['1m', '5m', '15m', '30m', '1h', '4h', 'd', 'w'];
        } else {
          console.error('获取周期列表失败:', response.data.message);
          // 使用默认周期列表
          this.availableIntervals = ['1m', '5m', '15m', '30m', '1h', '4h', 'd', 'w'];
        }
      } catch (error) {
        console.error('获取周期列表出错:', error);
        // 使用默认周期列表
        this.availableIntervals = ['1m', '5m', '15m', '30m', '1h', '4h', 'd', 'w'];
      }
    },
    // 交易所改变时的处理
    onExchangeChange(value) {
      this.backtestConfig.symbol = ''; // 清空合约
      this.loadAvailableSymbols(value);
    },
    // 合约改变时的处理
    onSymbolChange(value) {
      if (this.backtestConfig.exchange && value) {
        this.loadAvailableIntervals(this.backtestConfig.exchange, value);
      }
    },
    // 周期改变时的处理
    onIntervalChange(value) {
      // 可以在这里添加周期相关的逻辑，比如根据周期调整起止时间等
    },
    // 获取周期显示文本
    getIntervalLabel(interval) {
      const labelMap = {
        '1m': '1分钟',
        '5m': '5分钟',
        '15m': '15分钟',
        '30m': '30分钟',
        '1h': '1小时',
        '4h': '4小时',
        'd': '日线',
        'w': '周线'
      };
      return labelMap[interval] || interval;
    }
  }
}
</script>

<style>
/* ... (existing global styles) ... */

/* Styles for result display in backtest dialog */
.result-title {
  margin: 0 0 10px;
  font-size: 14px;
  color: #606266;
  font-weight: normal;
}
.result-value {
  font-size: 20px;
  font-weight: 600;
  margin: 0;
}
.result-value.positive {
  color: #67C23A;
}
.result-value.negative {
  color: #F56C6C;
}
</style>

<style scoped>
/* Make cards have consistent height and use flex layout */
.strategy-card {
  height: 100%; /* Ensure card takes full height of the column */
  display: flex;
  flex-direction: column;
}

/* Allow card content to grow and push actions down */
.strategy-card-content {
  flex-grow: 1; /* Allow content to take available space */
  display: flex;
  flex-direction: column;
  height: 100%; /* Ensure content fills the card */
}

.strategy-card-header {
  display: flex;
  justify-content: space-between; /* Space between title and tags */
  align-items: flex-start; /* Align items to the top */
  margin-bottom: 10px;
}

.strategy-title {
  margin: 0;
  font-size: 1.1em;
  font-weight: 600;
  margin-right: 10px; /* Add some space between title and tag */
  /* Optional: Allow title to wrap if too long */
  white-space: normal;
  overflow-wrap: break-word;
}

.strategy-description {
  flex-grow: 1; /* Allow description to take up most space */
  font-size: 0.9em;
  color: #606266;
  line-height: 1.4;
  margin-bottom: 15px;
  /* Optional: Limit description lines and add ellipsis */
  /* display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis; */
}

/* Push actions to the bottom */
.strategy-actions {
  margin-top: auto; /* Push to the bottom */
  text-align: left; /* Align button to the left */
}

/* General metrics styling (if needed later) */
.strategy-metrics {
  margin-bottom: 10px;
}

.metric {
  font-size: 0.85em;
  color: #909399;
  margin-right: 15px;
}

.metric-value {
  font-weight: 600;
  color: #303133;
}

.metric-value.positive {
  color: #67C23A;
}

.metric-value.negative {
  color: #F56C6C;
}

/* Style for component library tabs */
.component-tabs {
    margin-top: 20px;
}

/* Adjust table status tag colors if needed */
/* .el-tag--success { background-color: #f0f9eb; border-color: #e1f3d8; color: #67c23a; } */
/* .el-tag--warning { background-color: #fdf6ec; border-color: #faecd8; color: #e6a23c; } */
/* .el-tag--info { background-color: #f4f4f5; border-color: #e9e9eb; color: #909399; } */
/* .el-tag--danger { background-color: #fef0f0; border-color: #fde2e2; color: #f56c6c; } */
</style>

```

### `/simpletrade/web-frontend/src/views/AIAnalysisView.vue`
*(统计信息: 521 行, 20524 字符 [~2.94%])*
```
<template>
  <div>
    <!-- 顶部标签导航 -->
    <el-tabs v-model="activeTab" type="border-card">
      <el-tab-pane label="市场分析" name="market-analysis">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">市场分析</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-select v-model="marketType" placeholder="选择市场" style="width: 150px; margin-right: 10px;">
                <el-option label="美股市场" value="us"></el-option>
                <el-option label="港股市场" value="hk"></el-option>
                <el-option label="中国市场" value="cn"></el-option>
              </el-select>
              <el-button type="primary" icon="el-icon-refresh">刷新分析</el-button>
            </el-col>
          </el-row>
        </div>

        <!-- 市场概况卡片 -->
        <el-row :gutter="20" style="margin-bottom: 20px;">
          <el-col :span="8">
            <el-card shadow="hover">
              <div slot="header" class="clearfix">
                <span>市场情绪</span>
                <el-tag style="float: right;" size="small" type="success">看涨</el-tag>
              </div>
              <div style="text-align: center;">
                <el-progress type="dashboard" :percentage="68" :color="customColors"></el-progress>
                <div style="margin-top: 10px; font-size: 14px;">
                  市场情绪偏向乐观，投资者信心指数连续三周上升。
                </div>
              </div>
            </el-card>
          </el-col>

          <el-col :span="8">
            <el-card shadow="hover">
              <div slot="header" class="clearfix">
                <span>行业趋势</span>
              </div>
              <div>
                <h4 style="margin: 0 0 15px;">领先行业</h4>
                <el-row style="margin-bottom: 10px;">
                  <el-col :span="8">科技</el-col>
                  <el-col :span="16">
                    <el-progress :percentage="85" color="#409EFF"></el-progress>
                  </el-col>
                </el-row>
                <el-row style="margin-bottom: 10px;">
                  <el-col :span="8">能源</el-col>
                  <el-col :span="16">
                    <el-progress :percentage="72" color="#67C23A"></el-progress>
                  </el-col>
                </el-row>
                <el-row style="margin-bottom: 10px;">
                  <el-col :span="8">金融</el-col>
                  <el-col :span="16">
                    <el-progress :percentage="65" color="#E6A23C"></el-progress>
                  </el-col>
                </el-row>
              </div>
            </el-card>
          </el-col>

          <el-col :span="8">
            <el-card shadow="hover">
              <div slot="header" class="clearfix">
                <span>风险评估</span>
                <el-tag style="float: right;" size="small" type="warning">中等</el-tag>
              </div>
              <div style="text-align: center;">
                <el-progress type="dashboard" :percentage="45" :color="riskColors"></el-progress>
                <div style="margin-top: 10px; font-size: 14px;">
                  市场波动性增大，建议关注利率变化和地缘政治风险。
                </div>
              </div>
            </el-card>
          </el-col>
        </el-row>

        <!-- 市场热点 -->
        <el-card shadow="hover" style="margin-bottom: 20px;">
          <div slot="header" class="clearfix">
            <span>市场热点</span>
            <el-radio-group v-model="timeFrame" size="small" style="float: right;">
              <el-radio-button label="day">日</el-radio-button>
              <el-radio-button label="week">周</el-radio-button>
              <el-radio-button label="month">月</el-radio-button>
            </el-radio-group>
          </div>
          <el-table :data="hotStocks" style="width: 100%">
            <el-table-column prop="symbol" label="股票代码" width="120"></el-table-column>
            <el-table-column prop="name" label="股票名称" width="180"></el-table-column>
            <el-table-column prop="price" label="当前价格" width="120"></el-table-column>
            <el-table-column prop="change" label="涨跌幅" width="120">
              <template slot-scope="scope">
                <span :style="{ color: scope.row.change >= 0 ? '#67C23A' : '#F56C6C' }">
                  {{ scope.row.change >= 0 ? '+' : '' }}{{ scope.row.change }}%
                </span>
              </template>
            </el-table-column>
            <el-table-column prop="volume" label="成交量" width="150"></el-table-column>
            <el-table-column prop="sentiment" label="AI情绪分析" width="150">
              <template slot-scope="scope">
                <el-tag :type="scope.row.sentiment === '看涨' ? 'success' : scope.row.sentiment === '看跌' ? 'danger' : 'info'" size="small">
                  {{ scope.row.sentiment }}
                </el-tag>
              </template>
            </el-table-column>
            <el-table-column label="操作">
              <template slot-scope="scope">
                <el-button size="mini" type="text" @click="viewStockAnalysis(scope.row)">详细分析</el-button>
                <el-button size="mini" type="text" @click="addToWatchlist(scope.row)">添加关注</el-button>
              </template>
            </el-table-column>
          </el-table>
        </el-card>
      </el-tab-pane>

      <el-tab-pane label="股票预测" name="stock-prediction">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">股票预测</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-autocomplete
                v-model="stockSearch"
                :fetch-suggestions="queryStockSearch"
                placeholder="输入股票代码或名称"
                style="width: 300px; margin-right: 10px;"
              ></el-autocomplete>
              <el-button type="primary" icon="el-icon-search" @click="generatePrediction">生成预测</el-button>
            </el-col>
          </el-row>
        </div>

        <el-card v-if="!selectedStock" shadow="hover" style="margin-bottom: 20px; text-align: center; padding: 60px 0;">
          <i class="el-icon-search" style="font-size: 48px; color: #909399; margin-bottom: 20px;"></i>
          <p style="font-size: 16px; color: #606266;">请输入股票代码或名称进行预测分析</p>
        </el-card>

        <div v-else>
          <!-- 股票基本信息 -->
          <el-card shadow="hover" style="margin-bottom: 20px;">
            <el-row :gutter="20">
              <el-col :span="6">
                <div style="text-align: center;">
                  <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">当前价格</h3>
                  <p style="font-size: 24px; font-weight: 600; color: #303133; margin: 0;">{{ selectedStock.price }}</p>
                  <div style="margin-top: 10px; font-size: 14px;" :style="{ color: selectedStock.change >= 0 ? '#67C23A' : '#F56C6C' }">
                    <i :class="selectedStock.change >= 0 ? 'el-icon-top' : 'el-icon-bottom'"></i>
                    {{ selectedStock.change >= 0 ? '+' : '' }}{{ selectedStock.change }}% 今日
                  </div>
                </div>
              </el-col>

              <el-col :span="6">
                <div style="text-align: center;">
                  <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">预测价格 (7日)</h3>
                  <p style="font-size: 24px; font-weight: 600; color: #303133; margin: 0;">{{ selectedStock.prediction7d }}</p>
                  <div style="margin-top: 10px; font-size: 14px;" :style="{ color: selectedStock.prediction7dChange >= 0 ? '#67C23A' : '#F56C6C' }">
                    <i :class="selectedStock.prediction7dChange >= 0 ? 'el-icon-top' : 'el-icon-bottom'"></i>
                    {{ selectedStock.prediction7dChange >= 0 ? '+' : '' }}{{ selectedStock.prediction7dChange }}%
                  </div>
                </div>
              </el-col>

              <el-col :span="6">
                <div style="text-align: center;">
                  <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">预测价格 (30日)</h3>
                  <p style="font-size: 24px; font-weight: 600; color: #303133; margin: 0;">{{ selectedStock.prediction30d }}</p>
                  <div style="margin-top: 10px; font-size: 14px;" :style="{ color: selectedStock.prediction30dChange >= 0 ? '#67C23A' : '#F56C6C' }">
                    <i :class="selectedStock.prediction30dChange >= 0 ? 'el-icon-top' : 'el-icon-bottom'"></i>
                    {{ selectedStock.prediction30dChange >= 0 ? '+' : '' }}{{ selectedStock.prediction30dChange }}%
                  </div>
                </div>
              </el-col>

              <el-col :span="6">
                <div style="text-align: center;">
                  <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">AI建议</h3>
                  <p style="font-size: 24px; font-weight: 600; margin: 0;">
                    <el-tag :type="selectedStock.recommendation === '买入' ? 'success' : selectedStock.recommendation === '卖出' ? 'danger' : 'warning'" size="medium">
                      {{ selectedStock.recommendation }}
                    </el-tag>
                  </p>
                  <div style="margin-top: 10px; font-size: 14px; color: #909399;">
                    置信度: {{ selectedStock.confidence }}%
                  </div>
                </div>
              </el-col>
            </el-row>
          </el-card>

          <!-- 预测图表 -->
          <el-card shadow="hover" style="margin-bottom: 20px;">
            <div slot="header" class="clearfix">
              <span>价格预测图表</span>
              <el-radio-group v-model="predictionTimeframe" size="small" style="float: right;">
                <el-radio-button label="7d">7天</el-radio-button>
                <el-radio-button label="30d">30天</el-radio-button>
                <el-radio-button label="90d">90天</el-radio-button>
              </el-radio-group>
            </div>
            <div style="height: 300px; display: flex; align-items: center; justify-content: center; color: #909399;">
              <i class="el-icon-data-line" style="font-size: 24px; margin-right: 10px;"></i>
              价格预测图表（这里将显示图表）
            </div>
          </el-card>

          <!-- 分析报告 -->
          <el-card shadow="hover">
            <div slot="header" class="clearfix">
              <span>AI分析报告</span>
            </div>
            <div>
              <h4>技术分析</h4>
              <p>{{ selectedStock.technicalAnalysis }}</p>

              <el-divider></el-divider>

              <h4>基本面分析</h4>
              <p>{{ selectedStock.fundamentalAnalysis }}</p>

              <el-divider></el-divider>

              <h4>风险因素</h4>
              <p>{{ selectedStock.riskFactors }}</p>
            </div>
          </el-card>
        </div>
      </el-tab-pane>

      <el-tab-pane label="模型训练" name="model-training">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">模型训练</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-button type="primary" icon="el-icon-plus" @click="createNewModel">新建模型</el-button>
            </el-col>
          </el-row>
        </div>

        <!-- 模型列表 -->
        <el-table :data="models" style="width: 100%" border>
          <el-table-column prop="name" label="模型名称" width="180"></el-table-column>
          <el-table-column prop="type" label="模型类型" width="150">
            <template slot-scope="scope">
              <el-tag :type="scope.row.type === 'LSTM' ? 'primary' : scope.row.type === 'CNN' ? 'success' : 'warning'" size="small">
                {{ scope.row.type }}
              </el-tag>
            </template>
          </el-table-column>
          <el-table-column prop="target" label="预测目标" width="150"></el-table-column>
          <el-table-column prop="accuracy" label="准确率" width="120">
            <template slot-scope="scope">
              <el-progress :percentage="scope.row.accuracy" :format="percentFormat"></el-progress>
            </template>
          </el-table-column>
          <el-table-column prop="lastTrained" label="上次训练时间" width="180"></el-table-column>
          <el-table-column prop="status" label="状态" width="120">
            <template slot-scope="scope">
              <el-tag :type="scope.row.status === '已部署' ? 'success' : scope.row.status === '训练中' ? 'warning' : 'info'" size="small">
                {{ scope.row.status }}
              </el-tag>
            </template>
          </el-table-column>
          <el-table-column label="操作">
            <template slot-scope="scope">
              <el-button size="mini" type="text" @click="viewModelDetails(scope.row)">查看</el-button>
              <el-button size="mini" type="text" @click="trainModel(scope.row)" :disabled="scope.row.status === '训练中'">训练</el-button>
              <el-button
                size="mini"
                type="text"
                @click="deployModel(scope.row)"
                :disabled="scope.row.status === '训练中' || scope.row.status === '已部署'"
              >
                部署
              </el-button>
            </template>
          </el-table-column>
        </el-table>
      </el-tab-pane>
    </el-tabs>

    <!-- 新建模型对话框 -->
    <el-dialog title="新建AI模型" :visible.sync="modelDialogVisible" width="50%">
      <el-form :model="newModelForm" label-width="120px">
        <el-form-item label="模型名称">
          <el-input v-model="newModelForm.name" placeholder="请输入模型名称"></el-input>
        </el-form-item>
        <el-form-item label="模型类型">
          <el-select v-model="newModelForm.type" placeholder="请选择模型类型" style="width: 100%;">
            <el-option label="LSTM (长短期记忆网络)" value="LSTM"></el-option>
            <el-option label="CNN (卷积神经网络)" value="CNN"></el-option>
            <el-option label="GRU (门控循环单元)" value="GRU"></el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="预测目标">
          <el-select v-model="newModelForm.target" placeholder="请选择预测目标" style="width: 100%;">
            <el-option label="价格预测" value="price"></el-option>
            <el-option label="趋势预测" value="trend"></el-option>
            <el-option label="波动率预测" value="volatility"></el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="训练数据">
          <el-select v-model="newModelForm.dataSource" placeholder="请选择数据源" style="width: 100%;">
            <el-option label="美股市场数据" value="us"></el-option>
            <el-option label="港股市场数据" value="hk"></el-option>
            <el-option label="中国市场数据" value="cn"></el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="训练周期">
          <el-slider v-model="newModelForm.epochs" :min="10" :max="100" :step="10" show-stops></el-slider>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="modelDialogVisible = false">取消</el-button>
        <el-button type="primary" @click="submitNewModel">创建</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
export default {
  name: 'AIAnalysisView',
  data() {
    return {
      activeTab: 'market-analysis',
      marketType: 'us',
      timeFrame: 'week',
      stockSearch: '',
      selectedStock: null,
      predictionTimeframe: '30d',
      modelDialogVisible: false,
      customColors: [
        {color: '#F56C6C', percentage: 20},
        {color: '#E6A23C', percentage: 40},
        {color: '#5CB87A', percentage: 60},
        {color: '#1989FA', percentage: 80},
        {color: '#6F7AD3', percentage: 100}
      ],
      riskColors: [
        {color: '#6F7AD3', percentage: 20},
        {color: '#1989FA', percentage: 40},
        {color: '#E6A23C', percentage: 60},
        {color: '#F56C6C', percentage: 80},
        {color: '#FF0000', percentage: 100}
      ],
      hotStocks: [
        {
          symbol: 'AAPL',
          name: 'Apple Inc.',
          price: '182.50',
          change: 2.3,
          volume: '45.2M',
          sentiment: '看涨'
        },
        {
          symbol: 'TSLA',
          name: 'Tesla, Inc.',
          price: '245.30',
          change: -1.5,
          volume: '32.8M',
          sentiment: '中性'
        },
        {
          symbol: 'NVDA',
          name: 'NVIDIA Corporation',
          price: '485.20',
          change: 3.8,
          volume: '28.5M',
          sentiment: '看涨'
        },
        {
          symbol: 'MSFT',
          name: 'Microsoft Corporation',
          price: '340.25',
          change: 1.2,
          volume: '22.1M',
          sentiment: '看涨'
        },
        {
          symbol: 'AMZN',
          name: 'Amazon.com, Inc.',
          price: '178.75',
          change: -0.8,
          volume: '18.9M',
          sentiment: '中性'
        }
      ],
      models: [
        {
          name: 'LSTM股价预测模型',
          type: 'LSTM',
          target: '价格预测',
          accuracy: 78,
          lastTrained: '2023-10-10 15:30:45',
          status: '已部署'
        },
        {
          name: 'CNN趋势识别模型',
          type: 'CNN',
          target: '趋势预测',
          accuracy: 82,
          lastTrained: '2023-10-12 09:15:20',
          status: '已训练'
        },
        {
          name: 'GRU波动率预测',
          type: 'GRU',
          target: '波动率预测',
          accuracy: 65,
          lastTrained: '2023-10-08 11:45:30',
          status: '训练中'
        }
      ],
      newModelForm: {
        name: '',
        type: '',
        target: '',
        dataSource: '',
        epochs: 50
      }
    }
  },
  methods: {
    percentFormat(percentage) {
      return `${percentage}%`;
    },
    queryStockSearch(queryString, callback) {
      const results = [
        { value: 'AAPL - Apple Inc.' },
        { value: 'MSFT - Microsoft Corporation' },
        { value: 'GOOGL - Alphabet Inc.' },
        { value: 'AMZN - Amazon.com, Inc.' },
        { value: 'TSLA - Tesla, Inc.' }
      ];
      callback(queryString ? results.filter(item => item.value.toLowerCase().includes(queryString.toLowerCase())) : results);
    },
    generatePrediction() {
      // 模拟生成预测结果
      if (this.stockSearch.includes('AAPL')) {
        this.selectedStock = {
          symbol: 'AAPL',
          name: 'Apple Inc.',
          price: '$182.50',
          change: 2.3,
          prediction7d: '$187.25',
          prediction7dChange: 2.6,
          prediction30d: '$195.80',
          prediction30dChange: 7.3,
          recommendation: '买入',
          confidence: 85,
          technicalAnalysis: 'AAPL股票目前处于上升趋势，突破了200日均线，MACD指标显示强劲的买入信号。相对强弱指标(RSI)为65，表明股票有上升动能但尚未达到超买区域。',
          fundamentalAnalysis: 'Apple公司最近财报显示营收和利润均超出市场预期，iPhone销售强劲，服务业务持续增长。公司现金储备充足，有能力继续进行股票回购和派发股息。',
          riskFactors: '全球供应链问题可能影响产品生产和交付。科技行业竞争激烈，创新压力大。监管风险增加，特别是在应用商店和隐私政策方面。'
        };
      } else if (this.stockSearch) {
        this.$message({
          message: '暂无该股票的预测数据，请尝试搜索"AAPL"',
          type: 'warning'
        });
      }
    },
    viewStockAnalysis(stock) {
      this.activeTab = 'stock-prediction';
      this.stockSearch = `${stock.symbol} - ${stock.name}`;
      this.generatePrediction();
    },
    addToWatchlist(stock) {
      this.$message({
        message: `已将 ${stock.name} 添加到关注列表`,
        type: 'success'
      });
    },
    createNewModel() {
      this.modelDialogVisible = true;
    },
    submitNewModel() {
      this.$message({
        message: '新模型创建成功，已加入训练队列',
        type: 'success'
      });
      this.modelDialogVisible = false;
    },
    viewModelDetails(model) {
      this.$message({
        message: `查看模型详情: ${model.name}`,
        type: 'info'
      });
    },
    trainModel(model) {
      this.$message({
        message: `开始训练模型: ${model.name}`,
        type: 'success'
      });
    },
    deployModel(model) {
      this.$message({
        message: `模型 ${model.name} 已成功部署`,
        type: 'success'
      });
    }
  }
}
</script>

<style>
.el-tabs__header {
  margin-bottom: 25px;
}
</style>

```

### `/simpletrade/web-frontend/src/views/UserCenterView.vue`
*(统计信息: 429 行, 16597 字符 [~2.38%])*
```
<template>
  <div>
    <!-- 顶部标签导航 -->
    <el-tabs v-model="activeTab" type="border-card">
      <el-tab-pane label="个人资料" name="profile">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">个人资料</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-button type="primary" icon="el-icon-edit" @click="editProfile">编辑资料</el-button>
            </el-col>
          </el-row>
        </div>

        <el-card shadow="hover" style="margin-bottom: 20px;">
          <el-row :gutter="20">
            <el-col :span="6">
              <div style="text-align: center;">
                <el-avatar :size="120" src="https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png"></el-avatar>
                <el-button type="text" style="margin-top: 10px;">更换头像</el-button>
              </div>
            </el-col>
            <el-col :span="18">
              <el-descriptions title="基本信息" :column="2" border>
                <el-descriptions-item label="用户名">张三</el-descriptions-item>
                <el-descriptions-item label="注册时间">2023-01-15</el-descriptions-item>
                <el-descriptions-item label="邮箱">zhangsan@example.com</el-descriptions-item>
                <el-descriptions-item label="手机">138****1234</el-descriptions-item>
                <el-descriptions-item label="账户类型">个人投资者</el-descriptions-item>
                <el-descriptions-item label="账户状态">
                  <el-tag type="success">正常</el-tag>
                </el-descriptions-item>
              </el-descriptions>
            </el-col>
          </el-row>
        </el-card>

        <!-- 交易统计 -->
        <el-card shadow="hover" style="margin-bottom: 20px;">
          <div slot="header" class="clearfix">
            <span>交易统计</span>
            <el-radio-group v-model="tradingStatsTimeframe" size="small" style="float: right;">
              <el-radio-button label="month">月</el-radio-button>
              <el-radio-button label="quarter">季</el-radio-button>
              <el-radio-button label="year">年</el-radio-button>
            </el-radio-group>
          </div>
          <el-row :gutter="20">
            <el-col :span="6">
              <div style="text-align: center;">
                <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">总交易次数</h3>
                <p style="font-size: 24px; font-weight: 600; color: #303133; margin: 0;">128</p>
              </div>
            </el-col>
            <el-col :span="6">
              <div style="text-align: center;">
                <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">盈利交易</h3>
                <p style="font-size: 24px; font-weight: 600; color: #67C23A; margin: 0;">75</p>
                <div style="margin-top: 10px; font-size: 14px; color: #909399;">
                  胜率: 58.6%
                </div>
              </div>
            </el-col>
            <el-col :span="6">
              <div style="text-align: center;">
                <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">亏损交易</h3>
                <p style="font-size: 24px; font-weight: 600; color: #F56C6C; margin: 0;">53</p>
                <div style="margin-top: 10px; font-size: 14px; color: #909399;">
                  亏损率: 41.4%
                </div>
              </div>
            </el-col>
            <el-col :span="6">
              <div style="text-align: center;">
                <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">总收益率</h3>
                <p style="font-size: 24px; font-weight: 600; color: #67C23A; margin: 0;">+12.5%</p>
                <div style="margin-top: 10px; font-size: 14px; color: #909399;">
                  超过市场: +5.2%
                </div>
              </div>
            </el-col>
          </el-row>
        </el-card>

        <!-- 最近登录记录 -->
        <el-card shadow="hover">
          <div slot="header" class="clearfix">
            <span>最近登录记录</span>
          </div>
          <el-table :data="loginRecords" style="width: 100%">
            <el-table-column prop="time" label="登录时间" width="180"></el-table-column>
            <el-table-column prop="ip" label="IP地址" width="180"></el-table-column>
            <el-table-column prop="location" label="登录地点" width="180"></el-table-column>
            <el-table-column prop="device" label="设备" width="180"></el-table-column>
            <el-table-column prop="status" label="状态">
              <template slot-scope="scope">
                <el-tag :type="scope.row.status === '成功' ? 'success' : 'danger'" size="small">{{ scope.row.status }}</el-tag>
              </template>
            </el-table-column>
          </el-table>
        </el-card>
      </el-tab-pane>

      <el-tab-pane label="账户设置" name="settings">
        <div style="margin-bottom: 20px;">
          <h2 style="font-size: 20px; font-weight: 600; margin: 0;">账户设置</h2>
        </div>

        <el-card shadow="hover" style="margin-bottom: 20px;">
          <div slot="header" class="clearfix">
            <span>基本设置</span>
          </div>
          <el-form :model="settingsForm" label-width="120px">
            <el-form-item label="用户名">
              <el-input v-model="settingsForm.username"></el-input>
            </el-form-item>
            <el-form-item label="邮箱">
              <el-input v-model="settingsForm.email"></el-input>
            </el-form-item>
            <el-form-item label="手机号码">
              <el-input v-model="settingsForm.phone"></el-input>
            </el-form-item>
            <el-form-item label="语言">
              <el-select v-model="settingsForm.language" style="width: 100%;">
                <el-option label="简体中文" value="zh-CN"></el-option>
                <el-option label="English" value="en-US"></el-option>
              </el-select>
            </el-form-item>
            <el-form-item label="时区">
              <el-select v-model="settingsForm.timezone" style="width: 100%;">
                <el-option label="(GMT+08:00) 北京时间" value="Asia/Shanghai"></el-option>
                <el-option label="(GMT+00:00) 格林威治标准时间" value="GMT"></el-option>
                <el-option label="(GMT-05:00) 东部标准时间" value="America/New_York"></el-option>
              </el-select>
            </el-form-item>
            <el-form-item>
              <el-button type="primary" @click="saveSettings">保存设置</el-button>
            </el-form-item>
          </el-form>
        </el-card>

        <el-card shadow="hover" style="margin-bottom: 20px;">
          <div slot="header" class="clearfix">
            <span>安全设置</span>
          </div>
          <el-form label-width="120px">
            <el-form-item label="修改密码">
              <el-button type="primary" plain @click="changePassword">修改密码</el-button>
            </el-form-item>
            <el-form-item label="两步验证">
              <el-switch v-model="securitySettings.twoFactorAuth"></el-switch>
              <span style="margin-left: 10px; color: #909399; font-size: 14px;">
                {{ securitySettings.twoFactorAuth ? '已开启' : '未开启' }}
              </span>
            </el-form-item>
            <el-form-item label="登录通知">
              <el-switch v-model="securitySettings.loginNotification"></el-switch>
              <span style="margin-left: 10px; color: #909399; font-size: 14px;">
                {{ securitySettings.loginNotification ? '已开启' : '未开启' }}
              </span>
            </el-form-item>
            <el-form-item label="异常登录保护">
              <el-switch v-model="securitySettings.unusualLoginProtection"></el-switch>
              <span style="margin-left: 10px; color: #909399; font-size: 14px;">
                {{ securitySettings.unusualLoginProtection ? '已开启' : '未开启' }}
              </span>
            </el-form-item>
            <el-form-item>
              <el-button type="primary" @click="saveSecuritySettings">保存设置</el-button>
            </el-form-item>
          </el-form>
        </el-card>

        <el-card shadow="hover">
          <div slot="header" class="clearfix">
            <span>通知设置</span>
          </div>
          <el-form label-width="200px">
            <el-form-item label="交易执行通知">
              <el-switch v-model="notificationSettings.tradeExecution"></el-switch>
            </el-form-item>
            <el-form-item label="价格提醒通知">
              <el-switch v-model="notificationSettings.priceAlert"></el-switch>
            </el-form-item>
            <el-form-item label="系统公告通知">
              <el-switch v-model="notificationSettings.systemAnnouncement"></el-switch>
            </el-form-item>
            <el-form-item label="市场分析报告通知">
              <el-switch v-model="notificationSettings.marketAnalysis"></el-switch>
            </el-form-item>
            <el-form-item>
              <el-button type="primary" @click="saveNotificationSettings">保存设置</el-button>
            </el-form-item>
          </el-form>
        </el-card>
      </el-tab-pane>

      <el-tab-pane label="订阅管理" name="subscription">
        <div style="margin-bottom: 20px;">
          <h2 style="font-size: 20px; font-weight: 600; margin: 0;">订阅管理</h2>
        </div>

        <!-- 当前订阅 -->
        <el-card shadow="hover" style="margin-bottom: 20px;">
          <div slot="header" class="clearfix">
            <span>当前订阅</span>
          </div>
          <el-row :gutter="20">
            <el-col :span="8">
              <div style="text-align: center; padding: 20px; border: 1px solid #EBEEF5; border-radius: 4px;">
                <h3 style="margin: 0 0 10px; font-size: 18px; color: #303133;">专业版</h3>
                <div style="font-size: 24px; font-weight: 600; color: #409EFF; margin-bottom: 10px;">¥299/月</div>
                <el-tag type="success">当前订阅</el-tag>
                <ul style="text-align: left; margin-top: 20px; padding-left: 20px;">
                  <li>实时市场数据</li>
                  <li>高级图表分析</li>
                  <li>AI策略推荐</li>
                  <li>无限策略创建</li>
                  <li>优先客户支持</li>
                </ul>
                <div style="margin-top: 20px; color: #909399; font-size: 14px;">
                  到期时间: 2023-12-15
                </div>
                <el-button type="danger" plain style="margin-top: 20px;">取消订阅</el-button>
              </div>
            </el-col>
          </el-row>
        </el-card>

        <!-- 可用订阅计划 -->
        <el-card shadow="hover">
          <div slot="header" class="clearfix">
            <span>可用订阅计划</span>
          </div>
          <el-row :gutter="20">
            <el-col :span="8">
              <div style="text-align: center; padding: 20px; border: 1px solid #EBEEF5; border-radius: 4px;">
                <h3 style="margin: 0 0 10px; font-size: 18px; color: #303133;">基础版</h3>
                <div style="font-size: 24px; font-weight: 600; color: #303133; margin-bottom: 20px;">¥99/月</div>
                <ul style="text-align: left; padding-left: 20px;">
                  <li>延迟市场数据</li>
                  <li>基础图表分析</li>
                  <li>最多3个策略</li>
                  <li>标准客户支持</li>
                </ul>
                <el-button type="primary" plain style="margin-top: 20px;">降级到此计划</el-button>
              </div>
            </el-col>
            <el-col :span="8">
              <div style="text-align: center; padding: 20px; border: 1px solid #EBEEF5; border-radius: 4px; background-color: #F5F7FA;">
                <h3 style="margin: 0 0 10px; font-size: 18px; color: #303133;">专业版</h3>
                <div style="font-size: 24px; font-weight: 600; color: #409EFF; margin-bottom: 20px;">¥299/月</div>
                <el-tag type="success">当前订阅</el-tag>
                <ul style="text-align: left; margin-top: 20px; padding-left: 20px;">
                  <li>实时市场数据</li>
                  <li>高级图表分析</li>
                  <li>AI策略推荐</li>
                  <li>无限策略创建</li>
                  <li>优先客户支持</li>
                </ul>
              </div>
            </el-col>
            <el-col :span="8">
              <div style="text-align: center; padding: 20px; border: 1px solid #EBEEF5; border-radius: 4px;">
                <h3 style="margin: 0 0 10px; font-size: 18px; color: #303133;">企业版</h3>
                <div style="font-size: 24px; font-weight: 600; color: #303133; margin-bottom: 20px;">¥999/月</div>
                <ul style="text-align: left; padding-left: 20px;">
                  <li>实时市场数据</li>
                  <li>高级图表分析</li>
                  <li>AI策略推荐</li>
                  <li>无限策略创建</li>
                  <li>专属客户经理</li>
                  <li>API访问</li>
                  <li>多用户管理</li>
                </ul>
                <el-button type="primary" style="margin-top: 20px;">升级到此计划</el-button>
              </div>
            </el-col>
          </el-row>
        </el-card>
      </el-tab-pane>
    </el-tabs>

    <!-- 修改密码对话框 -->
    <el-dialog title="修改密码" :visible.sync="passwordDialogVisible" width="40%">
      <el-form :model="passwordForm" label-width="120px">
        <el-form-item label="当前密码">
          <el-input v-model="passwordForm.currentPassword" type="password"></el-input>
        </el-form-item>
        <el-form-item label="新密码">
          <el-input v-model="passwordForm.newPassword" type="password"></el-input>
        </el-form-item>
        <el-form-item label="确认新密码">
          <el-input v-model="passwordForm.confirmPassword" type="password"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="passwordDialogVisible = false">取消</el-button>
        <el-button type="primary" @click="submitPasswordChange">确认修改</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
export default {
  name: 'UserCenterView',
  data() {
    return {
      activeTab: 'profile',
      tradingStatsTimeframe: 'month',
      passwordDialogVisible: false,
      loginRecords: [
        {
          time: '2023-10-15 14:30:25',
          ip: '192.168.1.1',
          location: '北京',
          device: 'Chrome / Windows',
          status: '成功'
        },
        {
          time: '2023-10-14 09:15:10',
          ip: '192.168.1.1',
          location: '北京',
          device: 'Safari / iOS',
          status: '成功'
        },
        {
          time: '2023-10-12 18:45:32',
          ip: '118.24.63.156',
          location: '上海',
          device: 'Firefox / macOS',
          status: '成功'
        },
        {
          time: '2023-10-10 22:10:45',
          ip: '45.76.192.88',
          location: '美国',
          device: 'Chrome / Windows',
          status: '失败'
        }
      ],
      settingsForm: {
        username: '张三',
        email: 'zhangsan@example.com',
        phone: '13812341234',
        language: 'zh-CN',
        timezone: 'Asia/Shanghai'
      },
      securitySettings: {
        twoFactorAuth: true,
        loginNotification: true,
        unusualLoginProtection: true
      },
      notificationSettings: {
        tradeExecution: true,
        priceAlert: true,
        systemAnnouncement: false,
        marketAnalysis: true
      },
      passwordForm: {
        currentPassword: '',
        newPassword: '',
        confirmPassword: ''
      }
    }
  },
  methods: {
    editProfile() {
      this.$message({
        message: '进入编辑模式',
        type: 'info'
      });
    },
    saveSettings() {
      this.$message({
        message: '设置已保存',
        type: 'success'
      });
    },
    changePassword() {
      this.passwordDialogVisible = true;
    },
    submitPasswordChange() {
      if (this.passwordForm.newPassword !== this.passwordForm.confirmPassword) {
        this.$message({
          message: '两次输入的密码不一致',
          type: 'error'
        });
        return;
      }

      this.$message({
        message: '密码修改成功',
        type: 'success'
      });
      this.passwordDialogVisible = false;

      // 清空表单
      this.passwordForm = {
        currentPassword: '',
        newPassword: '',
        confirmPassword: ''
      };
    },
    saveSecuritySettings() {
      this.$message({
        message: '安全设置已保存',
        type: 'success'
      });
    },
    saveNotificationSettings() {
      this.$message({
        message: '通知设置已保存',
        type: 'success'
      });
    }
  }
}
</script>

<style>
.el-tabs__header {
  margin-bottom: 25px;
}
</style>

```

### `/simpletrade/web-frontend/src/views/TradingCenterView.vue`
*(统计信息: 325 行, 11959 字符 [~1.71%])*
```
<template>
  <div>
    <!-- 顶部标签导航 -->
    <el-tabs v-model="activeTab" type="border-card">
      <el-tab-pane label="账户概览" name="overview">
        <div style="margin-bottom: 20px;">
          <el-row :gutter="20">
            <el-col :span="6">
              <el-card shadow="hover">
                <div style="text-align: center;">
                  <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">账户总资产</h3>
                  <p style="font-size: 24px; font-weight: 600; color: #303133; margin: 0;">¥ 1,250,000</p>
                  <div style="margin-top: 10px; font-size: 14px; color: #67C23A;">
                    <i class="el-icon-top"></i> +2.5% 今日
                  </div>
                </div>
              </el-card>
            </el-col>

            <el-col :span="6">
              <el-card shadow="hover">
                <div style="text-align: center;">
                  <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">可用资金</h3>
                  <p style="font-size: 24px; font-weight: 600; color: #303133; margin: 0;">¥ 450,000</p>
                  <div style="margin-top: 10px; font-size: 14px; color: #909399;">
                    36% 总资产
                  </div>
                </div>
              </el-card>
            </el-col>

            <el-col :span="6">
              <el-card shadow="hover">
                <div style="text-align: center;">
                  <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">持仓市值</h3>
                  <p style="font-size: 24px; font-weight: 600; color: #303133; margin: 0;">¥ 800,000</p>
                  <div style="margin-top: 10px; font-size: 14px; color: #909399;">
                    64% 总资产
                  </div>
                </div>
              </el-card>
            </el-col>

            <el-col :span="6">
              <el-card shadow="hover">
                <div style="text-align: center;">
                  <h3 style="margin: 0 0 10px; font-size: 16px; color: #606266;">今日盈亏</h3>
                  <p style="font-size: 24px; font-weight: 600; color: #67C23A; margin: 0;">¥ 32,500</p>
                  <div style="margin-top: 10px; font-size: 14px; color: #67C23A;">
                    <i class="el-icon-top"></i> +2.5% 今日
                  </div>
                </div>
              </el-card>
            </el-col>
          </el-row>
        </div>

        <!-- 资产走势图 -->
        <el-card shadow="hover" style="margin-bottom: 20px;">
          <div slot="header">
            <span>资产走势</span>
            <el-radio-group v-model="timeRange" size="small" style="float: right;">
              <el-radio-button label="week">周</el-radio-button>
              <el-radio-button label="month">月</el-radio-button>
              <el-radio-button label="year">年</el-radio-button>
            </el-radio-group>
          </div>
          <div style="height: 300px; display: flex; align-items: center; justify-content: center; color: #909399;">
            <i class="el-icon-data-analysis" style="font-size: 24px; margin-right: 10px;"></i>
            资产走势图（这里将显示图表）
          </div>
        </el-card>

        <!-- 最近交易 -->
        <el-card shadow="hover">
          <div slot="header">
            <span>最近交易</span>
            <el-button style="float: right;" type="text">查看全部</el-button>
          </div>
          <el-table :data="recentTrades" style="width: 100%">
            <el-table-column prop="time" label="时间" width="180"></el-table-column>
            <el-table-column prop="symbol" label="股票代码" width="120"></el-table-column>
            <el-table-column prop="name" label="股票名称" width="150"></el-table-column>
            <el-table-column prop="type" label="交易类型" width="100">
              <template slot-scope="scope">
                <el-tag :type="scope.row.type === '买入' ? 'success' : 'danger'" size="small">{{ scope.row.type }}</el-tag>
              </template>
            </el-table-column>
            <el-table-column prop="price" label="价格" width="120"></el-table-column>
            <el-table-column prop="quantity" label="数量" width="120"></el-table-column>
            <el-table-column prop="amount" label="金额"></el-table-column>
          </el-table>
        </el-card>
      </el-tab-pane>

      <el-tab-pane label="持仓" name="positions">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">持仓列表</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-input
                placeholder="搜索股票..."
                prefix-icon="el-icon-search"
                style="width: 200px;"
              ></el-input>
            </el-col>
          </el-row>
        </div>

        <el-table :data="positions" style="width: 100%" border>
          <el-table-column prop="symbol" label="股票代码" width="120"></el-table-column>
          <el-table-column prop="name" label="股票名称" width="150"></el-table-column>
          <el-table-column prop="quantity" label="持仓数量" width="120"></el-table-column>
          <el-table-column prop="costPrice" label="成本价" width="120"></el-table-column>
          <el-table-column prop="currentPrice" label="当前价" width="120"></el-table-column>
          <el-table-column prop="marketValue" label="市值" width="150"></el-table-column>
          <el-table-column prop="profit" label="盈亏" width="120">
            <template slot-scope="scope">
              <span :style="{ color: scope.row.profit >= 0 ? '#67C23A' : '#F56C6C' }">
                {{ scope.row.profit >= 0 ? '+' : '' }}{{ scope.row.profit }}
              </span>
            </template>
          </el-table-column>
          <el-table-column prop="profitPercent" label="盈亏比例" width="120">
            <template slot-scope="scope">
              <span :style="{ color: scope.row.profitPercent >= 0 ? '#67C23A' : '#F56C6C' }">
                {{ scope.row.profitPercent >= 0 ? '+' : '' }}{{ scope.row.profitPercent }}%
              </span>
            </template>
          </el-table-column>
          <el-table-column label="操作">
            <template slot-scope="scope">
              <el-button size="mini" type="primary" @click="handleBuy(scope.row)">买入</el-button>
              <el-button size="mini" type="danger" @click="handleSell(scope.row)">卖出</el-button>
            </template>
          </el-table-column>
        </el-table>
      </el-tab-pane>

      <el-tab-pane label="订单" name="orders">
        <div style="margin-bottom: 20px;">
          <el-row type="flex" justify="space-between" align="middle">
            <el-col :span="12">
              <h2 style="font-size: 20px; font-weight: 600; margin: 0;">订单列表</h2>
            </el-col>
            <el-col :span="12" style="text-align: right;">
              <el-radio-group v-model="orderStatus" size="small">
                <el-radio-button label="all">全部</el-radio-button>
                <el-radio-button label="pending">待成交</el-radio-button>
                <el-radio-button label="completed">已成交</el-radio-button>
                <el-radio-button label="canceled">已撤销</el-radio-button>
              </el-radio-group>
            </el-col>
          </el-row>
        </div>

        <el-table :data="orders" style="width: 100%" border>
          <el-table-column prop="time" label="时间" width="180"></el-table-column>
          <el-table-column prop="symbol" label="股票代码" width="120"></el-table-column>
          <el-table-column prop="name" label="股票名称" width="150"></el-table-column>
          <el-table-column prop="type" label="交易类型" width="100">
            <template slot-scope="scope">
              <el-tag :type="scope.row.type === '买入' ? 'success' : 'danger'" size="small">{{ scope.row.type }}</el-tag>
            </template>
          </el-table-column>
          <el-table-column prop="price" label="价格" width="120"></el-table-column>
          <el-table-column prop="quantity" label="数量" width="120"></el-table-column>
          <el-table-column prop="amount" label="金额" width="150"></el-table-column>
          <el-table-column prop="status" label="状态" width="120">
            <template slot-scope="scope">
              <el-tag
                :type="scope.row.status === '已成交' ? 'success' : scope.row.status === '待成交' ? 'warning' : 'info'"
                size="small"
              >
                {{ scope.row.status }}
              </el-tag>
            </template>
          </el-table-column>
          <el-table-column label="操作">
            <template slot-scope="scope">
              <el-button
                size="mini"
                type="text"
                @click="handleCancelOrder(scope.row)"
                :disabled="scope.row.status !== '待成交'"
              >
                撤销
              </el-button>
              <el-button size="mini" type="text" @click="handleViewOrder(scope.row)">详情</el-button>
            </template>
          </el-table-column>
        </el-table>
      </el-tab-pane>
    </el-tabs>
  </div>
</template>

<script>
export default {
  name: 'TradingCenterView',
  data() {
    return {
      activeTab: 'overview',
      timeRange: 'month',
      orderStatus: 'all',
      recentTrades: [
        {
          time: '2023-10-15 14:30:25',
          symbol: '600000',
          name: '浦发银行',
          type: '买入',
          price: '10.25',
          quantity: '1000',
          amount: '10,250.00'
        },
        {
          time: '2023-10-15 11:20:15',
          symbol: '000001',
          name: '平安银行',
          type: '卖出',
          price: '15.80',
          quantity: '500',
          amount: '7,900.00'
        },
        {
          time: '2023-10-14 15:45:30',
          symbol: '601318',
          name: '中国平安',
          type: '买入',
          price: '42.50',
          quantity: '200',
          amount: '8,500.00'
        }
      ],
      positions: [
        {
          symbol: '600000',
          name: '浦发银行',
          quantity: '1000',
          costPrice: '10.25',
          currentPrice: '10.50',
          marketValue: '10,500.00',
          profit: '250.00',
          profitPercent: 2.44
        },
        {
          symbol: '601318',
          name: '中国平安',
          quantity: '200',
          costPrice: '42.50',
          currentPrice: '41.80',
          marketValue: '8,360.00',
          profit: '-140.00',
          profitPercent: -1.65
        },
        {
          symbol: '000651',
          name: '格力电器',
          quantity: '300',
          costPrice: '35.20',
          currentPrice: '36.50',
          marketValue: '10,950.00',
          profit: '390.00',
          profitPercent: 3.69
        }
      ],
      orders: [
        {
          time: '2023-10-15 14:30:25',
          symbol: '600000',
          name: '浦发银行',
          type: '买入',
          price: '10.25',
          quantity: '1000',
          amount: '10,250.00',
          status: '已成交'
        },
        {
          time: '2023-10-15 11:20:15',
          symbol: '000001',
          name: '平安银行',
          type: '卖出',
          price: '15.80',
          quantity: '500',
          amount: '7,900.00',
          status: '已成交'
        },
        {
          time: '2023-10-15 10:05:40',
          symbol: '601988',
          name: '中国银行',
          type: '买入',
          price: '3.50',
          quantity: '2000',
          amount: '7,000.00',
          status: '待成交'
        }
      ]
    }
  },
  methods: {
    handleBuy(row) {
      console.log('买入:', row);
    },
    handleSell(row) {
      console.log('卖出:', row);
    },
    handleCancelOrder(row) {
      console.log('撤销订单:', row);
    },
    handleViewOrder(row) {
      console.log('查看订单详情:', row);
    }
  }
}
</script>

<style>
.el-tabs__header {
  margin-bottom: 25px;
}
</style>

```

### `/simpletrade/web-frontend/src/views/CreateFromTemplateView.vue`
*(统计信息: 187 行, 5366 字符 [~0.77%])*
```
<template>
  <div class="template-strategy-create">
    <el-card class="box-card">
      <div slot="header" class="clearfix">
        <span>基于{{ templateName }}创建我的策略</span>
        <el-button style="float: right; padding: 3px 0" type="text" @click="goBack">返回</el-button>
      </div>

      <div v-if="loading" class="loading-container">
        <el-skeleton :rows="5" animated />
      </div>

      <div v-else-if="error" class="error-message">
        加载策略模板失败：{{ error }}
      </div>

      <el-form v-else :model="strategyForm" :rules="rules" ref="strategyForm" label-width="120px">
        <el-form-item label="策略名称" prop="name">
          <el-input v-model="strategyForm.name" placeholder="请输入您的策略名称"></el-input>
        </el-form-item>

        <el-divider>策略参数</el-divider>

        <el-form-item v-for="(param, key) in originalParameters" :key="key" :label="param.description || key" :prop="'parameters.' + key">
          <el-input-number
            v-if="param.type === 'int' || param.type === 'float'"
            v-model="strategyForm.parameters[key]"
            :precision="param.type === 'float' ? 2 : 0"
            :step="param.type === 'float' ? 0.1 : 1"
            :min="param.min !== undefined ? param.min : undefined"
            :max="param.max !== undefined ? param.max : undefined"
          ></el-input-number>
          <el-input v-else v-model="strategyForm.parameters[key]"></el-input>
          <div class="param-description" v-if="param.description">{{ param.description }}</div>
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="submitForm" :loading="submitting">创建我的策略</el-button>
          <el-button @click="goBack">取消</el-button>
        </el-form-item>
      </el-form>
    </el-card>
  </div>
</template>

<script>
import { getStrategyDetail, createUserStrategy } from '@/api/strategies';

export default {
  name: 'CreateFromTemplateView',
  props: {
    templateId: {
      type: [String, Number],
      required: true
    }
  },
  data() {
    return {
      loading: true,
      submitting: false,
      error: null,
      templateName: '策略模板',
      originalParameters: {}, // 原始参数定义
      strategyForm: {
        name: '',
        parameters: {}
      },
      rules: {
        name: [
          { required: true, message: '请输入策略名称', trigger: 'blur' },
          { min: 2, max: 50, message: '长度在 2 到 50 个字符', trigger: 'blur' }
        ]
      }
    };
  },
  methods: {
    goBack() {
      this.$router.go(-1);
    },

    async loadTemplateStrategy() {
      this.loading = true;
      this.error = null;

      try {
        const response = await getStrategyDetail(this.templateId);
        if (response.data && response.data.success) {
          const strategy = response.data.data;
          this.templateName = strategy.name;

          // 设置默认策略名称为"我的 + 模板名称"
          this.strategyForm.name = `我的${strategy.name}`;

          // 处理参数
          this.originalParameters = strategy.parameters || {};

          // 设置默认参数值
          const defaultParameters = {};
          Object.entries(this.originalParameters).forEach(([key, param]) => {
            defaultParameters[key] = param.default;
          });

          this.strategyForm.parameters = defaultParameters;
        } else {
          this.error = response.data.message || '获取策略模板失败';
        }
      } catch (err) {
        console.error('Error loading template strategy:', err);
        this.error = err.message || '网络错误或服务器内部错误';
      } finally {
        this.loading = false;
      }
    },

    async submitForm() {
      try {
        this.$refs.strategyForm.validate(async (valid) => {
          if (!valid) {
            return false;
          }

          this.submitting = true;

          // 构建请求数据
          const requestData = {
            user_id: 1, // 应该从用户会话或存储中获取
            strategy_id: parseInt(this.templateId),
            name: this.strategyForm.name,
            parameters: this.strategyForm.parameters
          };

          try {
            const response = await createUserStrategy(requestData);

            if (response.data && response.data.success) {
              this.$message.success('用户策略创建成功');
              // 跳转到策略中心页面
              this.$router.push('/strategy-center');
            } else {
              this.$message.error(response.data.message || '创建用户策略失败');
            }
          } catch (err) {
            console.error('Error creating user strategy:', err);
            this.$message.error(err.message || '网络错误或服务器内部错误');
          } finally {
            this.submitting = false;
          }
        });
      } catch (err) {
        console.error('Form validation error:', err);
        this.$message.error('表单验证失败');
        this.submitting = false;
      }
    }
  },
  created() {
    this.loadTemplateStrategy();
  }
};
</script>

<style scoped>
.template-strategy-create {
  padding: 20px;
}
.loading-container {
  padding: 20px;
}
.error-message {
  color: #F56C6C;
  padding: 20px;
  text-align: center;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both;
}
.param-description {
  font-size: 12px;
  color: #909399;
  margin-top: 5px;
}
</style>
```

### `/simpletrade/web-frontend/src/views/StrategyDetailView.vue`
*(统计信息: 181 行, 5904 字符 [~0.85%])*
```
<template>
  <div class="strategy-detail-container">
    <div class="page-header">
      <el-page-header
        @back="goBack"
        :content="strategy ? strategy.name : '策略详情'"
        title="返回">
      </el-page-header>
    </div>

    <!-- 主要内容区域 -->
    <div class="main-content" v-loading="loading">
      <!-- 不再需要 Tabs, 直接显示信息 -->
      <div v-if="error" class="error-message">
         加载策略详情失败：{{ error }}
      </div>
      <div v-else-if="strategy">
          <!-- 策略基本信息 -->
          <el-descriptions :column="2" border title="基本信息">
            <el-descriptions-item label="策略名称">{{ strategy.name }}</el-descriptions-item>
            <el-descriptions-item label="标识符">{{ strategy.identifier }}</el-descriptions-item>
            <el-descriptions-item label="类型">{{ strategy.type }}</el-descriptions-item>
            <el-descriptions-item label="分类">{{ strategy.category || '-' }}</el-descriptions-item>
            <el-descriptions-item label="复杂度">
              <el-rate v-model="strategy.complexity" disabled></el-rate>
            </el-descriptions-item>
             <el-descriptions-item label="资源需求">
               <el-rate v-model="strategy.resource_requirement" disabled></el-rate>
            </el-descriptions-item>
            <el-descriptions-item label="描述" :span="2">{{ strategy.description || '无' }}</el-descriptions-item>
          </el-descriptions>

          <!-- 策略默认参数 -->
          <div style="margin-top: 20px;">
            <h3>默认参数</h3>
            <el-table :data="parameterList" style="width: 100%" border size="small">
                <el-table-column prop="name" label="参数名" width="180"></el-table-column>
                <el-table-column prop="default" label="默认值"></el-table-column>
                <el-table-column prop="description" label="描述"></el-table-column>
                <!-- 可以根据需要添加 type, min, max 等列 -->
            </el-table>
          </div>

           <!-- 策略代码显示 -->
           <div v-if="strategy.code" style="margin-top: 20px;">
              <h3>策略代码示例</h3>
              <el-card shadow="never" style="max-height: 600px; overflow-y: auto;">
                  <pre style="margin: 0;"><code class="language-python">{{ strategy.code }}</code></pre>
              </el-card>
           </div>

           <!-- (可选) 添加"使用此模板创建我的策略"按钮 -->
           <div style="margin-top: 30px; text-align: center;">
               <el-button type="success" icon="el-icon-plus" @click="handleUseTemplate">使用此模板创建我的策略</el-button>
           </div>
      </div>
       <div v-else-if="!loading">
          未找到策略信息。
      </div>
      <!-- 原有的 Tabs 和其他 Pane 已移除 -->
    </div>
  </div>
</template>

<script>
// 只保留需要的 import
import { getStrategyDetail } from '@/api/strategies';
// import dayjs from 'dayjs'; // 不再需要

export default {
  name: 'StrategyDetailView',
  props: {
    id: {
      type: [String, Number],
      required: true
    }
  },
  data() {
    return {
      strategy: null,
      loading: false,
      error: null,
      // --- 移除所有与回测、优化、实盘相关的 data ---
      // activeTab: 'info',
      // strategyComplexity: 3,
      // strategyParams: {},
      // backtestLoading: false,
      // backtestSymbol: '',
      // ... (移除其他 backtest 相关)
      // backtestResult: { hasResult: false, statistics: {} },
      // optimizeParams: { ... },
      // optimizeResult: { ... },
      // liveTradeRecords: []
    };
  },
  computed: {
    // parameterList 计算属性保持不变，用于展示默认参数
    parameterList() {
      if (!this.strategy || !this.strategy.parameters || typeof this.strategy.parameters !== 'object') {
        return [];
      }
      // 修正从参数对象获取默认值的方式
      return Object.entries(this.strategy.parameters).map(([name, paramData]) => ({
        name,
        default: paramData.default,  // 正确获取default属性值而不是整个对象
        description: paramData.description || ''  // 直接从参数对象获取描述
      }));
    }
  },
  methods: {
    goBack() {
      this.$router.go(-1); // 改为返回上一页，通常更友好
    },
    // fetchStrategyDetail 保持不变
    async fetchStrategyDetail() {
      console.log('StrategyDetailView: fetchStrategyDetail() called with id:', this.id);
      this.loading = true;
      this.error = null;
      this.strategy = null; // 先清空
      try {
        const response = await getStrategyDetail(this.id);
        if (response.data && response.data.success) {
          this.strategy = response.data.data;
        } else {
          this.error = response.data.message || '获取策略详情失败';
        }
      } catch (err) {
        console.error('Error fetching strategy detail:', err);
        this.error = (err.response && err.response.data && err.response.data.message)
                       || (err.response && err.response.data && err.response.detail)
                       || err.message
                       || '网络错误或服务器内部错误';
      } finally {
        this.loading = false;
      }
    },
    // --- 移除所有与回测、优化、实盘相关的方法 ---
    // runBacktest() { ... }
    // formatPercent() { ... }
    // formatNumber() { ... }
    // saveStrategyParams() { ... }
    // deployToLive() { ... }
    // runOptimization() { ... }
    // applyOptimizedParams() { ... }
    // applyParamSet() { ... }
    // stopStrategy() { ... }

    // (可选) 处理"使用模板"按钮点击
    handleUseTemplate() {
        if (!this.strategy) return;
        // 跳转到"创建我的策略"页面，并传递模板ID
        this.$router.push({
            name: 'CreateFromTemplate',
            params: { templateId: this.strategy.id }
        });
    }
  },
  created() {
    this.fetchStrategyDetail();
  },
  watch: {
    // Watch id 保持不变, 但不再需要重置回测状态
    id(newId, oldId) {
      console.log(`StrategyDetailView: Watcher triggered. ID changed from ${oldId} to ${newId}`);
      if (newId && newId !== oldId) {
        this.fetchStrategyDetail();
      }
    }
  }
};
</script>

<style scoped>
/* ... (原有样式) ... */
.error-message {
    color: #F56C6C;
    padding: 20px;
    text-align: center;
}
</style>

```

### `/simpletrade/web-frontend/src/views/trading/Positions.vue`
*(统计信息: 398 行, 12198 字符 [~1.75%])*
```
<template>
  <div class="positions-container">
    <el-card class="box-card">
      <div slot="header" class="clearfix">
        <span>持仓管理</span>
        <el-button style="float: right; padding: 3px 0" type="text" @click="refreshPositions">刷新</el-button>
      </div>

      <el-form :inline="true" :model="filterForm" class="filter-form">
        <el-form-item label="交易接口">
          <el-select v-model="filterForm.gateway" placeholder="请选择交易接口" clearable>
            <el-option label="老虎证券" value="tiger"></el-option>
            <el-option label="盈透证券" value="ib"></el-option>
            <el-option label="CTP" value="ctp"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="交易所">
          <el-select v-model="filterForm.exchange" placeholder="请选择交易所" clearable>
            <el-option label="上海证券交易所" value="SSE"></el-option>
            <el-option label="深圳证券交易所" value="SZSE"></el-option>
            <el-option label="中国金融期货交易所" value="CFFEX"></el-option>
            <el-option label="上海期货交易所" value="SHFE"></el-option>
            <el-option label="大连商品交易所" value="DCE"></el-option>
            <el-option label="郑州商品交易所" value="CZCE"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="合约代码">
          <el-input v-model="filterForm.symbol" placeholder="请输入合约代码" clearable></el-input>
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="filterPositions">查询</el-button>
          <el-button @click="resetFilter">重置</el-button>
        </el-form-item>
      </el-form>

      <el-table
        :data="positionsData"
        style="width: 100%"
        border
        v-loading="loading"
        :row-class-name="getRowClassName">
        <el-table-column prop="symbol" label="合约代码" width="120"></el-table-column>
        <el-table-column prop="exchange" label="交易所" width="120"></el-table-column>
        <el-table-column prop="direction" label="方向" width="80">
          <template slot-scope="scope">
            <el-tag :type="scope.row.direction === 'LONG' ? 'danger' : 'success'">
              {{ scope.row.direction === 'LONG' ? '多' : '空' }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="volume" label="持仓量" width="100"></el-table-column>
        <el-table-column prop="frozen" label="冻结量" width="100"></el-table-column>
        <el-table-column prop="price" label="持仓均价" width="120"></el-table-column>
        <el-table-column prop="pnl" label="持仓盈亏" width="120">
          <template slot-scope="scope">
            <span :class="scope.row.pnl >= 0 ? 'profit' : 'loss'">
              {{ scope.row.pnl }}
            </span>
          </template>
        </el-table-column>
        <el-table-column prop="pnlRatio" label="盈亏比例" width="120">
          <template slot-scope="scope">
            <span :class="scope.row.pnlRatio >= 0 ? 'profit' : 'loss'">
              {{ scope.row.pnlRatio }}%
            </span>
          </template>
        </el-table-column>
        <el-table-column prop="ydVolume" label="昨仓" width="100"></el-table-column>
        <el-table-column prop="tdVolume" label="今仓" width="100"></el-table-column>
        <el-table-column prop="gateway" label="接口" width="120"></el-table-column>
        <el-table-column label="操作" fixed="right" width="200">
          <template slot-scope="scope">
            <el-button
              size="mini"
              type="primary"
              @click="handleClose(scope.row)">平仓</el-button>
            <el-button
              size="mini"
              type="warning"
              @click="handleModify(scope.row)">修改止损</el-button>
          </template>
        </el-table-column>
      </el-table>

      <div class="position-summary">
        <el-row :gutter="20">
          <el-col :span="8">
            <div class="summary-item">
              <span class="label">总持仓市值:</span>
              <span class="value">{{ totalValue }}</span>
            </div>
          </el-col>
          <el-col :span="8">
            <div class="summary-item">
              <span class="label">总持仓盈亏:</span>
              <span :class="['value', totalPnl >= 0 ? 'profit' : 'loss']">{{ totalPnl }}</span>
            </div>
          </el-col>
          <el-col :span="8">
            <div class="summary-item">
              <span class="label">总盈亏比例:</span>
              <span :class="['value', totalPnlRatio >= 0 ? 'profit' : 'loss']">{{ totalPnlRatio }}%</span>
            </div>
          </el-col>
        </el-row>
      </div>
    </el-card>

    <!-- 平仓对话框 -->
    <el-dialog title="平仓" :visible.sync="closeDialogVisible" width="30%">
      <el-form :model="closeForm" label-width="100px">
        <el-form-item label="合约代码">
          <span>{{ closeForm.symbol }}</span>
        </el-form-item>
        <el-form-item label="方向">
          <span>{{ closeForm.direction === 'LONG' ? '多' : '空' }}</span>
        </el-form-item>
        <el-form-item label="持仓量">
          <span>{{ closeForm.volume }}</span>
        </el-form-item>
        <el-form-item label="平仓数量">
          <el-input-number v-model="closeForm.closeVolume" :min="1" :max="closeForm.volume" :step="1"></el-input-number>
        </el-form-item>
        <el-form-item label="价格类型">
          <el-select v-model="closeForm.orderType" placeholder="请选择价格类型">
            <el-option label="限价单" value="LIMIT"></el-option>
            <el-option label="市价单" value="MARKET"></el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="价格" v-if="closeForm.orderType === 'LIMIT'">
          <el-input-number v-model="closeForm.price" :precision="2" :step="0.01" :min="0"></el-input-number>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="closeDialogVisible = false">取消</el-button>
        <el-button type="primary" @click="submitClose">确定</el-button>
      </span>
    </el-dialog>

    <!-- 修改止损对话框 -->
    <el-dialog title="修改止损" :visible.sync="stopLossDialogVisible" width="30%">
      <el-form :model="stopLossForm" label-width="100px">
        <el-form-item label="合约代码">
          <span>{{ stopLossForm.symbol }}</span>
        </el-form-item>
        <el-form-item label="方向">
          <span>{{ stopLossForm.direction === 'LONG' ? '多' : '空' }}</span>
        </el-form-item>
        <el-form-item label="持仓均价">
          <span>{{ stopLossForm.price }}</span>
        </el-form-item>
        <el-form-item label="止损价格">
          <el-input-number v-model="stopLossForm.stopLossPrice" :precision="2" :step="0.01" :min="0"></el-input-number>
        </el-form-item>
        <el-form-item label="止盈价格">
          <el-input-number v-model="stopLossForm.takeProfitPrice" :precision="2" :step="0.01" :min="0"></el-input-number>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="stopLossDialogVisible = false">取消</el-button>
        <el-button type="primary" @click="submitStopLoss">确定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
export default {
  name: 'TradingPositions',
  data() {
    return {
      loading: false,
      filterForm: {
        gateway: '',
        exchange: '',
        symbol: ''
      },
      positionsData: [
        {
          symbol: '600000',
          exchange: 'SSE',
          direction: 'LONG',
          volume: 1000,
          frozen: 0,
          price: 10.25,
          pnl: 250.00,
          pnlRatio: 2.44,
          ydVolume: 1000,
          tdVolume: 0,
          gateway: 'tiger'
        },
        {
          symbol: '000001',
          exchange: 'SZSE',
          direction: 'SHORT',
          volume: 500,
          frozen: 0,
          price: 15.75,
          pnl: -125.00,
          pnlRatio: -1.59,
          ydVolume: 300,
          tdVolume: 200,
          gateway: 'ib'
        },
        {
          symbol: 'IF2106',
          exchange: 'CFFEX',
          direction: 'LONG',
          volume: 2,
          frozen: 0,
          price: 5320.00,
          pnl: 1200.00,
          pnlRatio: 11.28,
          ydVolume: 0,
          tdVolume: 2,
          gateway: 'ctp'
        }
      ],
      closeDialogVisible: false,
      closeForm: {
        symbol: '',
        direction: '',
        volume: 0,
        closeVolume: 0,
        orderType: 'LIMIT',
        price: 0
      },
      stopLossDialogVisible: false,
      stopLossForm: {
        symbol: '',
        direction: '',
        price: 0,
        stopLossPrice: 0,
        takeProfitPrice: 0
      }
    }
  },
  computed: {
    totalValue() {
      let total = 0;
      this.positionsData.forEach(position => {
        total += position.volume * position.price;
      });
      return total.toFixed(2);
    },
    totalPnl() {
      let total = 0;
      this.positionsData.forEach(position => {
        total += position.pnl;
      });
      return total.toFixed(2);
    },
    totalPnlRatio() {
      if (this.totalValue === 0) return 0;
      return ((this.totalPnl / this.totalValue) * 100).toFixed(2);
    }
  },
  methods: {
    refreshPositions() {
      this.loading = true;

      // 模拟API请求
      setTimeout(() => {
        this.loading = false;
        this.$message.success('持仓数据已刷新');
      }, 1000);
    },
    filterPositions() {
      this.loading = true;

      // 模拟API请求
      setTimeout(() => {
        // 过滤数据
        const filteredData = this.positionsData.filter(position => {
          let match = true;
          if (this.filterForm.gateway && position.gateway !== this.filterForm.gateway) {
            match = false;
          }
          if (this.filterForm.exchange && position.exchange !== this.filterForm.exchange) {
            match = false;
          }
          if (this.filterForm.symbol && !position.symbol.includes(this.filterForm.symbol)) {
            match = false;
          }
          return match;
        });

        this.loading = false;
        this.$message.success('查询成功');
      }, 500);
    },
    resetFilter() {
      this.filterForm = {
        gateway: '',
        exchange: '',
        symbol: ''
      };
      this.filterPositions();
    },
    getRowClassName({ row }) {
      if (row.pnl >= 0) {
        return 'profit-row';
      } else {
        return 'loss-row';
      }
    },
    handleClose(row) {
      this.closeForm = {
        symbol: row.symbol,
        direction: row.direction,
        volume: row.volume,
        closeVolume: row.volume,
        orderType: 'LIMIT',
        price: row.price
      };
      this.closeDialogVisible = true;
    },
    handleModify(row) {
      this.stopLossForm = {
        symbol: row.symbol,
        direction: row.direction,
        price: row.price,
        stopLossPrice: row.direction === 'LONG' ? row.price * 0.95 : row.price * 1.05,
        takeProfitPrice: row.direction === 'LONG' ? row.price * 1.1 : row.price * 0.9
      };
      this.stopLossDialogVisible = true;
    },
    submitClose() {
      // 调用API提交平仓订单
      this.$message.success(`已提交平仓订单: ${this.closeForm.symbol} ${this.closeForm.closeVolume}手`);
      this.closeDialogVisible = false;
    },
    submitStopLoss() {
      // 调用API设置止损止盈
      this.$message.success(`已设置止损止盈: ${this.stopLossForm.symbol}`);
      this.stopLossDialogVisible = false;
    }
  },
  created() {
    this.refreshPositions();
  }
}
</script>

<style scoped>
.positions-container {
  padding: 20px;
}
.filter-form {
  margin-bottom: 20px;
}
.position-summary {
  margin-top: 20px;
  padding: 15px;
  background-color: #f5f7fa;
  border-radius: 4px;
}
.summary-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.label {
  font-weight: bold;
  color: #606266;
}
.value {
  font-size: 16px;
  font-weight: bold;
}
.profit {
  color: #f56c6c;
}
.loss {
  color: #67c23a;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both
}
</style>

<style>
.profit-row {
  background-color: rgba(245, 108, 108, 0.1);
}
.loss-row {
  background-color: rgba(103, 194, 58, 0.1);
}
</style>

```

### `/simpletrade/web-frontend/src/views/trading/Index.vue`
*(统计信息: 391 行, 13014 字符 [~1.86%])*
```
<template>
  <div class="trading-container">
    <el-row :gutter="20">
      <el-col :span="16">
        <el-card class="box-card">
          <div slot="header" class="clearfix">
            <span>交易下单</span>
            <el-tag type="success" style="margin-left: 10px;" v-if="connected">已连接</el-tag>
            <el-tag type="danger" style="margin-left: 10px;" v-else>未连接</el-tag>
            <el-button style="float: right; padding: 3px 0" type="text" @click="connectGateway">
              {{ connected ? '断开连接' : '连接交易接口' }}
            </el-button>
          </div>

          <el-form :model="orderForm" label-width="100px" :rules="rules" ref="orderForm">
            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="交易接口" prop="gateway">
                  <el-select v-model="orderForm.gateway" placeholder="请选择交易接口">
                    <el-option label="老虎证券" value="tiger"></el-option>
                    <el-option label="盈透证券" value="ib"></el-option>
                    <el-option label="CTP" value="ctp"></el-option>
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="交易账户" prop="account">
                  <el-select v-model="orderForm.account" placeholder="请选择交易账户">
                    <el-option label="模拟账户" value="demo"></el-option>
                    <el-option label="实盘账户" value="real"></el-option>
                  </el-select>
                </el-form-item>
              </el-col>
            </el-row>

            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="交易所" prop="exchange">
                  <el-select v-model="orderForm.exchange" placeholder="请选择交易所" @change="handleExchangeChange">
                    <el-option label="上海证券交易所" value="SSE"></el-option>
                    <el-option label="深圳证券交易所" value="SZSE"></el-option>
                    <el-option label="中国金融期货交易所" value="CFFEX"></el-option>
                    <el-option label="上海期货交易所" value="SHFE"></el-option>
                    <el-option label="大连商品交易所" value="DCE"></el-option>
                    <el-option label="郑州商品交易所" value="CZCE"></el-option>
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="合约代码" prop="symbol">
                  <el-select v-model="orderForm.symbol" placeholder="请选择合约代码" filterable>
                    <el-option
                      v-for="item in symbolOptions"
                      :key="item.value"
                      :label="item.label"
                      :value="item.value">
                    </el-option>
                  </el-select>
                </el-form-item>
              </el-col>
            </el-row>

            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="方向" prop="direction">
                  <el-radio-group v-model="orderForm.direction">
                    <el-radio label="LONG">买入</el-radio>
                    <el-radio label="SHORT">卖出</el-radio>
                  </el-radio-group>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="开平" prop="offset">
                  <el-radio-group v-model="orderForm.offset">
                    <el-radio label="OPEN">开仓</el-radio>
                    <el-radio label="CLOSE">平仓</el-radio>
                    <el-radio label="CLOSETODAY">平今</el-radio>
                    <el-radio label="CLOSEYESTERDAY">平昨</el-radio>
                  </el-radio-group>
                </el-form-item>
              </el-col>
            </el-row>

            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="价格类型" prop="orderType">
                  <el-select v-model="orderForm.orderType" placeholder="请选择价格类型">
                    <el-option label="限价单" value="LIMIT"></el-option>
                    <el-option label="市价单" value="MARKET"></el-option>
                    <el-option label="FAK单" value="FAK"></el-option>
                    <el-option label="FOK单" value="FOK"></el-option>
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item label="价格" prop="price" :required="orderForm.orderType === 'LIMIT'">
                  <el-input-number
                    v-model="orderForm.price"
                    :precision="2"
                    :step="0.01"
                    :min="0"
                    :disabled="orderForm.orderType === 'MARKET'"
                    controls-position="right">
                  </el-input-number>
                </el-form-item>
              </el-col>
            </el-row>

            <el-row :gutter="20">
              <el-col :span="12">
                <el-form-item label="数量" prop="volume">
                  <el-input-number
                    v-model="orderForm.volume"
                    :precision="0"
                    :step="1"
                    :min="1"
                    controls-position="right">
                  </el-input-number>
                </el-form-item>
              </el-col>
              <el-col :span="12">
                <el-form-item>
                  <el-button type="primary" @click="submitOrder('orderForm')">下单</el-button>
                  <el-button @click="resetForm('orderForm')">重置</el-button>
                </el-form-item>
              </el-col>
            </el-row>
          </el-form>
        </el-card>
      </el-col>

      <el-col :span="8">
        <el-card class="box-card">
          <div slot="header" class="clearfix">
            <span>行情信息</span>
            <el-button style="float: right; padding: 3px 0" type="text" @click="refreshQuote">刷新</el-button>
          </div>
          <div v-if="currentQuote.symbol" class="quote-info">
            <div class="quote-header">
              <h3>{{ currentQuote.name }} ({{ currentQuote.symbol }})</h3>
              <div :class="['price', currentQuote.change >= 0 ? 'price-up' : 'price-down']">
                {{ currentQuote.last }}
                <span class="change">
                  {{ currentQuote.change >= 0 ? '+' : '' }}{{ currentQuote.change }} ({{ currentQuote.changePercent }}%)
                </span>
              </div>
            </div>
            <el-divider></el-divider>
            <div class="quote-details">
              <div class="quote-item">
                <span class="label">开盘价:</span>
                <span class="value">{{ currentQuote.open }}</span>
              </div>
              <div class="quote-item">
                <span class="label">最高价:</span>
                <span class="value">{{ currentQuote.high }}</span>
              </div>
              <div class="quote-item">
                <span class="label">最低价:</span>
                <span class="value">{{ currentQuote.low }}</span>
              </div>
              <div class="quote-item">
                <span class="label">昨收价:</span>
                <span class="value">{{ currentQuote.preClose }}</span>
              </div>
              <div class="quote-item">
                <span class="label">成交量:</span>
                <span class="value">{{ currentQuote.volume }}</span>
              </div>
              <div class="quote-item">
                <span class="label">成交额:</span>
                <span class="value">{{ currentQuote.turnover }}</span>
              </div>
              <div class="quote-item">
                <span class="label">更新时间:</span>
                <span class="value">{{ currentQuote.updateTime }}</span>
              </div>
            </div>
          </div>
          <div v-else class="no-quote">
            <p>请选择合约查看行情</p>
          </div>
        </el-card>
      </el-col>
    </el-row>
  </div>
</template>

<script>
export default {
  name: 'TradingIndex',
  data() {
    return {
      connected: false,
      orderForm: {
        gateway: '',
        account: '',
        exchange: '',
        symbol: '',
        direction: 'LONG',
        offset: 'OPEN',
        orderType: 'LIMIT',
        price: 0,
        volume: 1
      },
      rules: {
        gateway: [{ required: true, message: '请选择交易接口', trigger: 'change' }],
        account: [{ required: true, message: '请选择交易账户', trigger: 'change' }],
        exchange: [{ required: true, message: '请选择交易所', trigger: 'change' }],
        symbol: [{ required: true, message: '请选择合约代码', trigger: 'change' }],
        direction: [{ required: true, message: '请选择方向', trigger: 'change' }],
        offset: [{ required: true, message: '请选择开平', trigger: 'change' }],
        orderType: [{ required: true, message: '请选择价格类型', trigger: 'change' }],
        volume: [{ required: true, message: '请输入数量', trigger: 'blur' }]
      },
      symbolOptions: [],
      currentQuote: {
        symbol: '',
        name: '',
        last: 0,
        change: 0,
        changePercent: 0,
        open: 0,
        high: 0,
        low: 0,
        preClose: 0,
        volume: 0,
        turnover: 0,
        updateTime: ''
      }
    }
  },
  methods: {
    connectGateway() {
      this.connected = !this.connected;
      this.$message({
        message: this.connected ? '交易接口连接成功' : '交易接口已断开',
        type: this.connected ? 'success' : 'warning'
      });
    },
    handleExchangeChange() {
      // 根据交易所获取合约列表
      this.symbolOptions = [
        { value: '600000', label: '浦发银行 (600000)' },
        { value: '601398', label: '工商银行 (601398)' },
        { value: '000001', label: '平安银行 (000001)' },
        { value: '000858', label: '五粮液 (000858)' }
      ];

      // 清空当前选择的合约
      this.orderForm.symbol = '';
      this.currentQuote = {
        symbol: '',
        name: '',
        last: 0,
        change: 0,
        changePercent: 0,
        open: 0,
        high: 0,
        low: 0,
        preClose: 0,
        volume: 0,
        turnover: 0,
        updateTime: ''
      };
    },
    submitOrder(formName) {
      this.$refs[formName].validate((valid) => {
        if (valid) {
          if (!this.connected) {
            this.$message.error('请先连接交易接口');
            return;
          }

          // 调用API提交订单
          this.$message({
            message: '订单已提交',
            type: 'success'
          });
        } else {
          this.$message.error('请完善订单信息');
          return false;
        }
      });
    },
    resetForm(formName) {
      this.$refs[formName].resetFields();
    },
    refreshQuote() {
      if (!this.orderForm.symbol) {
        this.$message.warning('请先选择合约');
        return;
      }

      // 模拟获取行情数据
      const symbolInfo = this.symbolOptions.find(item => item.value === this.orderForm.symbol);
      if (symbolInfo) {
        const name = symbolInfo.label.split(' ')[0];
        const last = (Math.random() * 20 + 10).toFixed(2);
        const preClose = (last * (1 + (Math.random() * 0.1 - 0.05))).toFixed(2);
        const change = (last - preClose).toFixed(2);
        const changePercent = ((change / preClose) * 100).toFixed(2);

        this.currentQuote = {
          symbol: this.orderForm.symbol,
          name: name,
          last: parseFloat(last),
          change: parseFloat(change),
          changePercent: parseFloat(changePercent),
          open: parseFloat((preClose * (1 + (Math.random() * 0.02 - 0.01))).toFixed(2)),
          high: parseFloat((last * (1 + Math.random() * 0.05)).toFixed(2)),
          low: parseFloat((last * (1 - Math.random() * 0.05)).toFixed(2)),
          preClose: parseFloat(preClose),
          volume: Math.floor(Math.random() * 10000000),
          turnover: Math.floor(Math.random() * 100000000),
          updateTime: new Date().toLocaleTimeString()
        };

        this.$message({
          message: '行情数据已更新',
          type: 'success'
        });
      }
    }
  },
  watch: {
    'orderForm.symbol'(newVal) {
      if (newVal) {
        this.refreshQuote();
      }
    }
  }
}
</script>

<style scoped>
.trading-container {
  padding: 20px;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both
}
.quote-info {
  padding: 10px;
}
.quote-header {
  text-align: center;
  margin-bottom: 10px;
}
.quote-header h3 {
  margin: 0 0 10px 0;
}
.price {
  font-size: 24px;
  font-weight: bold;
}
.price-up {
  color: #f56c6c;
}
.price-down {
  color: #67c23a;
}
.change {
  font-size: 14px;
  margin-left: 5px;
}
.quote-details {
  margin-top: 10px;
}
.quote-item {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
}
.label {
  color: #909399;
}
.no-quote {
  height: 200px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #909399;
}
</style>

```

### `/simpletrade/web-frontend/src/views/trading/Orders.vue`
*(统计信息: 367 行, 11387 字符 [~1.63%])*
```
<template>
  <div class="orders-container">
    <el-card class="box-card">
      <div slot="header" class="clearfix">
        <span>订单管理</span>
        <el-button style="float: right; padding: 3px 0" type="text" @click="refreshOrders">刷新</el-button>
      </div>

      <el-form :inline="true" :model="filterForm" class="filter-form">
        <el-form-item label="交易接口">
          <el-select v-model="filterForm.gateway" placeholder="请选择交易接口" clearable>
            <el-option label="老虎证券" value="tiger"></el-option>
            <el-option label="盈透证券" value="ib"></el-option>
            <el-option label="CTP" value="ctp"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="交易所">
          <el-select v-model="filterForm.exchange" placeholder="请选择交易所" clearable>
            <el-option label="上海证券交易所" value="SSE"></el-option>
            <el-option label="深圳证券交易所" value="SZSE"></el-option>
            <el-option label="中国金融期货交易所" value="CFFEX"></el-option>
            <el-option label="上海期货交易所" value="SHFE"></el-option>
            <el-option label="大连商品交易所" value="DCE"></el-option>
            <el-option label="郑州商品交易所" value="CZCE"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="合约代码">
          <el-input v-model="filterForm.symbol" placeholder="请输入合约代码" clearable></el-input>
        </el-form-item>

        <el-form-item label="订单状态">
          <el-select v-model="filterForm.status" placeholder="请选择订单状态" clearable>
            <el-option label="未成交" value="SUBMITTING"></el-option>
            <el-option label="部分成交" value="PARTTRADED"></el-option>
            <el-option label="全部成交" value="ALLTRADED"></el-option>
            <el-option label="已撤销" value="CANCELLED"></el-option>
            <el-option label="拒单" value="REJECTED"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="日期范围">
          <el-date-picker
            v-model="filterForm.dateRange"
            type="daterange"
            range-separator="至"
            start-placeholder="开始日期"
            end-placeholder="结束日期"
            format="yyyy-MM-dd"
            value-format="yyyy-MM-dd">
          </el-date-picker>
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="filterOrders">查询</el-button>
          <el-button @click="resetFilter">重置</el-button>
        </el-form-item>
      </el-form>

      <el-tabs v-model="activeTab" @tab-click="handleTabClick">
        <el-tab-pane label="活动订单" name="active"></el-tab-pane>
        <el-tab-pane label="历史订单" name="history"></el-tab-pane>
      </el-tabs>

      <el-table
        :data="ordersData"
        style="width: 100%"
        border
        v-loading="loading">
        <el-table-column prop="orderid" label="订单编号" width="120"></el-table-column>
        <el-table-column prop="symbol" label="合约代码" width="120"></el-table-column>
        <el-table-column prop="exchange" label="交易所" width="100"></el-table-column>
        <el-table-column prop="direction" label="方向" width="80">
          <template slot-scope="scope">
            <el-tag :type="scope.row.direction === 'LONG' ? 'danger' : 'success'">
              {{ scope.row.direction === 'LONG' ? '买入' : '卖出' }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="offset" label="开平" width="80">
          <template slot-scope="scope">
            <el-tag :type="scope.row.offset === 'OPEN' ? 'primary' : 'warning'">
              {{
                scope.row.offset === 'OPEN' ? '开仓' :
                scope.row.offset === 'CLOSE' ? '平仓' :
                scope.row.offset === 'CLOSETODAY' ? '平今' : '平昨'
              }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="price" label="价格" width="100"></el-table-column>
        <el-table-column prop="volume" label="总数量" width="80"></el-table-column>
        <el-table-column prop="traded" label="已成交" width="80"></el-table-column>
        <el-table-column prop="status" label="状态" width="100">
          <template slot-scope="scope">
            <el-tag :type="getStatusType(scope.row.status)">
              {{ getStatusText(scope.row.status) }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="orderTime" label="委托时间" width="180"></el-table-column>
        <el-table-column prop="cancelTime" label="撤销时间" width="180"></el-table-column>
        <el-table-column prop="gateway" label="接口" width="100"></el-table-column>
        <el-table-column label="操作" fixed="right" width="120">
          <template slot-scope="scope">
            <el-button
              size="mini"
              type="danger"
              :disabled="!canCancel(scope.row.status)"
              @click="handleCancel(scope.row)">撤单</el-button>
          </template>
        </el-table-column>
      </el-table>

      <div class="pagination-container">
        <el-pagination
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
          :current-page="currentPage"
          :page-sizes="[10, 20, 50, 100]"
          :page-size="pageSize"
          layout="total, sizes, prev, pager, next, jumper"
          :total="total">
        </el-pagination>
      </div>
    </el-card>
  </div>
</template>

<script>
export default {
  name: 'TradingOrders',
  data() {
    return {
      loading: false,
      activeTab: 'active',
      filterForm: {
        gateway: '',
        exchange: '',
        symbol: '',
        status: '',
        dateRange: []
      },
      ordersData: [
        {
          orderid: '2024041300001',
          symbol: '600000',
          exchange: 'SSE',
          direction: 'LONG',
          offset: 'OPEN',
          price: 10.25,
          volume: 1000,
          traded: 1000,
          status: 'ALLTRADED',
          orderTime: '2024-04-13 09:30:15',
          cancelTime: '',
          gateway: 'tiger'
        },
        {
          orderid: '2024041300002',
          symbol: '000001',
          exchange: 'SZSE',
          direction: 'SHORT',
          offset: 'CLOSE',
          price: 15.75,
          volume: 500,
          traded: 0,
          status: 'CANCELLED',
          orderTime: '2024-04-13 10:15:30',
          cancelTime: '2024-04-13 10:16:45',
          gateway: 'ib'
        },
        {
          orderid: '2024041300003',
          symbol: 'IF2106',
          exchange: 'CFFEX',
          direction: 'LONG',
          offset: 'OPEN',
          price: 5320.00,
          volume: 2,
          traded: 1,
          status: 'PARTTRADED',
          orderTime: '2024-04-13 11:05:22',
          cancelTime: '',
          gateway: 'ctp'
        },
        {
          orderid: '2024041300004',
          symbol: '600519',
          exchange: 'SSE',
          direction: 'LONG',
          offset: 'OPEN',
          price: 1800.50,
          volume: 100,
          traded: 0,
          status: 'SUBMITTING',
          orderTime: '2024-04-13 13:30:45',
          cancelTime: '',
          gateway: 'tiger'
        }
      ],
      currentPage: 1,
      pageSize: 10,
      total: 4
    }
  },
  methods: {
    refreshOrders() {
      this.loading = true;

      // 模拟API请求
      setTimeout(() => {
        this.loading = false;
        this.$message.success('订单数据已刷新');
      }, 1000);
    },
    filterOrders() {
      this.loading = true;

      // 模拟API请求
      setTimeout(() => {
        // 过滤数据
        const filteredData = this.ordersData.filter(order => {
          let match = true;
          if (this.filterForm.gateway && order.gateway !== this.filterForm.gateway) {
            match = false;
          }
          if (this.filterForm.exchange && order.exchange !== this.filterForm.exchange) {
            match = false;
          }
          if (this.filterForm.symbol && !order.symbol.includes(this.filterForm.symbol)) {
            match = false;
          }
          if (this.filterForm.status && order.status !== this.filterForm.status) {
            match = false;
          }
          // 日期范围过滤
          if (this.filterForm.dateRange && this.filterForm.dateRange.length === 2) {
            const orderDate = order.orderTime.split(' ')[0];
            if (orderDate < this.filterForm.dateRange[0] || orderDate > this.filterForm.dateRange[1]) {
              match = false;
            }
          }
          return match;
        });

        this.loading = false;
        this.$message.success('查询成功');
      }, 500);
    },
    resetFilter() {
      this.filterForm = {
        gateway: '',
        exchange: '',
        symbol: '',
        status: '',
        dateRange: []
      };
      this.filterOrders();
    },
    handleTabClick(tab) {
      if (tab.name === 'active') {
        // 加载活动订单
        this.ordersData = this.ordersData.filter(order =>
          order.status === 'SUBMITTING' || order.status === 'PARTTRADED'
        );
      } else {
        // 加载历史订单
        this.ordersData = this.ordersData.filter(order =>
          order.status === 'ALLTRADED' || order.status === 'CANCELLED' || order.status === 'REJECTED'
        );
      }
    },
    getStatusType(status) {
      switch (status) {
        case 'SUBMITTING':
          return 'info';
        case 'PARTTRADED':
          return 'warning';
        case 'ALLTRADED':
          return 'success';
        case 'CANCELLED':
          return '';
        case 'REJECTED':
          return 'danger';
        default:
          return '';
      }
    },
    getStatusText(status) {
      switch (status) {
        case 'SUBMITTING':
          return '未成交';
        case 'PARTTRADED':
          return '部分成交';
        case 'ALLTRADED':
          return '全部成交';
        case 'CANCELLED':
          return '已撤销';
        case 'REJECTED':
          return '拒单';
        default:
          return status;
      }
    },
    canCancel(status) {
      return status === 'SUBMITTING' || status === 'PARTTRADED';
    },
    handleCancel(row) {
      this.$confirm(`确定要撤销订单 ${row.orderid} 吗?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        // 调用API撤销订单
        this.$message.success(`订单 ${row.orderid} 撤销请求已提交`);

        // 模拟撤单成功
        setTimeout(() => {
          const index = this.ordersData.findIndex(item => item.orderid === row.orderid);
          if (index !== -1) {
            this.ordersData[index].status = 'CANCELLED';
            this.ordersData[index].cancelTime = new Date().toLocaleString();
            this.$message.success(`订单 ${row.orderid} 已成功撤销`);
          }
        }, 1000);
      }).catch(() => {
        this.$message.info('已取消撤单操作');
      });
    },
    handleSizeChange(val) {
      this.pageSize = val;
      this.filterOrders();
    },
    handleCurrentChange(val) {
      this.currentPage = val;
      this.filterOrders();
    }
  },
  created() {
    this.refreshOrders();
  }
}
</script>

<style scoped>
.orders-container {
  padding: 20px;
}
.filter-form {
  margin-bottom: 20px;
}
.pagination-container {
  margin-top: 20px;
  text-align: right;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both
}
</style>

```

### `/simpletrade/web-frontend/src/views/strategy/Index.vue`
*(统计信息: 209 行, 6526 字符 [~0.93%])*
```
<template>
  <div class="strategy-index-container">
    <el-card class="box-card">
      <div slot="header" class="clearfix">
        <span>策略列表</span>
        <el-button style="float: right;" type="primary" icon="el-icon-plus" @click="goToCreate">创建新策略</el-button>
      </div>

      <el-table
        :data="strategyList"
        style="width: 100%"
        border
        v-loading="loading">
        <el-table-column prop="name" label="策略名称" width="180"></el-table-column>
        <el-table-column prop="type" label="策略类型" width="120"></el-table-column>
        <el-table-column prop="symbols" label="交易品种" width="200">
           <template slot-scope="scope">
              {{ scope.row.symbols.join(', ') }}
           </template>
        </el-table-column>
        <el-table-column prop="status" label="状态" width="100">
          <template slot-scope="scope">
            <el-tag :type="scope.row.status === 'running' ? 'success' : 'info'">
              {{ scope.row.status === 'running' ? '运行中' : '已停止' }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="lastUpdateTime" label="最后更新时间" width="180"></el-table-column>
        <el-table-column label="操作" fixed="right" width="250">
          <template slot-scope="scope">
            <el-button
              size="mini"
              :type="scope.row.status === 'running' ? 'warning' : 'success'"
              @click="toggleStrategy(scope.row)">
              {{ scope.row.status === 'running' ? '停止' : '启动' }}
            </el-button>
            <el-button
              size="mini"
              @click="editStrategy(scope.row)">编辑</el-button>
            <el-button
              size="mini"
              type="danger"
              @click="deleteStrategy(scope.row)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>

       <div class="pagination-container">
        <el-pagination
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
          :current-page="currentPage"
          :page-sizes="[10, 20, 50, 100]"
          :page-size="pageSize"
          layout="total, sizes, prev, pager, next, jumper"
          :total="total">
        </el-pagination>
      </div>

    </el-card>
  </div>
</template>

<script>
// 导入 API 函数
import { getStrategies } from '@/api/strategies' // 假设 @ 指向 src 目录

export default {
  name: 'StrategyIndex',
  data() {
    return {
      loading: false,
      strategyList: [
        // Placeholder data
        {
          id: 'strategy1',
          name: '双均线策略',
          type: 'CTA',
          symbols: ['IF2106', 'rb2110'],
          status: 'running',
          lastUpdateTime: '2024-04-13 14:30:00'
        },
        {
          id: 'strategy2',
          name: 'RSI选股',
          type: 'Stock',
          symbols: ['600000', '000001'],
          status: 'stopped',
          lastUpdateTime: '2024-04-12 10:00:00'
        }
      ],
      currentPage: 1,
      pageSize: 10,
      total: 2
    }
  },
  methods: {
    goToCreate() {
      this.$router.push('/strategy/create');
    },
    fetchStrategies() {
      this.loading = true;
      // console.log(`Fetching strategies page ${this.currentPage} size ${this.pageSize}`);
      // setTimeout(() => {
      //   // Update strategyList and total based on API response
      //   this.loading = false;
      //    this.$message.info('策略列表已刷新 (模拟)');
      // }, 1000);

      // 调用 API 获取数据
      // 注意：当前后端 API 和 api/strategies.js 中的 getStrategies 暂未支持分页参数
      // 如果需要分页，需要前后端同步修改
      getStrategies() // 暂不传递分页或过滤参数
        .then(response => {
          // 检查后端返回的数据结构
          if (response.data && response.data.success) {
            // 假设后端返回的数据在 response.data.data 中
            this.strategyList = response.data.data;
            // 注意：后端目前似乎没有返回 total，暂时用列表长度代替，如果需要准确分页，后端需返回 total
            this.total = this.strategyList.length;
            this.$message.success('策略列表已更新');
          } else {
            // 处理后端返回的业务错误消息
            this.$message.error(response.data.message || '获取策略列表失败');
            this.strategyList = []; // 清空列表
            this.total = 0;
          }
        })
        .catch(error => {
          // 处理网络错误或其他JS异常
          console.error('获取策略列表失败:', error);
          this.$message.error('网络错误，无法获取策略列表');
          this.strategyList = []; // 清空列表
          this.total = 0;
        })
        .finally(() => {
          // 无论成功失败，最终都停止加载状态
          this.loading = false;
        });
    },
    toggleStrategy(row) {
      const action = row.status === 'running' ? '停止' : '启动';
      this.$confirm(`确定要${action}策略 ${row.name} 吗?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        // TODO: Call API to start/stop strategy
        console.log(`${action} strategy:`, row);
        row.status = row.status === 'running' ? 'stopped' : 'running'; // Toggle status locally for demo
        this.$message({
          type: 'success',
          message: `${action}请求已发送!`
        });
      }).catch(() => {
        this.$message({ type: 'info', message: '已取消操作' });
      });
    },
    editStrategy(row) {
      // Navigate to create/edit page with strategy ID
      this.$router.push({ path: '/strategy/create', query: { id: row.id } });
    },
    deleteStrategy(row) {
       this.$confirm(`确定要删除策略 ${row.name} 吗? 此操作不可恢复。`, '警告', {
        confirmButtonText: '确定删除',
        cancelButtonText: '取消',
        type: 'error' // Use error type for deletion confirmation
      }).then(() => {
        // TODO: Call API to delete strategy
        console.log('Delete strategy:', row);
        this.strategyList = this.strategyList.filter(s => s.id !== row.id); // Remove locally for demo
        this.total = this.strategyList.length; // Update total for demo
        this.$message({ type: 'success', message: '删除请求已发送!' });
      }).catch(() => {
        this.$message({ type: 'info', message: '已取消删除' });
      });
    },
    handleSizeChange(val) {
      this.pageSize = val;
      this.fetchStrategies();
    },
    handleCurrentChange(val) {
      this.currentPage = val;
      this.fetchStrategies();
    }
  },
  created() {
    this.fetchStrategies();
  }
}
</script>

<style scoped>
.strategy-index-container {
  padding: 20px;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both
}
.pagination-container {
    margin-top: 20px;
    text-align: right;
}
</style>
```

### `/simpletrade/web-frontend/src/views/strategy/Create.vue`
*(统计信息: 202 行, 7501 字符 [~1.07%])*
```
<template>
  <div class="strategy-create-container">
    <el-card class="box-card">
      <div slot="header" class="clearfix">
        <span>{{ isEditing ? '编辑策略' : '创建新策略' }}</span>
         <el-button style="float: right; padding: 3px 0" type="text" @click="goBack">返回列表</el-button>
      </div>

      <el-form :model="strategyForm" :rules="rules" ref="strategyForm" label-width="120px">
        <el-form-item label="策略名称" prop="name">
          <el-input v-model="strategyForm.name" placeholder="请输入策略名称"></el-input>
        </el-form-item>

        <el-form-item label="策略类型" prop="type">
            <el-select v-model="strategyForm.type" placeholder="选择策略类型">
                <el-option label="CTA策略" value="cta"></el-option>
                <el-option label="选股策略" value="stock"></el-option>
                <el-option label="套利策略" value="arbitrage"></el-option>
            </el-select>
        </el-form-item>

        <el-form-item label="策略模板/文件" prop="template">
           <!-- TODO: Implement selection or upload based on backend capabilities -->
           <el-select v-model="strategyForm.template" placeholder="选择策略模板">
               <el-option label="双均线 (DualMA)" value="DualMA"></el-option>
               <el-option label="布林带 (Bollinger)" value="Bollinger"></el-option>
               <el-option label="自定义..." value="custom"></el-option>
           </el-select>
           <!-- Or potentially an upload component if using custom files -->
        </el-form-item>

        <el-form-item label="交易品种" prop="symbols">
            <el-select
                v-model="strategyForm.symbols"
                multiple
                filterable
                allow-create
                default-first-option
                placeholder="请输入或选择交易品种">
                <!-- TODO: Load symbol options dynamically -->
                <el-option
                  v-for="item in symbolOptions"
                  :key="item.value"
                  :label="item.label"
                  :value="item.value">
                </el-option>
            </el-select>
        </el-form-item>

        <el-form-item label="K线周期" prop="interval">
            <el-select v-model="strategyForm.interval" placeholder="选择K线周期">
                <el-option label="1分钟" value="1m"></el-option>
                <el-option label="5分钟" value="5m"></el-option>
                <el-option label="15分钟" value="15m"></el-option>
                <el-option label="30分钟" value="30m"></el-option>
                <el-option label="1小时" value="1h"></el-option>
                <el-option label="日线" value="1d"></el-option>
            </el-select>
        </el-form-item>

        <el-divider>策略参数</el-divider>
        <!-- TODO: Dynamically generate parameter fields based on selected template -->
         <el-form-item v-for="(param, index) in strategyForm.parameters" :key="index" :label="param.label || `参数 ${index + 1}`">
            <el-input v-model="param.value" :placeholder="param.placeholder || '请输入参数值'"></el-input>
            <!-- Consider different input types based on param type (number, string, boolean) -->
        </el-form-item>
        <el-button type="text" @click="addParameter">添加参数</el-button> <!-- For custom params -->

        <el-divider>运行设置</el-divider>
         <el-form-item label="初始资金" prop="initialCapital">
              <el-input-number v-model="strategyForm.initialCapital" :min="0" :step="10000"></el-input-number>
         </el-form-item>
        <!-- Add other settings like commission, slippage if needed -->

        <el-form-item style="margin-top: 20px;">
          <el-button type="primary" @click="submitForm('strategyForm')" :loading="submitting">{{ isEditing ? '保存修改' : '创建策略' }}</el-button>
          <el-button @click="goBack">取消</el-button>
        </el-form-item>
      </el-form>
    </el-card>
  </div>
</template>

<script>
export default {
  name: 'StrategyCreate',
  data() {
    return {
      isEditing: false,
      strategyId: null,
      submitting: false,
      strategyForm: {
        name: '',
        type: 'cta',
        template: '',
        symbols: [],
        interval: '1d',
        parameters: [
            // Example dynamic parameter structure
            // { key: 'fast_period', label: '快线周期', value: '12', type: 'number' },
            // { key: 'slow_period', label: '慢线周期', value: '26', type: 'number' },
        ],
        initialCapital: 100000,
      },
      symbolOptions: [ // Placeholder
        { value: 'IF2106', label: 'IF2106' },
        { value: 'rb2110', label: 'rb2110' },
      ],
      rules: {
        name: [{ required: true, message: '请输入策略名称', trigger: 'blur' }],
        type: [{ required: true, message: '请选择策略类型', trigger: 'change' }],
        template: [{ required: true, message: '请选择策略模板', trigger: 'change' }],
        symbols: [{ required: true, message: '请至少选择一个交易品种', trigger: 'change' }],
        interval: [{ required: true, message: '请选择K线周期', trigger: 'change' }]
      }
    }
  },
  methods: {
    goBack() {
      this.$router.push('/strategy/index');
    },
    loadStrategyData(id) {
      this.submitting = true;
      // TODO: Call API to fetch strategy data for editing
      console.log('Loading strategy data for id:', id);
      setTimeout(() => {
           // Simulate loading existing data
           this.strategyForm = {
                name: '双均线策略 (编辑)',
                type: 'CTA',
                template: 'DualMA',
                symbols: ['IF2106', 'rb2110'],
                interval: '1h',
                parameters: [
                    { key: 'fast_ma', label: '快线周期', value: '10' },
                    { key: 'slow_ma', label: '慢线周期', value: '20' }
                ],
                initialCapital: 150000,
           };
           this.submitting = false;
           this.$message.success('策略数据已加载 (模拟)');
      }, 1000);
    },
    submitForm(formName) {
      this.$refs[formName].validate((valid) => {
        if (valid) {
          this.submitting = true;
          // TODO: Call API to save (create or update) strategy
          const payload = { ...this.strategyForm };
          // Convert parameters array to object if needed by backend
          // payload.parameters = {};
          // this.strategyForm.parameters.forEach(p => { payload.parameters[p.key] = p.value; });

          console.log('Submitting strategy data:', payload);

          setTimeout(() => {
            this.submitting = false;
            this.$message({
              message: `${this.isEditing ? '更新' : '创建'}成功 (模拟)`,
              type: 'success'
            });
            this.goBack(); // Go back to list after successful submission
          }, 1500);

        } else {
          console.log('error submit!!');
          return false;
        }
      });
    },
    addParameter() {
        this.strategyForm.parameters.push({ key: '', label: '', value: '', placeholder: '自定义参数' });
    }
    // TODO: Method to load parameters based on selected template
  },
  created() {
    if (this.$route.query.id) {
      this.isEditing = true;
      this.strategyId = this.$route.query.id;
      this.loadStrategyData(this.strategyId);
    }
     // TODO: Fetch dynamic symbol options
  }
}
</script>

<style scoped>
.strategy-create-container {
  padding: 20px;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both
}
.el-select {
    width: 100%;
}
</style>
```

### `/simpletrade/web-frontend/src/views/data/Export.vue`
*(统计信息: 208 行, 6550 字符 [~0.94%])*
```
<template>
  <div class="data-export-container">
    <el-card class="box-card">
      <div slot="header" class="clearfix">
        <span>数据导出</span>
      </div>
      <el-form :model="exportForm" label-width="100px">
        <el-form-item label="数据类型">
          <el-select v-model="exportForm.dataType" placeholder="请选择数据类型">
            <el-option label="K线数据" value="kline"></el-option>
            <el-option label="Tick数据" value="tick"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="交易所">
          <el-select v-model="exportForm.exchange" placeholder="请选择交易所">
            <el-option label="上海证券交易所" value="SSE"></el-option>
            <el-option label="深圳证券交易所" value="SZSE"></el-option>
            <el-option label="中国金融期货交易所" value="CFFEX"></el-option>
            <el-option label="上海期货交易所" value="SHFE"></el-option>
            <el-option label="大连商品交易所" value="DCE"></el-option>
            <el-option label="郑州商品交易所" value="CZCE"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="合约代码">
          <el-input v-model="exportForm.symbol" placeholder="请输入合约代码"></el-input>
        </el-form-item>

        <el-form-item label="时间周期" v-if="exportForm.dataType === 'kline'">
          <el-select v-model="exportForm.interval" placeholder="请选择时间周期">
            <el-option label="1分钟" value="1m"></el-option>
            <el-option label="5分钟" value="5m"></el-option>
            <el-option label="15分钟" value="15m"></el-option>
            <el-option label="30分钟" value="30m"></el-option>
            <el-option label="1小时" value="1h"></el-option>
            <el-option label="日线" value="1d"></el-option>
            <el-option label="周线" value="1w"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="开始日期">
          <el-date-picker
            v-model="exportForm.startDate"
            type="date"
            placeholder="选择开始日期"
            format="yyyy-MM-dd"
            value-format="yyyy-MM-dd">
          </el-date-picker>
        </el-form-item>

        <el-form-item label="结束日期">
          <el-date-picker
            v-model="exportForm.endDate"
            type="date"
            placeholder="选择结束日期"
            format="yyyy-MM-dd"
            value-format="yyyy-MM-dd">
          </el-date-picker>
        </el-form-item>

        <el-form-item label="导出格式">
          <el-radio-group v-model="exportForm.format">
            <el-radio label="csv">CSV</el-radio>
            <el-radio label="excel">Excel</el-radio>
            <el-radio label="json">JSON</el-radio>
          </el-radio-group>
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="submitExport">导出数据</el-button>
          <el-button @click="resetForm">重置</el-button>
        </el-form-item>
      </el-form>
    </el-card>

    <el-card class="box-card" style="margin-top: 20px;">
      <div slot="header" class="clearfix">
        <span>导出历史</span>
        <el-button style="float: right; padding: 3px 0" type="text" @click="refreshHistory">刷新</el-button>
      </div>
      <el-table :data="exportHistory" style="width: 100%">
        <el-table-column prop="id" label="ID" width="80"></el-table-column>
        <el-table-column prop="dataType" label="数据类型" width="100"></el-table-column>
        <el-table-column prop="symbol" label="合约代码" width="120"></el-table-column>
        <el-table-column prop="dateRange" label="日期范围"></el-table-column>
        <el-table-column prop="format" label="格式" width="80"></el-table-column>
        <el-table-column prop="status" label="状态" width="100">
          <template slot-scope="scope">
            <el-tag :type="scope.row.status === '完成' ? 'success' : scope.row.status === '处理中' ? 'warning' : 'danger'">
              {{ scope.row.status }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="createTime" label="创建时间" width="180"></el-table-column>
        <el-table-column label="操作" width="120">
          <template slot-scope="scope">
            <el-button
              size="mini"
              type="primary"
              :disabled="scope.row.status !== '完成'"
              @click="downloadFile(scope.row)">下载</el-button>
          </template>
        </el-table-column>
      </el-table>
    </el-card>
  </div>
</template>

<script>
export default {
  name: 'DataExport',
  data() {
    return {
      exportForm: {
        dataType: 'kline',
        exchange: '',
        symbol: '',
        interval: '1d',
        startDate: '',
        endDate: '',
        format: 'csv'
      },
      exportHistory: [
        {
          id: 1,
          dataType: 'K线数据',
          symbol: '600000',
          dateRange: '2023-01-01 至 2023-12-31',
          format: 'CSV',
          status: '完成',
          createTime: '2024-04-10 10:30:00'
        },
        {
          id: 2,
          dataType: 'Tick数据',
          symbol: '000001',
          dateRange: '2023-06-01 至 2023-06-30',
          format: 'Excel',
          status: '处理中',
          createTime: '2024-04-12 15:45:00'
        }
      ]
    }
  },
  methods: {
    submitExport() {
      // 调用API导出数据
      this.$message({
        message: '数据导出请求已提交，请等待处理',
        type: 'success'
      });

      // 模拟添加到导出历史
      const newExport = {
        id: this.exportHistory.length + 1,
        dataType: this.exportForm.dataType === 'kline' ? 'K线数据' : 'Tick数据',
        symbol: this.exportForm.symbol,
        dateRange: `${this.exportForm.startDate} 至 ${this.exportForm.endDate}`,
        format: this.exportForm.format.toUpperCase(),
        status: '处理中',
        createTime: new Date().toLocaleString()
      };
      this.exportHistory.unshift(newExport);
    },
    resetForm() {
      this.exportForm = {
        dataType: 'kline',
        exchange: '',
        symbol: '',
        interval: '1d',
        startDate: '',
        endDate: '',
        format: 'csv'
      };
    },
    refreshHistory() {
      // 调用API获取导出历史
      this.$message({
        message: '导出历史已刷新',
        type: 'success'
      });
    },
    downloadFile(row) {
      // 调用API下载文件
      this.$message({
        message: `正在下载 ${row.symbol} 的${row.dataType}`,
        type: 'success'
      });
    }
  }
}
</script>

<style scoped>
.data-export-container {
  padding: 20px;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both
}
</style>

```

### `/simpletrade/web-frontend/src/views/data/Import.vue`
*(统计信息: 156 行, 4478 字符 [~0.64%])*
```
<template>
  <div class="data-import-container">
    <el-card class="box-card">
      <div slot="header" class="clearfix">
        <span>数据导入</span>
      </div>
      <el-form :model="importForm" label-width="100px">
        <el-form-item label="数据类型">
          <el-select v-model="importForm.dataType" placeholder="请选择数据类型">
            <el-option label="K线数据" value="kline"></el-option>
            <el-option label="Tick数据" value="tick"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="交易所">
          <el-select v-model="importForm.exchange" placeholder="请选择交易所">
            <el-option label="上海证券交易所" value="SSE"></el-option>
            <el-option label="深圳证券交易所" value="SZSE"></el-option>
            <el-option label="中国金融期货交易所" value="CFFEX"></el-option>
            <el-option label="上海期货交易所" value="SHFE"></el-option>
            <el-option label="大连商品交易所" value="DCE"></el-option>
            <el-option label="郑州商品交易所" value="CZCE"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="合约代码">
          <el-input v-model="importForm.symbol" placeholder="请输入合约代码"></el-input>
        </el-form-item>

        <el-form-item label="时间周期" v-if="importForm.dataType === 'kline'">
          <el-select v-model="importForm.interval" placeholder="请选择时间周期">
            <el-option label="1分钟" value="1m"></el-option>
            <el-option label="5分钟" value="5m"></el-option>
            <el-option label="15分钟" value="15m"></el-option>
            <el-option label="30分钟" value="30m"></el-option>
            <el-option label="1小时" value="1h"></el-option>
            <el-option label="日线" value="1d"></el-option>
            <el-option label="周线" value="1w"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="开始日期">
          <el-date-picker
            v-model="importForm.startDate"
            type="date"
            placeholder="选择开始日期"
            format="yyyy-MM-dd"
            value-format="yyyy-MM-dd">
          </el-date-picker>
        </el-form-item>

        <el-form-item label="结束日期">
          <el-date-picker
            v-model="importForm.endDate"
            type="date"
            placeholder="选择结束日期"
            format="yyyy-MM-dd"
            value-format="yyyy-MM-dd">
          </el-date-picker>
        </el-form-item>

        <el-form-item label="数据文件">
          <el-upload
            class="upload-demo"
            action="/api/data/upload"
            :on-preview="handlePreview"
            :on-remove="handleRemove"
            :before-remove="beforeRemove"
            :on-success="handleSuccess"
            :on-error="handleError"
            :file-list="fileList">
            <el-button size="small" type="primary">点击上传</el-button>
            <div slot="tip" class="el-upload__tip">只能上传CSV文件，且不超过10MB</div>
          </el-upload>
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="submitImport">导入数据</el-button>
          <el-button @click="resetForm">重置</el-button>
        </el-form-item>
      </el-form>
    </el-card>
  </div>
</template>

<script>
export default {
  name: 'DataImport',
  data() {
    return {
      importForm: {
        dataType: 'kline',
        exchange: '',
        symbol: '',
        interval: '1d',
        startDate: '',
        endDate: ''
      },
      fileList: []
    }
  },
  methods: {
    submitImport() {
      // 调用API导入数据
      this.$message({
        message: '数据导入请求已提交，请等待处理',
        type: 'success'
      });
    },
    resetForm() {
      this.importForm = {
        dataType: 'kline',
        exchange: '',
        symbol: '',
        interval: '1d',
        startDate: '',
        endDate: ''
      };
      this.fileList = [];
    },
    handleRemove(file, fileList) {
      console.log(file, fileList);
    },
    handlePreview(file) {
      console.log(file);
    },
    beforeRemove(file) {
      return this.$confirm(`确定移除 ${file.name}？`);
    },
    handleSuccess(response, file, fileList) {
      this.$message({
        message: '文件上传成功',
        type: 'success'
      });
    },
    handleError(err, file, fileList) {
      this.$message.error('文件上传失败');
    }
  }
}
</script>

<style scoped>
.data-import-container {
  padding: 20px;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both
}
</style>

```

### `/simpletrade/web-frontend/src/views/analysis/Charts.vue`
*(统计信息: 173 行, 4869 字符 [~0.70%])*
```
<template>
  <div class="charts-container">
    <el-card class="box-card">
      <div slot="header" class="clearfix">
        <span>图表分析</span>
      </div>

      <el-form :inline="true" :model="chartForm" class="chart-form">
        <el-form-item label="交易所">
          <el-select v-model="chartForm.exchange" placeholder="请选择交易所" @change="handleExchangeChange">
            <el-option label="上海证券交易所" value="SSE"></el-option>
            <el-option label="深圳证券交易所" value="SZSE"></el-option>
            <el-option label="中国金融期货交易所" value="CFFEX"></el-option>
            <el-option label="上海期货交易所" value="SHFE"></el-option>
            <el-option label="大连商品交易所" value="DCE"></el-option>
            <el-option label="郑州商品交易所" value="CZCE"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="合约代码">
          <el-select v-model="chartForm.symbol" placeholder="请选择合约代码" filterable>
            <el-option
              v-for="item in symbolOptions"
              :key="item.value"
              :label="item.label"
              :value="item.value">
            </el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="时间周期">
          <el-select v-model="chartForm.interval" placeholder="请选择时间周期">
            <el-option label="1分钟" value="1m"></el-option>
            <el-option label="5分钟" value="5m"></el-option>
            <el-option label="15分钟" value="15m"></el-option>
            <el-option label="30分钟" value="30m"></el-option>
            <el-option label="1小时" value="1h"></el-option>
            <el-option label="日线" value="1d"></el-option>
            <el-option label="周线" value="1w"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="日期范围">
          <el-date-picker
            v-model="chartForm.dateRange"
            type="daterange"
            range-separator="至"
            start-placeholder="开始日期"
            end-placeholder="结束日期"
            format="yyyy-MM-dd"
            value-format="yyyy-MM-dd">
          </el-date-picker>
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="loadChartData">加载数据</el-button>
        </el-form-item>
      </el-form>

      <div class="chart-container" v-loading="loading">
        <div id="price-chart" class="chart"></div>
      </div>

      <div class="indicators-panel">
        <el-divider content-position="left">技术指标</el-divider>
        <el-checkbox-group v-model="selectedIndicators" @change="updateIndicators">
          <el-checkbox label="ma">移动平均线 (MA)</el-checkbox>
          <el-checkbox label="ema">指数移动平均线 (EMA)</el-checkbox>
          <el-checkbox label="boll">布林带 (BOLL)</el-checkbox>
          <el-checkbox label="macd">MACD</el-checkbox>
          <el-checkbox label="kdj">KDJ</el-checkbox>
          <el-checkbox label="rsi">RSI</el-checkbox>
        </el-checkbox-group>
      </div>
    </el-card>
  </div>
</template>

<script>
export default {
  name: 'AnalysisCharts',
  data() {
    return {
      chartForm: {
        exchange: '',
        symbol: '',
        interval: '1d',
        dateRange: []
      },
      symbolOptions: [],
      selectedIndicators: ['ma', 'boll'],
      loading: false,
      chart: null
    }
  },
  mounted() {
    // 在实际项目中，这里应该引入ECharts或其他图表库
    this.$nextTick(() => {
      this.initChart();
    });
  },
  methods: {
    initChart() {
      // 初始化图表
      // 在实际项目中，这里应该使用ECharts或其他图表库初始化图表
      console.log('初始化图表');
    },
    handleExchangeChange() {
      // 根据交易所获取合约列表
      this.symbolOptions = [
        { value: '600000', label: '浦发银行 (600000)' },
        { value: '601398', label: '工商银行 (601398)' },
        { value: '000001', label: '平安银行 (000001)' },
        { value: '000858', label: '五粮液 (000858)' }
      ];
    },
    loadChartData() {
      if (!this.chartForm.exchange || !this.chartForm.symbol || !this.chartForm.dateRange.length) {
        this.$message.warning('请完善查询条件');
        return;
      }

      this.loading = true;

      // 模拟API请求
      setTimeout(() => {
        this.loading = false;
        this.$message.success('数据加载成功');
        // 在实际项目中，这里应该调用API获取数据并更新图表
      }, 1500);
    },
    updateIndicators(value) {
      console.log('选中的指标:', value);
      // 在实际项目中，这里应该更新图表显示的指标
    }
  }
}
</script>

<style scoped>
.charts-container {
  padding: 20px;
}
.chart-form {
  margin-bottom: 20px;
}
.chart-container {
  width: 100%;
  height: 500px;
  background-color: #f5f7fa;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
}
.chart {
  width: 100%;
  height: 100%;
}
.indicators-panel {
  margin-top: 20px;
}
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}
.clearfix:after {
  clear: both
}
</style>

```

### `/simpletrade/web-frontend/src/components/MainLayout.vue`
*(统计信息: 128 行, 3524 字符 [~0.50%])*
```
<template>
  <el-container style="height: 100vh;">
    <!-- Sidebar -->
    <el-aside width="250px" style="background-color: #304156; color: white;">
      <div style="height: 60px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; border-bottom: 1px solid #1f2d3d;">
        SimpleTrade
      </div>

      <!-- Navigation Menu -->
      <el-menu
        :default-active="activeIndex"
        class="el-menu-vertical"
        background-color="#304156"
        text-color="#bfcbd9"
        active-text-color="#409EFF">

        <el-menu-item index="/strategy-center" @click="$router.push('/strategy-center')">
          <i class="el-icon-s-data"></i>
          <span slot="title">策略中心</span>
        </el-menu-item>

        <el-menu-item index="/trading-center" @click="$router.push('/trading-center')">
          <i class="el-icon-s-finance"></i>
          <span slot="title">交易中心</span>
        </el-menu-item>

        <el-menu-item index="/ai-analysis" @click="$router.push('/ai-analysis')">
          <i class="el-icon-s-marketing"></i>
          <span slot="title">AI分析</span>
        </el-menu-item>

        <el-menu-item index="/user-center" @click="$router.push('/user-center')">
          <i class="el-icon-user"></i>
          <span slot="title">用户中心</span>
        </el-menu-item>
      </el-menu>


    </el-aside>

    <!-- Main Content -->
    <el-container>
      <el-header style="background-color: white; box-shadow: 0 1px 4px rgba(0,21,41,.08); line-height: 60px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <h2 style="font-size: 18px; font-weight: 600; color: #303133;">{{ pageTitle }}</h2>
          <div>
            <el-dropdown>
              <span class="el-dropdown-link">
                <el-avatar size="small" icon="el-icon-user"></el-avatar>
                <span style="margin-left: 8px;">张三</span>
                <i class="el-icon-arrow-down el-icon--right"></i>
              </span>
              <el-dropdown-menu slot="dropdown">
                <el-dropdown-item icon="el-icon-user">个人中心</el-dropdown-item>
                <el-dropdown-item icon="el-icon-setting">账户设置</el-dropdown-item>
                <el-dropdown-item divided icon="el-icon-switch-button">退出登录</el-dropdown-item>
              </el-dropdown-menu>
            </el-dropdown>
          </div>
        </div>
      </el-header>

      <el-main style="background-color: #f0f2f5; padding: 20px;">
        <slot></slot>
      </el-main>
    </el-container>
  </el-container>
</template>

<script>
export default {
  name: 'MainLayout',
  data() {
    return {
      sidebarOpen: false,
      activeIndex: ''
    }
  },
  computed: {
    pageTitle() {
      const routeMap = {
        '/strategy-center': '策略中心',
        '/trading-center': '交易中心',
        '/ai-analysis': 'AI分析',
        '/user-center': '用户中心'
      };
      return routeMap[this.$route.path] || '';
    }
  },
  methods: {

    toggleSidebar() {
      this.sidebarOpen = !this.sidebarOpen;
    },
    isActive(path) {
      return this.$route.path.startsWith(path);
    }
  },
  watch: {
    $route: {
      immediate: true,
      handler(route) {
        this.activeIndex = route.path;
      }
    }
  },
  mounted() {
    // 初始化组件
  }
}
</script>

<style>
.el-menu {
  border-right: none;
}

.el-menu-vertical:not(.el-menu--collapse) {
  width: 250px;
}

.el-dropdown-link {
  cursor: pointer;
  display: flex;
  align-items: center;
}
</style>

```

### `/simpletrade/web-frontend/src/components/Sidebar.vue`
*(统计信息: 120 行, 2902 字符 [~0.42%])*
```
<template>
  <el-menu
    :default-active="activeIndex"
    class="sidebar-menu"
    :collapse="isCollapse"
    background-color="#304156"
    text-color="#bfcbd9"
    active-text-color="#409EFF"
    router>

    <div class="logo-container">
      <!-- <img src="../assets/logo.png" alt="Logo" class="logo" v-if="!isCollapse"> -->
      <span class="title" v-if="!isCollapse">SimpleTrade</span>
    </div>

    <el-menu-item index="/">
      <i class="el-icon-s-home"></i>
      <span slot="title">仪表盘</span>
    </el-menu-item>

    <el-submenu index="data">
      <template slot="title">
        <i class="el-icon-s-data"></i>
        <span>数据管理</span>
      </template>
      <el-menu-item index="/data">数据概览</el-menu-item>
      <el-menu-item index="/data/import">数据导入</el-menu-item>
      <el-menu-item index="/data/export">数据导出</el-menu-item>
    </el-submenu>

    <el-submenu index="analysis">
      <template slot="title">
        <i class="el-icon-s-marketing"></i>
        <span>数据分析</span>
      </template>
      <el-menu-item index="/analysis">技术指标</el-menu-item>
      <el-menu-item index="/analysis/charts">图表分析</el-menu-item>
    </el-submenu>

    <el-submenu index="trading">
      <template slot="title">
        <i class="el-icon-s-finance"></i>
        <span>交易中心</span>
      </template>
      <el-menu-item index="/trading">交易下单</el-menu-item>
      <el-menu-item index="/trading/positions">持仓管理</el-menu-item>
      <el-menu-item index="/trading/orders">订单管理</el-menu-item>
    </el-submenu>

    <el-submenu index="strategy">
      <template slot="title">
        <i class="el-icon-s-operation"></i>
        <span>策略管理</span>
      </template>
      <el-menu-item index="/strategy">策略列表</el-menu-item>
      <el-menu-item index="/strategy/create">创建策略</el-menu-item>
    </el-submenu>

    <el-menu-item index="/backtest">
      <i class="el-icon-s-opportunity"></i>
      <span slot="title">回测系统</span>
    </el-menu-item>

    <el-menu-item index="/ai">
      <i class="el-icon-s-platform"></i>
      <span slot="title">AI分析</span>
    </el-menu-item>

    <el-menu-item index="/settings">
      <i class="el-icon-setting"></i>
      <span slot="title">系统设置</span>
    </el-menu-item>
  </el-menu>
</template>

<script>
export default {
  name: 'Sidebar',
  props: {
    isCollapse: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    activeIndex() {
      return this.$route.path;
    }
  }
}
</script>

<style scoped>
.sidebar-menu {
  height: 100%;
  border-right: none;
}
.sidebar-menu:not(.el-menu--collapse) {
  width: 220px;
}
.logo-container {
  height: 60px;
  padding: 10px 0;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
}
.logo {
  width: 32px;
  height: 32px;
  margin-right: 10px;
}
.title {
  color: #fff;
  font-size: 18px;
  font-weight: bold;
}
</style>

```

### `/simpletrade/web-frontend/src/components/Breadcrumb.vue`
*(统计信息: 70 行, 1509 字符 [~0.22%])*
```
<template>
  <el-breadcrumb class="app-breadcrumb" separator="/">
    <transition-group name="breadcrumb">
      <el-breadcrumb-item v-for="(item, index) in levelList" :key="item.path">
        <span v-if="index === levelList.length - 1" class="no-redirect">{{ item.meta.title }}</span>
        <a v-else @click.prevent="handleLink(item)">{{ item.meta.title }}</a>
      </el-breadcrumb-item>
    </transition-group>
  </el-breadcrumb>
</template>

<script>
export default {
  name: 'Breadcrumb',
  data() {
    return {
      levelList: null
    }
  },
  watch: {
    $route() {
      this.getBreadcrumb()
    }
  },
  created() {
    this.getBreadcrumb()
  },
  methods: {
    getBreadcrumb() {
      // 面包屑仅显示有meta.title的路由
      let matched = this.$route.matched.filter(item => item.meta && item.meta.title)

      // 如果首页不在路由中，手动添加
      const first = matched[0]
      if (first && first.path !== '/') {
        matched = [{ path: '/', meta: { title: '首页' } }].concat(matched)
      }

      this.levelList = matched
    },
    handleLink(item) {
      const { path } = item
      this.$router.push(path)
    }
  }
}
</script>

<style scoped>
.app-breadcrumb {
  display: inline-block;
  font-size: 14px;
  line-height: 50px;
  margin-left: 8px;
}
.app-breadcrumb .no-redirect {
  color: #97a8be;
  cursor: text;
}
.breadcrumb-enter-active,
.breadcrumb-leave-active {
  transition: all 0.5s;
}
.breadcrumb-enter,
.breadcrumb-leave-to {
  opacity: 0;
  transform: translateX(20px);
}
</style>

```

### `/simpletrade/web-frontend/src/api/data.js`
*(统计信息: 108 行, 2414 字符 [~0.35%])*
```javascript
/**
 * 数据管理API
 */

import axios from 'axios'

const API_BASE_URL = 'http://localhost:8003/api'

/**
 * 获取数据概览
 */
export function getDataOverview() {
  return axios.get(`${API_BASE_URL}/data/overview`)
}

/**
 * 获取K线数据
 * @param {string} symbol 代码
 * @param {string} exchange 交易所
 * @param {string} interval 周期
 * @param {string} startDate 开始日期
 * @param {string} endDate 结束日期
 */
export function getBarData(symbol, exchange, interval, startDate, endDate) {
  let url = `${API_BASE_URL}/data/bars?symbol=${symbol}&exchange=${exchange}&interval=${interval}&start_date=${startDate}`

  if (endDate) {
    url += `&end_date=${endDate}`
  }

  return axios.get(url)
}

/**
 * 导入数据
 * @param {object} data 导入数据参数
 */
export function importData(data) {
  return axios.post(`${API_BASE_URL}/data/import`, data)
}

/**
 * 导出数据
 * @param {object} data 导出数据参数
 */
export function exportData(data) {
  return axios.post(`${API_BASE_URL}/data/export`, data)
}

/**
 * 删除数据
 * @param {string} symbol 代码
 * @param {string} exchange 交易所
 * @param {string} interval 周期
 */
export function deleteData(symbol, exchange, interval) {
  return axios.delete(`${API_BASE_URL}/data/bars?symbol=${symbol}&exchange=${exchange}&interval=${interval}`)
}

/**
 * 获取可用的合约代码列表
 * @param {string} exchange 可选，指定交易所筛选
 * @param {string} interval 可选，指定周期筛选
 */
export function getAvailableSymbols(exchange, interval) {
  let url = `${API_BASE_URL}/data/available-symbols`
  const params = {}
  if (exchange) params.exchange = exchange
  if (interval) params.interval = interval

  return axios.get(url, { params })
}

/**
 * 获取可用的交易所列表
 * @param {string} symbol 可选，指定合约代码筛选
 * @param {string} interval 可选，指定周期筛选
 */
export function getAvailableExchanges(symbol, interval) {
  let url = `${API_BASE_URL}/data/available-exchanges`
  const params = {}
  if (symbol) params.symbol = symbol
  if (interval) params.interval = interval

  return axios.get(url, { params })
}

/**
 * 获取可用的K线周期列表
 * @param {string} symbol 可选，指定合约代码筛选
 * @param {string} exchange 可选，指定交易所筛选
 */
export function getAvailableIntervals(symbol, exchange) {
  let url = `${API_BASE_URL}/data/available-intervals`
  const params = {}
  if (symbol) params.symbol = symbol
  if (exchange) params.exchange = exchange

  return axios.get(url, { params })
}

/**
 * 获取所有可用数据记录
 */
export function getAvailableData() {
  return axios.get(`${API_BASE_URL}/data/available-data`)
}

```

### `/simpletrade/web-frontend/src/api/strategies.js`
*(统计信息: 79 行, 2072 字符 [~0.30%])*
```javascript
/**
 * 策略管理API
 */

import axios from 'axios'

const API_BASE_URL = 'http://localhost:8003/api'

/**
 * 获取策略列表
 * @param {string} type 策略类型，可选值：basic, advanced, component
 * @param {string} category 策略分类，如：趋势跟踪, 震荡指标, 波动性, 选股, AI
 */
export function getStrategies(type, category) {
  let url = `${API_BASE_URL}/strategies/`

  // 添加查询参数
  const params = {}
  if (type) params.type = type
  if (category) params.category = category

  return axios.get(url, { params })
}

/**
 * 获取策略详情
 * @param {number} strategyId 策略ID
 */
export function getStrategyDetail(strategyId) {
  return axios.get(`${API_BASE_URL}/strategies/${strategyId}`)
}

/**
 * 获取用户策略列表
 * @param {number} userId 用户ID
 */
export function getUserStrategies(userId) {
  return axios.get(`${API_BASE_URL}/strategies/user/${userId}`)
}

/**
 * 获取所有策略类型
 */
export function getStrategyTypes() {
  return axios.get(`${API_BASE_URL}/strategies/types`);
}

/**
 * 运行策略回测
 * @param {object} backtestConfig 回测配置对象
 * @param {number} backtestConfig.strategy_id
 * @param {string} backtestConfig.symbol
 * @param {string} backtestConfig.exchange
 * @param {string} backtestConfig.interval
 * @param {string} backtestConfig.start_date (YYYY-MM-DD)
 * @param {string} backtestConfig.end_date (YYYY-MM-DD)
 * @param {number} backtestConfig.initial_capital
 * @param {number} backtestConfig.rate
 * @param {number} backtestConfig.slippage
 * @param {object} [backtestConfig.parameters] 可选的用户自定义参数
 * @param {number} backtestConfig.user_id
 */
export function runStrategyBacktest(backtestConfig) {
  return axios.post(`${API_BASE_URL}/strategies/backtest`, backtestConfig);
}

/**
 * 创建用户策略
 * @param {object} userStrategyData 用户策略数据
 * @param {number} userStrategyData.user_id 用户ID
 * @param {number} userStrategyData.strategy_id 策略模板ID
 * @param {string} userStrategyData.name 用户策略名称
 * @param {object} userStrategyData.parameters 策略参数
 * @returns {Promise} 包含创建结果的Promise
 */
export function createUserStrategy(userStrategyData) {
  return axios.post(`${API_BASE_URL}/strategies/user/create`, userStrategyData);
}

```

### `/simpletrade/web-frontend/src/api/analysis.js`
*(统计信息: 24 行, 404 字符 [~0.06%])*
```javascript
/**
 * 数据分析API
 */

import axios from 'axios'

const API_BASE_URL = 'http://localhost:8003/api'

/**
 * 计算技术指标
 * @param {object} data 计算参数
 */
export function calculateIndicators(data) {
  return axios.post(`${API_BASE_URL}/analysis/indicators`, data)
}

/**
 * 运行策略回测
 * @param {object} data 回测参数
 */
export function runBacktest(data) {
  return axios.post(`${API_BASE_URL}/analysis/backtest`, data)
}

```

### `/simpletrade/web-frontend/src/store/index.js`
*(统计信息: 91 行, 2691 字符 [~0.39%])*
```javascript
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    dataOverview: [],
    currentData: null,
    analysisResults: null
  },
  mutations: {
    setDataOverview(state, overview) {
      state.dataOverview = overview
    },
    setCurrentData(state, data) {
      state.currentData = data
    },
    setAnalysisResults(state, results) {
      state.analysisResults = results
    }
  },
  actions: {
    async fetchDataOverview({ commit }) {
      try {
        const response = await fetch('http://localhost:8003/api/data/overview')
        const data = await response.json()
        if (data.success) {
          commit('setDataOverview', data.data)
        }
      } catch (error) {
        console.error('Error fetching data overview:', error)
      }
    },
    async fetchBarData({ commit }, { symbol, exchange, interval, startDate, endDate }) {
      try {
        const url = `http://localhost:8003/api/data/bars?symbol=${symbol}&exchange=${exchange}&interval=${interval}&start_date=${startDate}${endDate ? `&end_date=${endDate}` : ''}`
        const response = await fetch(url)
        const data = await response.json()
        if (data.success) {
          commit('setCurrentData', data.data)
        }
        return data
      } catch (error) {
        console.error('Error fetching bar data:', error)
        return { success: false, message: error.message }
      }
    },
    async calculateIndicators({ commit }, payload) {
      try {
        const response = await fetch('http://localhost:8003/api/analysis/indicators', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        })
        const data = await response.json()
        if (data.success) {
          commit('setAnalysisResults', data.data)
        }
        return data
      } catch (error) {
        console.error('Error calculating indicators:', error)
        return { success: false, message: error.message }
      }
    },
    async runBacktest({ commit }, payload) {
      try {
        const response = await fetch('http://localhost:8003/api/analysis/backtest', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        })
        const data = await response.json()
        if (data.success) {
          commit('setAnalysisResults', data.data)
        }
        return data
      } catch (error) {
        console.error('Error running backtest:', error)
        return { success: false, message: error.message }
      }
    }
  },
  modules: {
  }
})

```

### `/simpletrade/web-frontend/src/router/index.js`
*(统计信息: 53 行, 1349 字符 [~0.19%])*
```javascript
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

const routes = [
  {
    // Add a default route redirecting to strategy center
    path: '/',
    redirect: '/strategy-center'
  },
  {
    path: '/strategy-center',
    name: 'strategyCenter',
    component: () => import(/* webpackChunkName: "strategy" */ '../views/StrategyCenterView.vue')
  },
  {
    path: '/strategy/:id',
    name: 'StrategyDetail',
    component: () => import(/* webpackChunkName: "strategy-detail" */ '../views/StrategyDetailView.vue'),
    props: true
  },
  {
    path: '/create-from-template/:templateId',
    name: 'CreateFromTemplate',
    component: () => import(/* webpackChunkName: "create-template" */ '../views/CreateFromTemplateView.vue'),
    props: true
  },
  {
    path: '/trading-center',
    name: 'tradingCenter',
    component: () => import(/* webpackChunkName: "trading" */ '../views/TradingCenterView.vue')
  },
  {
    path: '/ai-analysis',
    name: 'aiAnalysis',
    component: () => import(/* webpackChunkName: "ai" */ '../views/AIAnalysisView.vue')
  },
  {
    path: '/user-center',
    name: 'userCenter',
    component: () => import(/* webpackChunkName: "user" */ '../views/UserCenterView.vue')
  }
]

const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes
})

export default router

```

### `/simpletrade/scripts/start_web_frontend.py`
*(统计信息: 303 行, 9909 字符 [~1.42%])*
```python
#!/usr/bin/env python
"""
启动Web前端

启动SimpleTrade的Web前端和后端API服务。
"""

import sys
import os
import subprocess
import time
from pathlib import Path
import webbrowser

# 添加项目根目录到Python路径
ROOT_DIR = Path(__file__).parent.parent.absolute()
sys.path.append(str(ROOT_DIR))

def start_api_server():
    """启动API服务器"""
    print("正在启动API服务器...")

    # 检查依赖是否安装
    missing_deps = []
    try:
        import python_jose
    except ImportError:
        missing_deps.append("python-jose")

    try:
        import vnpy_sqlite
    except ImportError:
        missing_deps.append("vnpy_sqlite")

    try:
        import python_multipart
    except ImportError:
        missing_deps.append("python-multipart")

    if missing_deps:
        print(f"缺少依赖: {', '.join(missing_deps)}")
        print("正在安装缺少的依赖...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install"] + missing_deps, check=True)
            print("依赖安装成功")
        except subprocess.CalledProcessError as e:
            print(f"依赖安装失败: {e}")
            print("请手动安装依赖: pip install " + " ".join(missing_deps))
            return None

    try:
        # 创建一个新的进程来运行API服务器
        api_process = subprocess.Popen(
            [sys.executable, "-m", "uvicorn", "simpletrade.api.server:app", "--host", "0.0.0.0", "--port", "8000"],
            cwd=str(ROOT_DIR),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True
        )

        # 等待API服务器启动
        print("等待API服务器启动...")
        start_time = time.time()
        max_wait_time = 10  # 最多等待10秒

        while time.time() - start_time < max_wait_time:
            # 检查进程是否还在运行
            if api_process.poll() is not None:
                # 进程已经结束，读取错误信息
                stdout, stderr = api_process.communicate()
                print(f"启动API服务器失败，进程已退出，退出码: {api_process.returncode}")
                print(f"标准输出: {stdout}")
                print(f"错误输出: {stderr}")
                return None

            # 尝试连接API服务器
            try:
                import requests
                response = requests.get("http://localhost:8000/docs", timeout=0.5)
                if response.status_code == 200:
                    print("API服务器启动成功，访问 http://localhost:8000/docs 查看API文档")
                    return api_process
            except Exception:
                # 连接失败，继续等待
                pass

            time.sleep(0.5)

        # 如果超时但进程仍在运行，假设服务器已经启动
        if api_process.poll() is None:
            print("API服务器似乎已经启动，但无法确认。访问 http://localhost:8000/docs 查看API文档")
            return api_process
        else:
            # 进程已经结束，读取错误信息
            stdout, stderr = api_process.communicate()
            print(f"启动API服务器失败，进程已退出，退出码: {api_process.returncode}")
            print(f"标准输出: {stdout}")
            print(f"错误输出: {stderr}")
            return None
    except Exception as e:
        print(f"启动API服务器失败: {e}")
        return None

def start_web_frontend():
    """启动Web前端"""
    print("正在启动Web前端...")

    # 检查是否安装了Node.js
    try:
        node_version = subprocess.run(["node", "--version"], check=True, stdout=subprocess.PIPE, text=True).stdout.strip()
        print(f"Node.js版本: {node_version}")
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("错误: 未安装Node.js，请先安装Node.js")
        return None

    # 检查是否安装了npm
    try:
        npm_version = subprocess.run(["npm", "--version"], check=True, stdout=subprocess.PIPE, text=True).stdout.strip()
        print(f"npm版本: {npm_version}")
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("错误: 未安装npm，请先安装npm")
        return None

    # 检查web-frontend目录是否存在
    web_frontend_dir = os.path.join(ROOT_DIR, "web-frontend")
    if not os.path.exists(web_frontend_dir):
        print(f"错误: web-frontend目录不存在: {web_frontend_dir}")
        return None

    # 检查package.json文件是否存在
    package_json_path = os.path.join(web_frontend_dir, "package.json")
    if not os.path.exists(package_json_path):
        print("创建简单的package.json文件...")
        with open(package_json_path, "w") as f:
            f.write('{\n  "name": "simpletrade-web",\n  "version": "0.1.0",\n  "private": true,\n  "scripts": {\n    "serve": "vue-cli-service serve"\n  }\n}')

    # 检查是否安装了依赖
    if not os.path.exists(os.path.join(web_frontend_dir, "node_modules")):
        print("正在安装Web前端依赖...")
        try:
            # 尝试使用cnpm安装依赖（国内镜像）
            try:
                cnpm_version = subprocess.run(["cnpm", "--version"], check=True, stdout=subprocess.PIPE, text=True).stdout.strip()
                print(f"cnpm版本: {cnpm_version}")
                print("使用cnpm安装依赖...")
                subprocess.run(["cnpm", "install"], cwd=web_frontend_dir, check=True)
            except (subprocess.CalledProcessError, FileNotFoundError):
                # 如果没有cnpm，则尝试安装cnpm
                print("cnpm未安装，尝试安装cnpm...")
                try:
                    subprocess.run(["npm", "install", "-g", "cnpm", "--registry=https://registry.npmmirror.com"], check=True)
                    print("cnpm安装成功，使用cnpm安装依赖...")
                    subprocess.run(["cnpm", "install"], cwd=web_frontend_dir, check=True)
                except subprocess.CalledProcessError as e:
                    print(f"安装cnpm失败: {e}")
                    print("使用npm安装依赖...")
                    # 使用国内镜像
                    subprocess.run(["npm", "install", "--registry=https://registry.npmmirror.com"], cwd=web_frontend_dir, check=True)
        except subprocess.CalledProcessError as e:
            print(f"安装依赖失败: {e}")
            print("请手动安装依赖: cd web-frontend && npm install --registry=https://registry.npmmirror.com")
            return None

    # 启动Web前端
    try:
        print("正在启动Web前端服务...")
        web_process = subprocess.Popen(
            ["npm", "run", "serve"],
            cwd=web_frontend_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True
        )

        # 等待Web前端启动
        print("等待Web前端启动...")
        start_time = time.time()
        max_wait_time = 30  # 最多等待30秒

        while time.time() - start_time < max_wait_time:
            # 检查进程是否还在运行
            if web_process.poll() is not None:
                # 进程已经结束，读取错误信息
                stdout, stderr = web_process.communicate()
                print(f"启动Web前端失败，进程已退出，退出码: {web_process.returncode}")
                print(f"标准输出: {stdout}")
                print(f"错误输出: {stderr}")
                return None

            # 尝试连接Web前端
            try:
                import requests
                response = requests.get("http://localhost:8080", timeout=0.5)
                if response.status_code == 200:
                    print("Web前端启动成功，访问 http://localhost:8080 查看前端界面")
                    return web_process
            except Exception:
                # 连接失败，继续等待
                pass

            time.sleep(0.5)

        # 如果超时但进程仍在运行，假设服务器已经启动
        if web_process.poll() is None:
            print("Web前端似乎已经启动，但无法确认。访问 http://localhost:8080 查看前端界面")
            return web_process
        else:
            # 进程已经结束，读取错误信息
            stdout, stderr = web_process.communicate()
            print(f"启动Web前端失败，进程已退出，退出码: {web_process.returncode}")
            print(f"标准输出: {stdout}")
            print(f"错误输出: {stderr}")
            return None
    except Exception as e:
        print(f"启动Web前端失败: {e}")
        return None

def main():
    """主函数"""
    print("正在启动SimpleTrade Web前端...")

    # 检查requests库是否安装
    try:
        import requests
    except ImportError:
        print("缺少依赖: requests")
        print("正在安装requests...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", "requests"], check=True)
            print("requests安装成功")
        except subprocess.CalledProcessError as e:
            print(f"安装requests失败: {e}")
            print("请手动安装requests: pip install requests")
            return

    # 启动API服务器
    api_process = start_api_server()
    if api_process is None:
        print("启动API服务器失败，无法继续")
        return

    # 启动Web前端
    web_process = start_web_frontend()
    if web_process is None:
        print("启动Web前端失败")
        api_process.terminate()
        print("已停止API服务器")
        return

    # 打开浏览器
    try:
        print("正在打开浏览器...")
        webbrowser.open("http://localhost:8080")
    except Exception as e:
        print(f"打开浏览器失败: {e}")
        print("请手动访问 http://localhost:8080")

    print("\n=== SimpleTrade Web前端已启动 ===")
    print("API服务器地址: http://localhost:8000")
    print("API文档地址: http://localhost:8000/docs")
    print("Web前端地址: http://localhost:8080")
    print("按Ctrl+C停止服务\n")

    try:
        # 等待用户按Ctrl+C
        while True:
            # 检查API服务器进程是否还在运行
            if api_process.poll() is not None:
                stdout, stderr = api_process.communicate()
                print("API服务器已经结束，退出码:", api_process.returncode)
                if api_process.returncode != 0:
                    print("API服务器异常退出，错误信息:")
                    print(stderr)
                print("正在停止Web前端...")
                web_process.terminate()
                break

            # 检查Web前端进程是否还在运行
            if web_process.poll() is not None:
                stdout, stderr = web_process.communicate()
                print("Web前端已经结束，退出码:", web_process.returncode)
                if web_process.returncode != 0:
                    print("Web前端异常退出，错误信息:")
                    print(stderr)
                print("正在停止API服务器...")
                api_process.terminate()
                break

            time.sleep(1)
    except KeyboardInterrupt:
        print("\n接收到Ctrl+C，正在停止服务...")
        api_process.terminate()
        web_process.terminate()

    print("服务已停止")

if __name__ == "__main__":
    main()

```

### `/simpletrade/scripts/import_qlib_to_csv.py`
*(统计信息: 233 行, 6444 字符 [~0.92%])*
```python
"""
将Qlib数据导出为CSV

使用QlibDataImporter将qlib格式的数据导出为CSV文件，然后可以通过CSV导入功能导入到系统中。
"""

import os
import sys
import struct
import numpy as np
import pandas as pd
from datetime import datetime
from pathlib import Path
from typing import List, Optional

# 添加项目根目录到Python路径
root_path = str(Path(__file__).parent.parent)
sys.path.append(root_path)

# 添加vendors目录到Python路径
vendors_path = os.path.join(root_path, 'vendors')
sys.path.append(vendors_path)

# 导入vnpy相关模块
from vnpy.trader.constant import Exchange, Interval

def read_calendar(qlib_dir):
    """读取交易日历"""
    calendar_path = os.path.join(qlib_dir, 'calendars', 'day.txt')
    if not os.path.exists(calendar_path):
        return []

    with open(calendar_path, 'r') as f:
        calendar = [line.strip() for line in f if line.strip()]

    return calendar

def read_qlib_bin_file(file_path):
    """读取qlib二进制文件"""
    if not os.path.exists(file_path):
        return None

    # 获取字段名称
    field_name = os.path.basename(file_path).split('.')[0]

    # 读取二进制文件
    with open(file_path, 'rb') as f:
        # 读取文件头（第一个浮点数是开始索引）
        start_index = struct.unpack('f', f.read(4))[0]

        # 读取所有数据
        data = np.fromfile(f, dtype='<f')

        # 创建日期索引
        indices = np.arange(int(start_index), int(start_index) + len(data))

    # 创建DataFrame
    df = pd.DataFrame({field_name: data}, index=indices)
    return df

def read_symbol_data(qlib_dir, symbol, start_date=None, end_date=None):
    """读取品种数据"""
    print(f"\n开始读取品种数据: {symbol}")

    # 在qlib中，股票代码通常存储在features目录下
    features_dir = os.path.join(qlib_dir, 'features')
    symbol_path = os.path.join(features_dir, symbol)
    print(f"品种路径: {symbol_path}")

    if not os.path.exists(symbol_path):
        print(f"品种路径不存在: {symbol_path}")
        return pd.DataFrame()

    # 获取所有可用的数据文件
    data_files = []
    for root, _, files in os.walk(symbol_path):
        for file in files:
            if file.endswith('.day.bin'):  # 只读取日线数据
                data_files.append(os.path.join(root, file))

    print(f"找到 {len(data_files)} 个数据文件")
    for file in data_files[:5]:  # 只显示前5个
        print(f"  - {os.path.basename(file)}")

    if not data_files:
        print(f"未找到数据文件: {symbol_path}")
        return pd.DataFrame()

    # 读取各个字段的数据
    field_dfs = {}
    for file_path in data_files:
        field_name = os.path.basename(file_path).split('.')[0]
        df = read_qlib_bin_file(file_path)
        if df is not None and not df.empty:
            field_dfs[field_name] = df

    if not field_dfs:
        print(f"未读取到有效数据: {symbol_path}")
        return pd.DataFrame()

    # 合并所有字段数据
    # 获取所有数据帧的索引并取并集
    all_indices = sorted(set().union(*[df.index for df in field_dfs.values()]))

    # 创建结果数据帧
    result_df = pd.DataFrame(index=all_indices)

    # 将每个字段的数据添加到结果数据帧
    for field_name, df in field_dfs.items():
        result_df[field_name] = df[field_name]

    # 将索引转换为日期
    # 获取交易日历
    calendar = read_calendar(qlib_dir)
    if calendar:
        # 创建日期映射字典，将数字索引映射到日期
        date_map = {i: pd.Timestamp(date) for i, date in enumerate(calendar)}

        # 将索引转换为日期
        result_df['datetime'] = result_df.index.map(lambda x: date_map.get(x, pd.NaT))

        # 删除无效日期
        result_df = result_df.dropna(subset=['datetime'])

        # 过滤日期范围
        if start_date:
            result_df = result_df[result_df['datetime'] >= start_date]
        if end_date:
            result_df = result_df[result_df['datetime'] <= end_date]

    return result_df

def export_to_csv(df, output_file):
    """导出数据到CSV文件"""
    # 打印原始列名
    print(f"原始列名: {df.columns.tolist()}")

    # 重命名列名，使其符合vnpy的命名规范
    rename_map = {
        'open': 'open_price',
        'high': 'high_price',
        'low': 'low_price',
        'close': 'close_price',
        'volume': 'volume',
        'factor': 'open_interest'
    }

    # 重命名列
    df_renamed = df.copy()
    for old_name, new_name in rename_map.items():
        if old_name in df_renamed.columns:
            df_renamed[new_name] = df_renamed[old_name]
            df_renamed = df_renamed.drop(old_name, axis=1)

    # 打印重命名后的列名
    print(f"重命名后的列名: {df_renamed.columns.tolist()}")

    # 确保所有必要的列都存在
    required_columns = ['datetime', 'open_price', 'high_price', 'low_price', 'close_price', 'volume', 'open_interest']
    for col in required_columns:
        if col not in df_renamed.columns:
            if col == 'open_interest':
                df_renamed[col] = 0  # 设置默认值
            elif col == 'volume' and 'factor' in df_renamed.columns:
                # 如果没有volume列但有factor列，使用factor作为volume
                df_renamed[col] = df_renamed['factor'] * 10000
                print(f"使用factor作为{col}")
            else:
                print(f"缺少必要的列: {col}")
                return False

    # 导出到CSV文件
    df_renamed.to_csv(output_file, index=False)
    print(f"数据已导出到: {output_file}")
    return True

def import_qlib_to_csv():
    """将Qlib数据导出为CSV"""
    print("开始将Qlib数据导出为CSV...")

    # 设置qlib数据目录
    qlib_dir = "/Users/chengzheng/.qlib/qlib_data/cn_data"

    # 测试读取日历
    calendar = read_calendar(qlib_dir)
    print(f"读取到 {len(calendar)} 个交易日")
    if calendar:
        print(f"第一个交易日: {calendar[0]}")
        print(f"最后一个交易日: {calendar[-1]}")

    # 导入数据
    test_cases = [
        {"symbol": "sh600000", "output_symbol": "600000", "exchange": "SSE", "interval": "d"},
        {"symbol": "sz000001", "output_symbol": "000001", "exchange": "SZSE", "interval": "d"}
    ]

    # 创建输出目录
    output_dir = "data/csv"
    os.makedirs(output_dir, exist_ok=True)

    for case in test_cases:
        symbol = case["symbol"]
        output_symbol = case["output_symbol"]
        exchange = case["exchange"]
        interval = case["interval"]

        print(f"\n导出 {symbol} 数据...")

        # 设置日期范围（最近一年）
        end_date = datetime(2020, 9, 25)  # 使用qlib数据的最后一个交易日
        start_date = datetime(2019, 9, 25)  # 最近一年的数据

        # 读取数据
        df = read_symbol_data(qlib_dir, symbol, start_date, end_date)

        if df.empty:
            print(f"未读取到数据: {symbol}")
            continue

        print(f"读取到 {len(df)} 条数据")

        # 导出到CSV文件
        output_file = os.path.join(output_dir, f"{output_symbol}_{exchange}_{interval}.csv")
        success = export_to_csv(df, output_file)

        if success:
            print(f"成功导出数据: {output_file}")
        else:
            print(f"导出数据失败: {symbol}")

if __name__ == "__main__":
    import_qlib_to_csv()

```

### `/simpletrade/scripts/import_qlib_to_database_direct.py`
*(统计信息: 228 行, 6344 字符 [~0.91%])*
```python
"""
将Qlib数据直接导入到数据库

直接读取qlib格式的数据并导入到系统数据库中。
"""

import os
import sys
import struct
import numpy as np
import pandas as pd
from datetime import datetime
from pathlib import Path
from typing import List, Optional

# 添加项目根目录到Python路径
root_path = str(Path(__file__).parent.parent)
sys.path.append(root_path)

# 添加vendors目录到Python路径
vendors_path = os.path.join(root_path, 'vendors')
sys.path.append(vendors_path)

# 导入vnpy相关模块
from vnpy.trader.object import BarData
from vnpy.trader.constant import Exchange, Interval
from vnpy.trader.database import get_database

# 获取数据库对象
database_manager = get_database()

def read_calendar(qlib_dir):
    """读取交易日历"""
    calendar_path = os.path.join(qlib_dir, 'calendars', 'day.txt')
    if not os.path.exists(calendar_path):
        return []

    with open(calendar_path, 'r') as f:
        calendar = [line.strip() for line in f if line.strip()]

    return calendar

def read_qlib_bin_file(file_path):
    """读取qlib二进制文件"""
    if not os.path.exists(file_path):
        return None

    # 获取字段名称
    field_name = os.path.basename(file_path).split('.')[0]

    # 读取二进制文件
    with open(file_path, 'rb') as f:
        # 读取文件头（第一个浮点数是开始索引）
        start_index = struct.unpack('f', f.read(4))[0]

        # 读取所有数据
        data = np.fromfile(f, dtype='<f')

        # 创建日期索引
        indices = np.arange(int(start_index), int(start_index) + len(data))

    # 创建DataFrame
    df = pd.DataFrame({field_name: data}, index=indices)
    return df

def read_symbol_data(qlib_dir, symbol, start_date=None, end_date=None):
    """读取品种数据"""
    # 在qlib中，股票代码通常存储在features目录下
    features_dir = os.path.join(qlib_dir, 'features')
    symbol_path = os.path.join(features_dir, symbol)

    if not os.path.exists(symbol_path):
        print(f"品种路径不存在: {symbol_path}")
        return pd.DataFrame()

    # 获取所有可用的数据文件
    data_files = []
    for root, _, files in os.walk(symbol_path):
        for file in files:
            if file.endswith('.day.bin'):  # 只读取日线数据
                data_files.append(os.path.join(root, file))

    if not data_files:
        print(f"未找到数据文件: {symbol_path}")
        return pd.DataFrame()

    # 读取各个字段的数据
    field_dfs = {}
    for file_path in data_files:
        field_name = os.path.basename(file_path).split('.')[0]
        df = read_qlib_bin_file(file_path)
        if df is not None and not df.empty:
            field_dfs[field_name] = df

    if not field_dfs:
        print(f"未读取到有效数据: {symbol_path}")
        return pd.DataFrame()

    # 合并所有字段数据
    # 获取所有数据帧的索引并取并集
    all_indices = sorted(set().union(*[df.index for df in field_dfs.values()]))

    # 创建结果数据帧
    result_df = pd.DataFrame(index=all_indices)

    # 将每个字段的数据添加到结果数据帧
    for field_name, df in field_dfs.items():
        result_df[field_name] = df[field_name]

    # 将索引转换为日期
    # 获取交易日历
    calendar = read_calendar(qlib_dir)
    if calendar:
        # 创建日期映射字典，将数字索引映射到日期
        date_map = {i: pd.Timestamp(date) for i, date in enumerate(calendar)}

        # 将索引转换为日期
        result_df['datetime'] = result_df.index.map(lambda x: date_map.get(x, pd.NaT))

        # 删除无效日期
        result_df = result_df.dropna(subset=['datetime'])

        # 过滤日期范围
        if start_date:
            result_df = result_df[result_df['datetime'] >= start_date]
        if end_date:
            result_df = result_df[result_df['datetime'] <= end_date]

    return result_df

def convert_to_bar_data(df, symbol, exchange, interval):
    """将DataFrame转换为BarData列表"""
    bars = []

    for _, row in df.iterrows():
        # 创建BarData对象
        bar = BarData(
            symbol=symbol,
            exchange=exchange,
            datetime=row['datetime'],
            interval=interval,
            gateway_name="QLIB"
        )

        # 设置价格和成交量数据
        field_mapping = {
            'open': 'open_price',
            'high': 'high_price',
            'low': 'low_price',
            'close': 'close_price',
            'volume': 'volume',
            'factor': 'open_interest'  # 使用factor作为open_interest
        }

        for qlib_field, vnpy_field in field_mapping.items():
            if qlib_field in row:
                setattr(bar, vnpy_field, float(row[qlib_field]))

        # 确保必要字段都有值
        required_fields = ['open_price', 'high_price', 'low_price', 'close_price', 'volume']
        if all(hasattr(bar, field) and getattr(bar, field) is not None for field in required_fields):
            bars.append(bar)

    return bars

def import_qlib_to_database():
    """将Qlib数据导入到数据库"""
    print("开始将Qlib数据导入到数据库...")

    # 设置qlib数据目录
    qlib_dir = "/Users/chengzheng/.qlib/qlib_data/cn_data"

    # 测试读取日历
    calendar = read_calendar(qlib_dir)
    print(f"读取到 {len(calendar)} 个交易日")
    if calendar:
        print(f"第一个交易日: {calendar[0]}")
        print(f"最后一个交易日: {calendar[-1]}")

    # 导入数据
    test_cases = [
        {"symbol": "600000", "qlib_symbol": "sh600000", "exchange": Exchange.SSE, "interval": Interval.DAILY},
        {"symbol": "000001", "qlib_symbol": "sz000001", "exchange": Exchange.SZSE, "interval": Interval.DAILY}
    ]

    for case in test_cases:
        symbol = case["symbol"]
        qlib_symbol = case["qlib_symbol"]
        exchange = case["exchange"]
        interval = case["interval"]

        print(f"\n导入 {symbol}.{exchange.value} {interval.value} 数据...")

        # 设置日期范围（最近一年）
        end_date = datetime(2020, 9, 25)  # 使用qlib数据的最后一个交易日
        start_date = datetime(2019, 9, 25)  # 最近一年的数据

        # 读取数据
        df = read_symbol_data(qlib_dir, qlib_symbol, start_date, end_date)

        if df.empty:
            print(f"未读取到数据: {qlib_symbol}")
            continue

        print(f"读取到 {len(df)} 条数据")

        # 转换为BarData列表
        bars = convert_to_bar_data(df, symbol, exchange, interval)

        if not bars:
            print(f"转换数据失败: {qlib_symbol}")
            continue

        print(f"转换得到 {len(bars)} 条BarData")

        # 将数据保存到数据库
        database_manager.save_bar_data(bars)
        print(f"成功将 {len(bars)} 条数据保存到数据库")

        # 打印前5条数据
        for i, bar in enumerate(bars[:5]):
            if i >= 5:
                break
            print(f"{i+1}. {bar.datetime.strftime('%Y-%m-%d')}: 开{bar.open_price:.4f} 高{bar.high_price:.4f} 低{bar.low_price:.4f} 收{bar.close_price:.4f} 量{bar.volume:.0f}")

if __name__ == "__main__":
    import_qlib_to_database()

```

### `/simpletrade/scripts/init_database.py`
*(统计信息: 182 行, 7115 字符 [~1.02%])*
```python
"""
数据库初始化脚本

创建数据库表并添加示例数据。
"""

import sys
import os
from pathlib import Path

# 添加项目根目录到Python路径
project_root = Path(__file__).parent.parent.absolute()
sys.path.insert(0, str(project_root))

import pymysql
from simpletrade.config.database import init_db, get_db, DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME
from simpletrade.models.database import Symbol, Strategy, UserStrategy, BacktestRecord

def create_database():
    """创建数据库"""
    try:
        # 连接MySQL服务器
        conn = pymysql.connect(
            host=DB_HOST,
            user=DB_USER,
            password=DB_PASSWORD,
            port=int(DB_PORT)
        )

        # 创建游标
        cursor = conn.cursor()

        # 创建数据库
        cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_NAME} DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci")

        print(f"数据库 {DB_NAME} 创建成功或已存在")

        # 关闭连接
        cursor.close()
        conn.close()
    except Exception as e:
        print(f"创建数据库时出错: {e}")
        sys.exit(1)

def add_sample_data():
    """添加示例数据"""
    db = next(get_db())  # 获取数据库会话
    try:
        # 添加交易品种
        symbols = [
            Symbol(symbol="AAPL", exchange="SMART", name="Apple Inc.", category="Stock"),
            Symbol(symbol="MSFT", exchange="SMART", name="Microsoft Corporation", category="Stock"),
            Symbol(symbol="GOOG", exchange="SMART", name="Alphabet Inc.", category="Stock"),
            Symbol(symbol="AMZN", exchange="SMART", name="Amazon.com, Inc.", category="Stock"),
            Symbol(symbol="FB", exchange="SMART", name="Meta Platforms, Inc.", category="Stock"),
            Symbol(symbol="TSLA", exchange="SMART", name="Tesla, Inc.", category="Stock"),
            Symbol(symbol="NVDA", exchange="SMART", name="NVIDIA Corporation", category="Stock"),
            Symbol(symbol="JPM", exchange="SMART", name="JPMorgan Chase & Co.", category="Stock"),
            Symbol(symbol="V", exchange="SMART", name="Visa Inc.", category="Stock"),
            Symbol(symbol="JNJ", exchange="SMART", name="Johnson & Johnson", category="Stock")
        ]
        db.add_all(symbols)

        # 添加策略
        strategies = [
            Strategy(
                name="双均线交叉策略",
                description="使用短期和长期移动平均线的交叉来产生交易信号。当短期均线上穿长期均线时买入，当短期均线下穿长期均线时卖出。",
                category="趋势跟踪",
                type="basic",
                complexity=1,
                resource_requirement=1,
                parameters={
                    "fast_window": {"type": "int", "default": 5, "min": 2, "max": 20, "description": "短期均线周期"},
                    "slow_window": {"type": "int", "default": 20, "min": 5, "max": 60, "description": "长期均线周期"}
                }
            ),
            Strategy(
                name="RSI超买超卖策略",
                description="使用相对强弱指数(RSI)来识别超买和超卖条件。当RSI低于超卖阈值时买入，当RSI高于超买阈值时卖出。",
                category="震荡指标",
                type="basic",
                complexity=2,
                resource_requirement=1,
                parameters={
                    "rsi_window": {"type": "int", "default": 14, "min": 5, "max": 30, "description": "RSI计算周期"},
                    "oversold": {"type": "int", "default": 30, "min": 10, "max": 40, "description": "超卖阈值"},
                    "overbought": {"type": "int", "default": 70, "min": 60, "max": 90, "description": "超买阈值"}
                }
            ),
            Strategy(
                name="布林带突破策略",
                description="使用布林带来识别价格突破。当价格突破上轨时买入，当价格突破下轨时卖出。",
                category="波动性",
                type="basic",
                complexity=2,
                resource_requirement=2,
                parameters={
                    "window": {"type": "int", "default": 20, "min": 10, "max": 50, "description": "布林带周期"},
                    "dev": {"type": "float", "default": 2.0, "min": 1.0, "max": 3.0, "description": "标准差倍数"}
                }
            ),
            Strategy(
                name="MACD策略",
                description="使用MACD指标来产生交易信号。当MACD线上穿信号线时买入，当MACD线下穿信号线时卖出。",
                category="趋势跟踪",
                type="basic",
                complexity=3,
                resource_requirement=2,
                parameters={
                    "fast_window": {"type": "int", "default": 12, "min": 5, "max": 20, "description": "快线周期"},
                    "slow_window": {"type": "int", "default": 26, "min": 15, "max": 40, "description": "慢线周期"},
                    "signal_window": {"type": "int", "default": 9, "min": 5, "max": 15, "description": "信号线周期"}
                }
            ),
            Strategy(
                name="KDJ策略",
                description="使用KDJ指标来产生交易信号。当K线上穿D线时买入，当K线下穿D线时卖出。",
                category="震荡指标",
                type="basic",
                complexity=3,
                resource_requirement=2,
                parameters={
                    "k_period": {"type": "int", "default": 9, "min": 5, "max": 20, "description": "K线周期"},
                    "d_period": {"type": "int", "default": 3, "min": 2, "max": 10, "description": "D线周期"},
                    "j_period": {"type": "int", "default": 3, "min": 2, "max": 10, "description": "J线周期"}
                }
            ),
            Strategy(
                name="多因子选股策略",
                description="使用多个因子（如市盈率、市净率、ROE等）来选择股票。根据因子得分对股票进行排名，选择得分最高的股票进行投资。",
                category="选股",
                type="advanced",
                complexity=4,
                resource_requirement=3,
                parameters={
                    "factors": {"type": "array", "default": ["pe", "pb", "roe"], "description": "选股因子"},
                    "weights": {"type": "array", "default": [0.4, 0.3, 0.3], "description": "因子权重"},
                    "top_n": {"type": "int", "default": 10, "min": 5, "max": 50, "description": "选择的股票数量"}
                }
            ),
            Strategy(
                name="机器学习预测策略",
                description="使用机器学习模型（如随机森林、LSTM等）来预测股票价格走势，并根据预测结果产生交易信号。",
                category="AI",
                type="advanced",
                complexity=5,
                resource_requirement=5,
                parameters={
                    "model_type": {"type": "string", "default": "random_forest", "options": ["random_forest", "lstm", "xgboost"], "description": "模型类型"},
                    "features": {"type": "array", "default": ["close", "volume", "ma5", "ma10", "rsi"], "description": "特征"},
                    "lookback": {"type": "int", "default": 20, "min": 5, "max": 60, "description": "回溯周期"},
                    "prediction_horizon": {"type": "int", "default": 5, "min": 1, "max": 20, "description": "预测周期"}
                }
            )
        ]
        db.add_all(strategies)

        db.commit()  # 确保提交事务
        print("示例数据添加成功")
    finally:
        db.close()  # 确保关闭会话

def main():
    """主函数"""
    print("开始初始化数据库...")

    # 创建数据库
    create_database()

    # 创建表
    init_db()
    print("数据库表创建成功")

    # 添加示例数据
    add_sample_data()

    print("数据库初始化完成")

if __name__ == "__main__":
    main()

```

### `/simpletrade/scripts/start_simple_web.py`
*(统计信息: 173 行, 4987 字符 [~0.71%])*
```python
#!/usr/bin/env python
"""
启动简单的Web前端

启动SimpleTrade的API服务器并打开简单的HTML页面。
"""

import sys
import os
import subprocess
import time
import webbrowser
from pathlib import Path

# 添加项目根目录到Python路径
ROOT_DIR = Path(__file__).parent.parent.absolute()
sys.path.append(str(ROOT_DIR))

def start_api_server():
    """启动API服务器"""
    print("正在启动API服务器...")

    # 检查依赖是否安装
    missing_deps = []
    try:
        import python_jose
    except ImportError:
        missing_deps.append("python-jose")

    try:
        import vnpy_sqlite
    except ImportError:
        missing_deps.append("vnpy_sqlite")

    try:
        import python_multipart
    except ImportError:
        missing_deps.append("python-multipart")

    if missing_deps:
        print(f"缺少依赖: {', '.join(missing_deps)}")
        print("正在安装缺少的依赖...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install"] + missing_deps, check=True)
            print("依赖安装成功")
        except subprocess.CalledProcessError as e:
            print(f"依赖安装失败: {e}")
            print("请手动安装依赖: pip install " + " ".join(missing_deps))
            return None

    try:
        # 创建一个新的进程来运行API服务器
        api_process = subprocess.Popen(
            [sys.executable, "-m", "uvicorn", "simpletrade.api.server:app", "--host", "0.0.0.0", "--port", "8000"],
            cwd=str(ROOT_DIR),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True
        )

        # 等待API服务器启动
        print("等待API服务器启动...")
        start_time = time.time()
        max_wait_time = 10  # 最多等待10秒

        while time.time() - start_time < max_wait_time:
            # 检查进程是否还在运行
            if api_process.poll() is not None:
                # 进程已经结束，读取错误信息
                stdout, stderr = api_process.communicate()
                print(f"启动API服务器失败，进程已退出，退出码: {api_process.returncode}")
                print(f"标准输出: {stdout}")
                print(f"错误输出: {stderr}")
                return None

            # 尝试连接API服务器
            try:
                import requests
                response = requests.get("http://localhost:8000/docs", timeout=0.5)
                if response.status_code == 200:
                    print("API服务器启动成功，访问 http://localhost:8000/docs 查看API文档")
                    return api_process
            except Exception:
                # 连接失败，继续等待
                pass

            time.sleep(0.5)

        # 如果超时但进程仍在运行，假设服务器已经启动
        if api_process.poll() is None:
            print("API服务器似乎已经启动，但无法确认。访问 http://localhost:8000/docs 查看API文档")
            return api_process
        else:
            # 进程已经结束，读取错误信息
            stdout, stderr = api_process.communicate()
            print(f"启动API服务器失败，进程已退出，退出码: {api_process.returncode}")
            print(f"标准输出: {stdout}")
            print(f"错误输出: {stderr}")
            return None
    except Exception as e:
        print(f"启动API服务器失败: {e}")
        return None

def main():
    """主函数"""
    print("正在启动SimpleTrade简单Web前端...")

    # 检查requests库是否安装
    try:
        import requests
    except ImportError:
        print("缺少依赖: requests")
        print("正在安装requests...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", "requests"], check=True)
            print("requests安装成功")
        except subprocess.CalledProcessError as e:
            print(f"安装requests失败: {e}")
            print("请手动安装requests: pip install requests")
            return

    # 启动API服务器
    api_process = start_api_server()
    if api_process is None:
        print("启动API服务器失败，无法继续")
        return

    # 打开简单的HTML页面
    simple_html_path = os.path.join(ROOT_DIR, "web-frontend", "public", "simple.html")
    if not os.path.exists(simple_html_path):
        print(f"错误: 简单HTML页面不存在: {simple_html_path}")
        api_process.terminate()
        print("已停止API服务器")
        return

    # 打开浏览器
    try:
        print("正在打开浏览器...")
        webbrowser.open(f"file://{simple_html_path}")
    except Exception as e:
        print(f"打开浏览器失败: {e}")
        print(f"请手动打开文件: {simple_html_path}")

    print("\n=== SimpleTrade 简单Web前端已启动 ===")
    print("API服务器地址: http://localhost:8000")
    print("API文档地址: http://localhost:8000/docs")
    print(f"简单HTML页面: file://{simple_html_path}")
    print("按Ctrl+C停止服务\n")

    try:
        # 等待用户按Ctrl+C
        while True:
            # 检查API服务器进程是否还在运行
            if api_process.poll() is not None:
                stdout, stderr = api_process.communicate()
                print("API服务器已经结束，退出码:", api_process.returncode)
                if api_process.returncode != 0:
                    print("API服务器异常退出，错误信息:")
                    print(stderr)
                break

            time.sleep(1)
    except KeyboardInterrupt:
        print("\n接收到Ctrl+C，正在停止服务...")
        api_process.terminate()

    print("服务已停止")

if __name__ == "__main__":
    main()

```

### `/simpletrade/scripts/import_csv_to_sqlite.py`
*(统计信息: 143 行, 3859 字符 [~0.55%])*
```python
"""
将CSV数据导入到SQLite数据库

直接使用sqlite3将CSV格式的数据导入到系统数据库中。
"""

import os
import sys
import sqlite3
import pandas as pd
from datetime import datetime
from pathlib import Path

def convert_csv_to_db_format(csv_file, symbol, exchange, interval):
    """将CSV数据转换为数据库格式"""
    print(f"转换CSV文件: {csv_file}")

    # 读取CSV数据
    df = pd.read_csv(csv_file)
    print(f"读取到 {len(df)} 条数据")

    # 打印列名
    print(f"列名: {df.columns.tolist()}")

    # 创建结果列表
    result = []
    for _, row in df.iterrows():
        # 解析日期时间
        dt = datetime.strptime(row['datetime'], '%Y-%m-%d')

        # 创建数据记录
        record = {
            "symbol": symbol,
            "exchange": exchange,
            "interval": interval,
            "datetime": dt.strftime('%Y-%m-%d %H:%M:%S'),
            "open_price": float(row['open']),
            "high_price": float(row['high']),
            "low_price": float(row['low']),
            "close_price": float(row['close']),
            "volume": float(row['volume']),
            "open_interest": float(row.get('factor', 0))
        }

        result.append(record)

    print(f"转换得到 {len(result)} 条记录")
    return result

def import_to_sqlite(db_path, records):
    """将记录导入到SQLite数据库"""
    print(f"导入数据到数据库: {db_path}")

    # 连接数据库
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # 创建表（如果不存在）
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS bar_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        symbol TEXT,
        exchange TEXT,
        interval TEXT,
        datetime TEXT,
        open_price REAL,
        high_price REAL,
        low_price REAL,
        close_price REAL,
        volume REAL,
        open_interest REAL
    )
    ''')

    # 插入数据
    for record in records:
        cursor.execute('''
        INSERT INTO bar_data (
            symbol, exchange, interval, datetime,
            open_price, high_price, low_price, close_price,
            volume, open_interest
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            record['symbol'], record['exchange'], record['interval'], record['datetime'],
            record['open_price'], record['high_price'], record['low_price'], record['close_price'],
            record['volume'], record['open_interest']
        ))

    # 提交事务
    conn.commit()

    # 关闭连接
    conn.close()

    print(f"成功导入 {len(records)} 条记录到数据库")

def import_csv_to_sqlite():
    """将CSV数据导入到SQLite数据库"""
    print("开始将CSV数据导入到SQLite数据库...")

    # 设置数据库路径
    db_path = "data.db"

    # 设置CSV数据目录
    csv_dir = "test_data/qlib_data"

    # 导入数据
    test_cases = [
        {"csv_file": "sh600000.csv", "symbol": "600000", "exchange": "SSE", "interval": "d"},
        {"csv_file": "sz000001.csv", "symbol": "000001", "exchange": "SZSE", "interval": "d"}
    ]

    for case in test_cases:
        csv_file = os.path.join(csv_dir, case["csv_file"])
        symbol = case["symbol"]
        exchange = case["exchange"]
        interval = case["interval"]

        print(f"\n导入 {symbol}.{exchange} {interval} 数据...")

        if not os.path.exists(csv_file):
            print(f"CSV文件不存在: {csv_file}")
            continue

        # 转换为数据库格式
        records = convert_csv_to_db_format(csv_file, symbol, exchange, interval)

        if not records:
            print(f"转换数据失败: {csv_file}")
            continue

        # 导入到数据库
        import_to_sqlite(db_path, records)

        # 打印前5条数据
        for i, record in enumerate(records[:5]):
            if i >= 5:
                break
            print(f"{i+1}. {record['datetime']}: 开{record['open_price']:.4f} 高{record['high_price']:.4f} 低{record['low_price']:.4f} 收{record['close_price']:.4f} 量{record['volume']:.0f}")

if __name__ == "__main__":
    import_csv_to_sqlite()

```

### `/simpletrade/scripts/download_tiger_data.py`
*(统计信息: 140 行, 3405 字符 [~0.49%])*
```python
#!/usr/bin/env python
"""
下载老虎证券历史数据

从老虎证券下载历史数据并保存到数据库中。
"""

import sys
import os
import time
from datetime import datetime, timedelta
from pathlib import Path

# 添加项目根目录到Python路径
ROOT_DIR = Path(__file__).parent.parent.absolute()
sys.path.append(str(ROOT_DIR))

from vnpy.event import EventEngine
from vnpy.trader.engine import MainEngine
from vnpy.trader.object import HistoryRequest, Exchange, Interval
from vnpy.trader.constant import Exchange, Interval
from vnpy.trader.database import get_database

# 导入老虎证券Gateway
try:
    from vnpy_tiger import TigerGateway
except ImportError:
    print("请先安装vnpy_tiger: pip install -e ./vendors/vnpy_tiger")
    sys.exit(1)

# 导入数据管理器
try:
    from simpletrade.core.data import DataManager
except ImportError:
    print("无法导入DataManager，请检查simpletrade.core.data模块")
    sys.exit(1)

# 老虎证券账户配置
TIGER_SETTING = {
    "tiger_id": "",  # 请填写您的老虎证券开放平台ID
    "account": "",   # 请填写您的老虎证券账户
    "private_key": "",  # 请填写您的私钥文件路径
    "server": "模拟",  # 可选: "标准", "环球", "模拟"
    "language": "中文"  # 可选: "中文", "英文"
}

# 要下载的股票列表
SYMBOLS = [
    {"symbol": "AAPL", "exchange": Exchange.NASDAQ},
    {"symbol": "MSFT", "exchange": Exchange.NASDAQ},
    {"symbol": "GOOG", "exchange": Exchange.NASDAQ},
    {"symbol": "AMZN", "exchange": Exchange.NASDAQ},
    {"symbol": "TSLA", "exchange": Exchange.NASDAQ},
]

# 要下载的时间周期
INTERVALS = [
    Interval.MINUTE,
    Interval.HOUR,
    Interval.DAILY,
]

def download_history_data():
    """下载历史数据并保存到数据库"""
    print("正在下载历史数据并保存到数据库...")

    # 创建事件引擎和主引擎
    event_engine = EventEngine()
    main_engine = MainEngine(event_engine)

    # 添加老虎证券Gateway
    main_engine.add_gateway(TigerGateway)

    # 连接老虎证券Gateway
    main_engine.connect(TIGER_SETTING, "TIGER")

    # 等待连接成功
    print("等待连接成功...")
    time.sleep(5)

    # 创建数据管理器
    data_manager = DataManager()

    # 下载不同周期的历史数据
    for interval in INTERVALS:
        # 根据周期设置不同的开始时间
        if interval == Interval.MINUTE:
            start = datetime.now() - timedelta(days=7)  # 分钟数据下载一周
        elif interval == Interval.HOUR:
            start = datetime.now() - timedelta(days=30)  # 小时数据下载一个月
        else:
            start = datetime.now() - timedelta(days=365)  # 日线数据下载一年

        end = datetime.now()

        # 下载每个股票的历史数据
        for stock in SYMBOLS:
            symbol = stock["symbol"]
            exchange = stock["exchange"]

            print(f"正在下载 {symbol} {interval.value} 周期的历史数据...")

            # 创建历史数据请求
            req = HistoryRequest(
                symbol=symbol,
                exchange=exchange,
                interval=interval,
                start=start,
                end=end
            )

            # 查询历史数据
            bars = main_engine.query_history(req, "TIGER")

            if bars:
                # 保存到数据库
                database = get_database()
                database.save_bar_data(bars)

                print(f"成功下载并保存 {len(bars)} 条 {symbol} {interval.value} 周期的历史数据")
            else:
                print(f"未获取到 {symbol} {interval.value} 周期的历史数据")

            # 避免请求过于频繁
            time.sleep(1)

    # 关闭连接
    main_engine.close()

    print("历史数据下载完成")

if __name__ == "__main__":
    # 检查配置是否填写
    if not TIGER_SETTING["tiger_id"] or not TIGER_SETTING["account"] or not TIGER_SETTING["private_key"]:
        print("请先填写老虎证券账户配置")
        sys.exit(1)

    # 下载历史数据
    download_history_data()

```

### `/simpletrade/scripts/test_api_server.py`
*(统计信息: 139 行, 3863 字符 [~0.55%])*
```python
#!/usr/bin/env python
"""
测试API服务器

启动一个简化版的API服务器，只包含基本功能，不依赖于talib。
"""

import sys
import os
from pathlib import Path
import logging
import uvicorn
from fastapi import FastAPI, APIRouter

# 添加项目根目录到Python路径
ROOT_DIR = Path(__file__).parent.parent.absolute()
sys.path.append(str(ROOT_DIR))

# 配置日志
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("test_api_server")

# 创建FastAPI应用
app = FastAPI(title="SimpleTrade API (Test)", version="0.1.0")

# 添加CORS中间件
from fastapi.middleware.cors import CORSMiddleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 创建测试路由
test_router = APIRouter(prefix="/api/test", tags=["test"])

@test_router.get("/hello")
async def hello():
    return {"message": "Hello from SimpleTrade API!"}

@test_router.get("/info")
async def info():
    return {
        "status": "ok",
        "version": "0.1.0",
        "api": "SimpleTrade API (Test)",
        "time": "2024-04-17"
    }

# 创建健康检查路由
health_router = APIRouter(prefix="/api/health", tags=["health"])

@health_router.get("/")
async def health_check():
    return {"status": "ok", "message": "API服务正常运行"}

# 创建数据路由
data_router = APIRouter(prefix="/api/data", tags=["data"])

@data_router.get("/symbols")
async def get_symbols():
    """获取可用的交易品种列表"""
    # 返回一些测试数据
    symbols = [
        {"symbol": "AAPL", "exchange": "SMART", "name": "Apple Inc."},
        {"symbol": "MSFT", "exchange": "SMART", "name": "Microsoft Corporation"},
        {"symbol": "GOOG", "exchange": "SMART", "name": "Alphabet Inc."},
        {"symbol": "AMZN", "exchange": "SMART", "name": "Amazon.com, Inc."},
        {"symbol": "FB", "exchange": "SMART", "name": "Meta Platforms, Inc."}
    ]
    return {
        "success": True,
        "message": f"获取交易品种成功，共 {len(symbols)} 个",
        "data": symbols
    }

@data_router.get("/bars/{symbol}")
async def get_bars(symbol: str, exchange: str = "SMART", interval: str = "1d", limit: int = 100):
    """获取K线数据"""
    import pandas as pd
    import numpy as np
    from datetime import datetime, timedelta

    # 生成一些测试数据
    end_date = datetime.now()
    dates = [(end_date - timedelta(days=i)).strftime("%Y-%m-%d") for i in range(limit)]
    dates.reverse()

    # 生成随机价格
    np.random.seed(42)  # 固定随机种子，使结果可重现
    close_prices = np.random.normal(100, 5, limit).cumsum()
    close_prices = np.abs(close_prices) + 50  # 确保价格为正

    # 生成其他价格
    open_prices = close_prices * np.random.uniform(0.98, 1.02, limit)
    high_prices = np.maximum(close_prices, open_prices) * np.random.uniform(1.0, 1.05, limit)
    low_prices = np.minimum(close_prices, open_prices) * np.random.uniform(0.95, 1.0, limit)
    volumes = np.random.randint(1000, 10000, limit)

    # 创建K线数据
    bars = []
    for i in range(limit):
        bar = {
            "datetime": dates[i],
            "open": round(open_prices[i], 2),
            "high": round(high_prices[i], 2),
            "low": round(low_prices[i], 2),
            "close": round(close_prices[i], 2),
            "volume": int(volumes[i])
        }
        bars.append(bar)

    return {
        "success": True,
        "message": f"获取K线数据成功，共 {len(bars)} 条",
        "data": bars
    }

# 添加路由
app.include_router(test_router)
app.include_router(health_router)
app.include_router(data_router)

if __name__ == "__main__":
    print("启动测试API服务器...")
    logger.info("启动测试API服务器...")
    print("API服务器地址: http://localhost:8000")
    print("API文档地址: http://localhost:8000/docs")
    print("健康检查地址: http://localhost:8000/api/health")
    print("测试接口地址: http://localhost:8000/api/test/hello")
    print("按Ctrl+C停止服务")
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")

```

### `/simpletrade/scripts/subscribe_tiger_data.py`
*(统计信息: 138 行, 3494 字符 [~0.50%])*
```python
#!/usr/bin/env python
"""
订阅老虎证券实时行情

订阅老虎证券实时行情并保存到数据库中。
"""

import sys
import os
import time
from datetime import datetime
from pathlib import Path

# 添加项目根目录到Python路径
ROOT_DIR = Path(__file__).parent.parent.absolute()
sys.path.append(str(ROOT_DIR))

from vnpy.event import EventEngine
from vnpy.trader.engine import MainEngine
from vnpy.trader.object import SubscribeRequest, TickData
from vnpy.trader.constant import Exchange
from vnpy.trader.database import get_database

# 导入老虎证券Gateway
try:
    from vnpy_tiger import TigerGateway
except ImportError:
    print("请先安装vnpy_tiger: pip install -e ./vendors/vnpy_tiger")
    sys.exit(1)

# 老虎证券账户配置
TIGER_SETTING = {
    "tiger_id": "",  # 请填写您的老虎证券开放平台ID
    "account": "",   # 请填写您的老虎证券账户
    "private_key": "",  # 请填写您的私钥文件路径
    "server": "模拟",  # 可选: "标准", "环球", "模拟"
    "language": "中文"  # 可选: "中文", "英文"
}

# 要订阅的股票列表
SYMBOLS = [
    {"symbol": "AAPL", "exchange": Exchange.NASDAQ},
    {"symbol": "MSFT", "exchange": Exchange.NASDAQ},
    {"symbol": "GOOG", "exchange": Exchange.NASDAQ},
    {"symbol": "AMZN", "exchange": Exchange.NASDAQ},
    {"symbol": "TSLA", "exchange": Exchange.NASDAQ},
]

class TickRecorder:
    """Tick数据记录器"""

    def __init__(self):
        """初始化"""
        self.database = get_database()
        self.ticks = []
        self.tick_count = 0
        self.last_save_time = datetime.now()

        # 创建事件引擎和主引擎
        self.event_engine = EventEngine()
        self.main_engine = MainEngine(self.event_engine)

        # 添加老虎证券Gateway
        self.main_engine.add_gateway(TigerGateway)

        # 注册行情回调函数
        self.event_engine.register("TICK", self.process_tick_event)

    def start(self):
        """启动记录器"""
        # 连接老虎证券Gateway
        self.main_engine.connect(TIGER_SETTING, "TIGER")

        # 等待连接成功
        print("等待连接成功...")
        time.sleep(5)

        # 订阅行情
        for stock in SYMBOLS:
            symbol = stock["symbol"]
            exchange = stock["exchange"]

            req = SubscribeRequest(
                symbol=symbol,
                exchange=exchange
            )
            self.main_engine.subscribe(req, "TIGER")
            print(f"已订阅 {symbol} 的实时行情")

        print("所有股票订阅完成，正在接收实时行情...")
        print("按Ctrl+C退出")

        # 主循环
        try:
            while True:
                # 每隔10秒保存一次数据
                if (datetime.now() - self.last_save_time).total_seconds() >= 10:
                    self.save_ticks()
                    self.last_save_time = datetime.now()

                time.sleep(1)
        except KeyboardInterrupt:
            print("用户中断，正在退出...")
            self.save_ticks()  # 保存剩余的Tick数据
            self.main_engine.close()

    def process_tick_event(self, event):
        """处理Tick事件"""
        tick = event.data
        self.ticks.append(tick)
        self.tick_count += 1

        # 打印Tick数据
        print(f"收到Tick数据: {tick.symbol} {tick.datetime} 最新价: {tick.last_price}")

    def save_ticks(self):
        """保存Tick数据到数据库"""
        if not self.ticks:
            return

        # 保存到数据库
        self.database.save_tick_data(self.ticks)

        print(f"已保存 {len(self.ticks)} 条Tick数据到数据库，总计: {self.tick_count}")

        # 清空缓存
        self.ticks = []

if __name__ == "__main__":
    # 检查配置是否填写
    if not TIGER_SETTING["tiger_id"] or not TIGER_SETTING["account"] or not TIGER_SETTING["private_key"]:
        print("请先填写老虎证券账户配置")
        sys.exit(1)

    # 启动Tick记录器
    recorder = TickRecorder()
    recorder.start()

```

### `/simpletrade/scripts/import_csv_to_database.py`
*(统计信息: 119 行, 3355 字符 [~0.48%])*
```python
"""
将CSV数据导入到数据库

将CSV格式的数据导入到系统数据库中。
"""

import os
import sys
import pandas as pd
from datetime import datetime
from pathlib import Path
from typing import List

# 添加项目根目录到Python路径
root_path = str(Path(__file__).parent.parent)
sys.path.append(root_path)

# 添加vendors目录到Python路径
vendors_path = os.path.join(root_path, 'vendors')
sys.path.append(vendors_path)

# 导入vnpy相关模块
from vnpy.trader.object import BarData
from vnpy.trader.constant import Exchange, Interval
from vnpy.trader.database import get_database

def convert_csv_to_bars(csv_file, symbol, exchange, interval):
    """将CSV数据转换为BarData列表"""
    print(f"转换CSV文件: {csv_file}")

    # 读取CSV数据
    df = pd.read_csv(csv_file)
    print(f"读取到 {len(df)} 条数据")

    # 打印列名
    print(f"列名: {df.columns.tolist()}")

    # 转换为BarData列表
    bars = []
    for _, row in df.iterrows():
        # 创建BarData对象
        bar = BarData(
            symbol=symbol,
            exchange=exchange,
            datetime=datetime.strptime(row['datetime'], '%Y-%m-%d'),
            interval=interval,
            gateway_name="CSV"
        )

        # 设置价格和成交量数据
        field_mapping = {
            'open': 'open_price',
            'high': 'high_price',
            'low': 'low_price',
            'close': 'close_price',
            'volume': 'volume',
            'factor': 'open_interest'
        }

        for csv_field, bar_field in field_mapping.items():
            if csv_field in row:
                setattr(bar, bar_field, float(row[csv_field]))

        # 确保必要字段都有值
        required_fields = ['open_price', 'high_price', 'low_price', 'close_price', 'volume']
        if all(hasattr(bar, field) and getattr(bar, field) is not None for field in required_fields):
            bars.append(bar)

    print(f"转换得到 {len(bars)} 条BarData")
    return bars

def import_csv_to_database():
    """将CSV数据导入到数据库"""
    print("开始将CSV数据导入到数据库...")

    # 获取数据库对象
    database_manager = get_database()

    # 设置CSV数据目录
    csv_dir = "test_data/qlib_data"

    # 导入数据
    test_cases = [
        {"csv_file": "sh600000.csv", "symbol": "600000", "exchange": Exchange.SSE, "interval": Interval.DAILY},
        {"csv_file": "sz000001.csv", "symbol": "000001", "exchange": Exchange.SZSE, "interval": Interval.DAILY}
    ]

    for case in test_cases:
        csv_file = os.path.join(csv_dir, case["csv_file"])
        symbol = case["symbol"]
        exchange = case["exchange"]
        interval = case["interval"]

        print(f"\n导入 {symbol}.{exchange.value} {interval.value} 数据...")

        if not os.path.exists(csv_file):
            print(f"CSV文件不存在: {csv_file}")
            continue

        # 转换为BarData列表
        bars = convert_csv_to_bars(csv_file, symbol, exchange, interval)

        if not bars:
            print(f"转换数据失败: {csv_file}")
            continue

        # 将数据保存到数据库
        database_manager.save_bar_data(bars)
        print(f"成功将 {len(bars)} 条数据保存到数据库")

        # 打印前5条数据
        for i, bar in enumerate(bars[:5]):
            if i >= 5:
                break
            print(f"{i+1}. {bar.datetime.strftime('%Y-%m-%d')}: 开{bar.open_price:.4f} 高{bar.high_price:.4f} 低{bar.low_price:.4f} 收{bar.close_price:.4f} 量{bar.volume:.0f}")

if __name__ == "__main__":
    import_csv_to_database()

```

### `/simpletrade/scripts/upload_qlib_data_via_api.py`
*(统计信息: 90 行, 2394 字符 [~0.34%])*
```python
"""
通过API上传Qlib数据

使用API接口将qlib格式的数据上传到系统中。
"""

import os
import sys
import requests
import json
import pandas as pd
from datetime import datetime
from pathlib import Path

def upload_csv_data(csv_file, symbol, exchange, interval):
    """通过API上传CSV数据"""
    print(f"上传数据: {csv_file}")

    # 读取CSV数据
    df = pd.read_csv(csv_file)
    print(f"读取到 {len(df)} 条数据")

    # 转换为API需要的格式
    data = []
    for _, row in df.iterrows():
        bar_data = {
            "symbol": symbol,
            "exchange": exchange,
            "interval": interval,
            "datetime": row["datetime"],
            "open_price": float(row["open"]),
            "high_price": float(row["high"]),
            "low_price": float(row["low"]),
            "close_price": float(row["close"]),
            "volume": float(row["volume"]),
            "open_interest": float(row.get("factor", 0))
        }
        data.append(bar_data)

    # 上传数据
    url = "http://localhost:8000/api/datamanager/bars/upload"
    headers = {"Content-Type": "application/json"}
    payload = {
        "bars": data
    }

    try:
        response = requests.post(url, headers=headers, data=json.dumps(payload))
        print(f"上传响应: {response.status_code}")
        print(f"响应内容: {response.text}")
        return response.status_code == 200
    except Exception as e:
        print(f"上传失败: {str(e)}")
        return False

def upload_qlib_data():
    """上传Qlib数据"""
    print("开始上传Qlib数据...")

    # 设置数据目录
    data_dir = "test_data/qlib_data"

    # 上传数据
    test_cases = [
        {"csv_file": "sh600000.csv", "symbol": "600000", "exchange": "SSE", "interval": "d"},
        {"csv_file": "sz000001.csv", "symbol": "000001", "exchange": "SZSE", "interval": "d"}
    ]

    for case in test_cases:
        csv_file = os.path.join(data_dir, case["csv_file"])
        symbol = case["symbol"]
        exchange = case["exchange"]
        interval = case["interval"]

        print(f"\n上传 {symbol}.{exchange} {interval} 数据...")

        if not os.path.exists(csv_file):
            print(f"CSV文件不存在: {csv_file}")
            continue

        success = upload_csv_data(csv_file, symbol, exchange, interval)

        if success:
            print(f"成功上传数据: {csv_file}")
        else:
            print(f"上传数据失败: {csv_file}")

if __name__ == "__main__":
    upload_qlib_data()

```

### `/simpletrade/scripts/import_qlib_to_database.py`
*(统计信息: 81 行, 2326 字符 [~0.33%])*
```python
"""
将Qlib数据导入到数据库

使用QlibDataImporter将qlib格式的数据导入到系统数据库中。
"""

import os
import sys
from datetime import datetime
from pathlib import Path

# 添加项目根目录到Python路径
root_path = str(Path(__file__).parent.parent)
sys.path.append(root_path)

from simpletrade.apps.st_datamanager.importers.qlib_importer import QlibDataImporter
from vnpy.trader.constant import Exchange, Interval
from vnpy.trader.database import database_manager

def import_qlib_to_database():
    """将Qlib数据导入到数据库"""
    print("开始将Qlib数据导入到数据库...")

    # 设置qlib数据目录
    qlib_dir = "/Users/chengzheng/.qlib/qlib_data/cn_data"

    # 创建导入器
    importer = QlibDataImporter()

    # 测试读取日历
    calendar = importer._read_calendar(qlib_dir)
    print(f"读取到 {len(calendar)} 个交易日")
    if calendar:
        print(f"第一个交易日: {calendar[0]}")
        print(f"最后一个交易日: {calendar[-1]}")

    # 导入数据
    test_cases = [
        {"symbol": "600000", "exchange": Exchange.SSE, "interval": Interval.DAILY},
        {"symbol": "000001", "exchange": Exchange.SZSE, "interval": Interval.DAILY}
    ]

    for case in test_cases:
        symbol = case["symbol"]
        exchange = case["exchange"]
        interval = case["interval"]

        print(f"\n导入 {symbol}.{exchange.value} {interval.value} 数据...")

        # 设置日期范围（最近一年）
        end_date = datetime(2020, 9, 25)  # 使用qlib数据的最后一个交易日
        start_date = datetime(2019, 9, 25)  # 最近一年的数据

        # 导入数据
        success, msg, bars = importer.import_data(
            qlib_dir=qlib_dir,
            symbol=symbol,
            exchange=exchange,
            interval=interval,
            start_date=start_date,
            end_date=end_date
        )

        print(f"导入结果: {success}")
        print(f"消息: {msg}")
        print(f"导入数据数量: {len(bars)}")

        if success and bars:
            # 将数据保存到数据库
            database_manager.save_bar_data(bars)
            print(f"成功将 {len(bars)} 条数据保存到数据库")

            # 打印前5条数据
            for i, bar in enumerate(bars[:5]):
                if i >= 5:
                    break
                print(f"{i+1}. {bar.datetime.strftime('%Y-%m-%d')}: 开{bar.open_price:.4f} 高{bar.high_price:.4f} 低{bar.low_price:.4f} 收{bar.close_price:.4f} 量{bar.volume:.0f}")

if __name__ == "__main__":
    import_qlib_to_database()

```

### `/simpletrade/scripts/import_qlib_via_api.py`
*(统计信息: 66 行, 1655 字符 [~0.24%])*
```python
"""
通过API导入Qlib数据

使用API接口将qlib格式的数据导入到系统中。
"""

import os
import sys
import requests
import json
from datetime import datetime
from pathlib import Path

def import_qlib_data():
    """通过API导入Qlib数据"""
    print("开始通过API导入Qlib数据...")

    # 设置API地址
    api_url = "http://localhost:8000/api/data/import/qlib"

    # 设置qlib数据目录
    qlib_dir = "/Users/chengzheng/.qlib/qlib_data/cn_data"

    # 导入数据
    test_cases = [
        {"symbol": "600000", "exchange": "SSE", "interval": "d"},
        {"symbol": "000001", "exchange": "SZSE", "interval": "d"}
    ]

    for case in test_cases:
        symbol = case["symbol"]
        exchange = case["exchange"]
        interval = case["interval"]

        print(f"\n导入 {symbol}.{exchange} {interval} 数据...")

        # 设置日期范围（最近一年）
        end_date = "2020-09-25"  # 使用qlib数据的最后一个交易日
        start_date = "2019-09-25"  # 最近一年的数据

        # 准备请求数据
        payload = {
            "qlib_dir": qlib_dir,
            "symbol": symbol,
            "exchange": exchange,
            "interval": interval,
            "start_date": start_date,
            "end_date": end_date
        }

        # 发送请求
        try:
            response = requests.post(api_url, json=payload)
            print(f"API响应: {response.status_code}")
            print(f"响应内容: {response.text}")

            if response.status_code == 200:
                print(f"成功导入数据: {symbol}.{exchange}")
            else:
                print(f"导入数据失败: {symbol}.{exchange}")
        except Exception as e:
            print(f"请求失败: {str(e)}")

if __name__ == "__main__":
    import_qlib_data()

```

### `/simpletrade/scripts/setup_mysql.sh`
*(统计信息: 45 行, 1163 字符 [~0.17%])*
```bash
#!/bin/bash

# 获取脚本所在目录
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$( dirname "$SCRIPT_DIR" )"

# 从环境变量或默认值获取数据库连接信息
MYSQL_USER="${SIMPLETRADE_DB_USER:-root}"
MYSQL_PASSWORD="${SIMPLETRADE_DB_PASSWORD:-Cz159csa}"
MYSQL_HOST="${SIMPLETRADE_DB_HOST:-localhost}"
MYSQL_PORT="${SIMPLETRADE_DB_PORT:-3306}"
DB_NAME="${SIMPLETRADE_DB_NAME:-simpletrade}"

# 显示数据库连接信息
echo "Using database connection:"
echo "  Host: $MYSQL_HOST:$MYSQL_PORT"
echo "  Database: $DB_NAME"
echo "  User: $MYSQL_USER"

# 创建数据库
echo "创建数据库 $DB_NAME..."
mysql -u$MYSQL_USER -p$MYSQL_PASSWORD -h$MYSQL_HOST -P$MYSQL_PORT -e "CREATE DATABASE IF NOT EXISTS $DB_NAME DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

if [ $? -eq 0 ]; then
    echo "数据库创建成功或已存在"
else
    echo "数据库创建失败"
    exit 1
fi

# 安装必要的Python包
echo "安装必要的Python包..."
conda run -n simpletrade pip install sqlalchemy pymysql

# 获取脚本所在目录
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$( dirname "$SCRIPT_DIR" )"

# 初始化数据库表和示例数据
echo "初始化数据库表和示例数据..."
cd "$PROJECT_ROOT"
conda run -n simpletrade python "$SCRIPT_DIR/init_database.py"

echo "MySQL数据库设置完成"

```

### `/simpletrade/scripts/load_env.py`
*(统计信息: 39 行, 1093 字符 [~0.16%])*
```python
"""
加载环境变量脚本

从 .env 文件加载环境变量。
"""

import os
import sys
from pathlib import Path
from dotenv import load_dotenv

def main():
    """主函数"""
    # 获取项目根目录
    project_root = Path(__file__).parent.parent.absolute()

    # 加载 .env 文件
    env_file = project_root / '.env'
    if env_file.exists():
        print(f"Loading environment variables from {env_file}")
        load_dotenv(dotenv_path=env_file)
    else:
        print(f"Warning: .env file not found at {env_file}")
        print("Using default environment variables.")

    # 打印当前环境变量
    print("\nCurrent environment variables:")
    for key in sorted(os.environ.keys()):
        if key.startswith('SIMPLETRADE_'):
            print(f"  {key}={os.environ[key]}")

    print("\nDatabase connection parameters:")
    print(f"  Host: {os.environ.get('SIMPLETRADE_DB_HOST', 'localhost')}:{os.environ.get('SIMPLETRADE_DB_PORT', '3306')}")
    print(f"  Database: {os.environ.get('SIMPLETRADE_DB_NAME', 'simpletrade')}")
    print(f"  User: {os.environ.get('SIMPLETRADE_DB_USER', 'root')}")

if __name__ == "__main__":
    main()

```

### `/simpletrade/scripts/simple_api_test.py`
*(统计信息: 25 行, 443 字符 [~0.06%])*
```python
#!/usr/bin/env python
"""
简单API测试

启动一个最简单的FastAPI服务器，用于测试。
"""

from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/api/health")
async def health():
    return {"status": "ok", "message": "API服务正常运行"}

if __name__ == "__main__":
    print("启动简单API测试服务器...")
    print("访问 http://localhost:8000/ 查看API")
    uvicorn.run(app, host="0.0.0.0", port=8000)

```

### `/simpletrade/scripts/__init__.py`
*(统计信息: 6 行, 49 字符 [~0.01%])*
```python
"""
SimpleTrade脚本工具

包含各种实用脚本，如环境配置、vnpy更新等。
"""

```

### `/simpletrade/notebooks/数据分析示例.ipynb`
*(统计信息: 580 行, 16587 字符 [~2.37%])*
```
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 数据分析示例\n",
    "\n",
    "这个Notebook展示了如何使用Jupyter进行数据分析，包括加载历史数据、计算技术指标和可视化数据。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. 导入必要的库"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from datetime import datetime, timedelta\n",
    "\n",
    "# 设置绘图风格\n",
    "plt.style.use('ggplot')\n",
    "sns.set_style('whitegrid')\n",
    "%matplotlib inline\n",
    "\n",
    "# 导入vnpy相关模块\n",
    "from vnpy.trader.constant import Interval\n",
    "from vnpy.trader.database import database_manager\n",
    "from vnpy.trader.utility import BarGenerator, ArrayManager"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. 加载历史数据\n",
    "\n",
    "从数据库加载历史K线数据，并转换为DataFrame格式。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 设置数据参数\n",
    "symbol = \"BTCUSDT\"\n",
    "exchange = \"BINANCE\"\n",
    "interval = Interval.MINUTE\n",
    "start = datetime(2023, 1, 1)\n",
    "end = datetime(2023, 12, 31)\n",
    "\n",
    "# 从数据库加载历史数据\n",
    "bars = database_manager.load_bar_data(\n",
    "    symbol=symbol,\n",
    "    exchange=exchange,\n",
    "    interval=interval,\n",
    "    start=start,\n",
    "    end=end\n",
    ")\n",
    "\n",
    "# 转换为DataFrame\n",
    "data = []\n",
    "for bar in bars:\n",
    "    data.append({\n",
    "        \"datetime\": bar.datetime,\n",
    "        \"open\": bar.open_price,\n",
    "        \"high\": bar.high_price,\n",
    "        \"low\": bar.low_price,\n",
    "        \"close\": bar.close_price,\n",
    "        \"volume\": bar.volume\n",
    "    })\n",
    "\n",
    "df = pd.DataFrame(data)\n",
    "df.set_index(\"datetime\", inplace=True)\n",
    "\n",
    "# 显示数据\n",
    "df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. 数据预处理\n",
    "\n",
    "对数据进行预处理，包括处理缺失值、重采样等。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 检查缺失值\n",
    "print(f\"缺失值数量:\\n{df.isnull().sum()}\")\n",
    "\n",
    "# 处理缺失值\n",
    "df = df.dropna()\n",
    "\n",
    "# 重采样为日K线\n",
    "daily_df = df.resample('D').agg({\n",
    "    'open': 'first',\n",
    "    'high': 'max',\n",
    "    'low': 'min',\n",
    "    'close': 'last',\n",
    "    'volume': 'sum'\n",
    "})\n",
    "\n",
    "# 删除缺失值\n",
    "daily_df = daily_df.dropna()\n",
    "\n",
    "# 显示日K线数据\n",
    "daily_df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. 计算技术指标\n",
    "\n",
    "计算常用的技术指标，如移动平均线、MACD、RSI等。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 计算移动平均线\n",
    "daily_df[\"ma5\"] = daily_df[\"close\"].rolling(5).mean()\n",
    "daily_df[\"ma10\"] = daily_df[\"close\"].rolling(10).mean()\n",
    "daily_df[\"ma20\"] = daily_df[\"close\"].rolling(20).mean()\n",
    "daily_df[\"ma60\"] = daily_df[\"close\"].rolling(60).mean()\n",
    "\n",
    "# 计算MACD\n",
    "def calculate_macd(df, fast=12, slow=26, signal=9):\n",
    "    df = df.copy()\n",
    "    df[\"ema_fast\"] = df[\"close\"].ewm(span=fast, adjust=False).mean()\n",
    "    df[\"ema_slow\"] = df[\"close\"].ewm(span=slow, adjust=False).mean()\n",
    "    df[\"macd\"] = df[\"ema_fast\"] - df[\"ema_slow\"]\n",
    "    df[\"signal\"] = df[\"macd\"].ewm(span=signal, adjust=False).mean()\n",
    "    df[\"histogram\"] = df[\"macd\"] - df[\"signal\"]\n",
    "    return df\n",
    "\n",
    "daily_df = calculate_macd(daily_df)\n",
    "\n",
    "# 计算RSI\n",
    "def calculate_rsi(df, window=14):\n",
    "    df = df.copy()\n",
    "    delta = df[\"close\"].diff()\n",
    "    gain = delta.where(delta > 0, 0)\n",
    "    loss = -delta.where(delta < 0, 0)\n",
    "    avg_gain = gain.rolling(window=window).mean()\n",
    "    avg_loss = loss.rolling(window=window).mean()\n",
    "    rs = avg_gain / avg_loss\n",
    "    df[\"rsi\"] = 100 - (100 / (1 + rs))\n",
    "    return df\n",
    "\n",
    "daily_df = calculate_rsi(daily_df)\n",
    "\n",
    "# 计算布林带\n",
    "def calculate_bollinger_bands(df, window=20, num_std=2):\n",
    "    df = df.copy()\n",
    "    df[\"middle_band\"] = df[\"close\"].rolling(window=window).mean()\n",
    "    df[\"std\"] = df[\"close\"].rolling(window=window).std()\n",
    "    df[\"upper_band\"] = df[\"middle_band\"] + (df[\"std\"] * num_std)\n",
    "    df[\"lower_band\"] = df[\"middle_band\"] - (df[\"std\"] * num_std)\n",
    "    return df\n",
    "\n",
    "daily_df = calculate_bollinger_bands(daily_df)\n",
    "\n",
    "# 显示计算后的数据\n",
    "daily_df.tail()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. 数据可视化\n",
    "\n",
    "可视化价格和技术指标，帮助分析市场趋势和模式。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 绘制价格和移动平均线\n",
    "plt.figure(figsize=(12, 6))\n",
    "plt.plot(daily_df.index, daily_df[\"close\"], label=\"Close\")\n",
    "plt.plot(daily_df.index, daily_df[\"ma5\"], label=\"MA5\")\n",
    "plt.plot(daily_df.index, daily_df[\"ma20\"], label=\"MA20\")\n",
    "plt.plot(daily_df.index, daily_df[\"ma60\"], label=\"MA60\")\n",
    "plt.title(f\"{symbol} Price and Moving Averages\")\n",
    "plt.xlabel(\"Date\")\n",
    "plt.ylabel(\"Price\")\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 绘制布林带\n",
    "plt.figure(figsize=(12, 6))\n",
    "plt.plot(daily_df.index, daily_df[\"close\"], label=\"Close\")\n",
    "plt.plot(daily_df.index, daily_df[\"middle_band\"], label=\"Middle Band\")\n",
    "plt.plot(daily_df.index, daily_df[\"upper_band\"], label=\"Upper Band\")\n",
    "plt.plot(daily_df.index, daily_df[\"lower_band\"], label=\"Lower Band\")\n",
    "plt.fill_between(daily_df.index, daily_df[\"upper_band\"], daily_df[\"lower_band\"], alpha=0.1)\n",
    "plt.title(f\"{symbol} Bollinger Bands\")\n",
    "plt.xlabel(\"Date\")\n",
    "plt.ylabel(\"Price\")\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 绘制MACD\n",
    "plt.figure(figsize=(12, 8))\n",
    "\n",
    "# 价格子图\n",
    "plt.subplot(3, 1, 1)\n",
    "plt.plot(daily_df.index, daily_df[\"close\"], label=\"Close\")\n",
    "plt.title(f\"{symbol} Price\")\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "\n",
    "# MACD子图\n",
    "plt.subplot(3, 1, 2)\n",
    "plt.plot(daily_df.index, daily_df[\"macd\"], label=\"MACD\")\n",
    "plt.plot(daily_df.index, daily_df[\"signal\"], label=\"Signal\")\n",
    "plt.bar(daily_df.index, daily_df[\"histogram\"], label=\"Histogram\")\n",
    "plt.title(\"MACD\")\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "\n",
    "# RSI子图\n",
    "plt.subplot(3, 1, 3)\n",
    "plt.plot(daily_df.index, daily_df[\"rsi\"], label=\"RSI\")\n",
    "plt.axhline(y=70, color=\"r\", linestyle=\"--\")\n",
    "plt.axhline(y=30, color=\"g\", linestyle=\"--\")\n",
    "plt.title(\"RSI\")\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. 统计分析\n",
    "\n",
    "对价格和收益率进行统计分析，了解市场的统计特性。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 计算日收益率\n",
    "daily_df[\"returns\"] = daily_df[\"close\"].pct_change()\n",
    "\n",
    "# 描述性统计\n",
    "print(\"收益率描述性统计:\")\n",
    "print(daily_df[\"returns\"].describe())\n",
    "\n",
    "# 绘制收益率分布\n",
    "plt.figure(figsize=(12, 6))\n",
    "sns.histplot(daily_df[\"returns\"].dropna(), kde=True)\n",
    "plt.title(f\"{symbol} Daily Returns Distribution\")\n",
    "plt.xlabel(\"Returns\")\n",
    "plt.ylabel(\"Frequency\")\n",
    "plt.grid(True)\n",
    "plt.show()\n",
    "\n",
    "# 绘制收益率QQ图\n",
    "from scipy import stats\n",
    "plt.figure(figsize=(12, 6))\n",
    "stats.probplot(daily_df[\"returns\"].dropna(), plot=plt)\n",
    "plt.title(f\"{symbol} Daily Returns Q-Q Plot\")\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. 相关性分析\n",
    "\n",
    "分析不同交易品种之间的相关性，寻找交易机会。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 加载其他交易品种的数据\n",
    "symbols = [\"BTCUSDT\", \"ETHUSDT\", \"BNBUSDT\", \"ADAUSDT\", \"DOGEUSDT\"]\n",
    "correlation_data = {}\n",
    "\n",
    "for sym in symbols:\n",
    "    # 从数据库加载历史数据\n",
    "    bars = database_manager.load_bar_data(\n",
    "        symbol=sym,\n",
    "        exchange=exchange,\n",
    "        interval=Interval.DAILY,\n",
    "        start=start,\n",
    "        end=end\n",
    "    )\n",
    "    \n",
    "    # 转换为DataFrame\n",
    "    data = []\n",
    "    for bar in bars:\n",
    "        data.append({\n",
    "            \"datetime\": bar.datetime,\n",
    "            \"close\": bar.close_price\n",
    "        })\n",
    "    \n",
    "    sym_df = pd.DataFrame(data)\n",
    "    sym_df.set_index(\"datetime\", inplace=True)\n",
    "    \n",
    "    # 存储收盘价\n",
    "    correlation_data[sym] = sym_df[\"close\"]\n",
    "\n",
    "# 创建包含所有交易品种收盘价的DataFrame\n",
    "correlation_df = pd.DataFrame(correlation_data)\n",
    "\n",
    "# 计算收益率\n",
    "returns_df = correlation_df.pct_change().dropna()\n",
    "\n",
    "# 计算相关性矩阵\n",
    "correlation_matrix = returns_df.corr()\n",
    "\n",
    "# 绘制相关性热图\n",
    "plt.figure(figsize=(10, 8))\n",
    "sns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", vmin=-1, vmax=1)\n",
    "plt.title(\"Cryptocurrency Returns Correlation Matrix\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. 交易信号生成\n",
    "\n",
    "基于技术指标生成交易信号，为策略开发提供基础。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 生成移动平均线交叉信号\n",
    "daily_df[\"ma_cross_signal\"] = 0\n",
    "daily_df.loc[daily_df[\"ma5\"] > daily_df[\"ma20\"], \"ma_cross_signal\"] = 1  # 多头信号\n",
    "daily_df.loc[daily_df[\"ma5\"] < daily_df[\"ma20\"], \"ma_cross_signal\"] = -1  # 空头信号\n",
    "\n",
    "# 生成MACD信号\n",
    "daily_df[\"macd_signal\"] = 0\n",
    "daily_df.loc[daily_df[\"macd\"] > daily_df[\"signal\"], \"macd_signal\"] = 1  # 多头信号\n",
    "daily_df.loc[daily_df[\"macd\"] < daily_df[\"signal\"], \"macd_signal\"] = -1  # 空头信号\n",
    "\n",
    "# 生成RSI信号\n",
    "daily_df[\"rsi_signal\"] = 0\n",
    "daily_df.loc[daily_df[\"rsi\"] < 30, \"rsi_signal\"] = 1  # 超卖，多头信号\n",
    "daily_df.loc[daily_df[\"rsi\"] > 70, \"rsi_signal\"] = -1  # 超买，空头信号\n",
    "\n",
    "# 生成布林带信号\n",
    "daily_df[\"bb_signal\"] = 0\n",
    "daily_df.loc[daily_df[\"close\"] < daily_df[\"lower_band\"], \"bb_signal\"] = 1  # 价格低于下轨，多头信号\n",
    "daily_df.loc[daily_df[\"close\"] > daily_df[\"upper_band\"], \"bb_signal\"] = -1  # 价格高于上轨，空头信号\n",
    "\n",
    "# 显示信号\n",
    "daily_df[[\"close\", \"ma_cross_signal\", \"macd_signal\", \"rsi_signal\", \"bb_signal\"]].tail(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 9. 可视化交易信号\n",
    "\n",
    "可视化交易信号，帮助分析策略的有效性。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 绘制价格和交易信号\n",
    "plt.figure(figsize=(12, 8))\n",
    "\n",
    "# 绘制价格\n",
    "plt.plot(daily_df.index, daily_df[\"close\"], label=\"Close\")\n",
    "\n",
    "# 绘制MA5和MA20\n",
    "plt.plot(daily_df.index, daily_df[\"ma5\"], label=\"MA5\", alpha=0.7)\n",
    "plt.plot(daily_df.index, daily_df[\"ma20\"], label=\"MA20\", alpha=0.7)\n",
    "\n",
    "# 绘制多头信号\n",
    "buy_signals = daily_df[daily_df[\"ma_cross_signal\"] == 1]\n",
    "plt.scatter(buy_signals.index, buy_signals[\"close\"], marker=\"^\", color=\"green\", s=100, label=\"Buy Signal\")\n",
    "\n",
    "# 绘制空头信号\n",
    "sell_signals = daily_df[daily_df[\"ma_cross_signal\"] == -1]\n",
    "plt.scatter(sell_signals.index, sell_signals[\"close\"], marker=\"v\", color=\"red\", s=100, label=\"Sell Signal\")\n",
    "\n",
    "plt.title(f\"{symbol} Price with MA Cross Signals\")\n",
    "plt.xlabel(\"Date\")\n",
    "plt.ylabel(\"Price\")\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 10. 策略回测\n",
    "\n",
    "基于生成的交易信号进行简单的回测，评估策略性能。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 基于MA交叉信号进行回测\n",
    "def backtest_ma_cross_strategy(df):\n",
    "    df = df.copy()\n",
    "    \n",
    "    # 初始资金\n",
    "    initial_capital = 10000.0\n",
    "    position = 0\n",
    "    capital = initial_capital\n",
    "    df[\"capital\"] = initial_capital\n",
    "    \n",
    "    # 遍历数据\n",
    "    for i in range(1, len(df)):\n",
    "        # 获取当前信号\n",
    "        signal = df[\"ma_cross_signal\"].iloc[i]\n",
    "        price = df[\"close\"].iloc[i]\n",
    "        prev_price = df[\"close\"].iloc[i-1]\n",
    "        \n",
    "        # 更新资金\n",
    "        if position != 0:\n",
    "            # 持有仓位，更新资金\n",
    "            capital = capital + position * (price - prev_price)\n",
    "        \n",
    "        # 交易信号\n",
    "        if signal == 1 and position <= 0:  # 多头信号\n",
    "            position = capital / price  # 全仓买入\n",
    "        elif signal == -1 and position >= 0:  # 空头信号\n",
    "            position = -capital / price  # 全仓卖出\n",
    "        \n",
    "        # 记录资金\n",
    "        df[\"capital\"].iloc[i] = capital\n",
    "    \n",
    "    # 计算收益率\n",
    "    df[\"returns\"] = df[\"capital\"].pct_change()\n",
    "    \n",
    "    # 计算累计收益率\n",
    "    df[\"cumulative_returns\"] = (1 + df[\"returns\"]).cumprod() - 1\n",
    "    \n",
    "    # 计算回撤\n",
    "    df[\"peak\"] = df[\"capital\"].cummax()\n",
    "    df[\"drawdown\"] = (df[\"capital\"] - df[\"peak\"]) / df[\"peak\"]\n",
    "    \n",
    "    return df\n",
    "\n",
    "# 运行回测\n",
    "backtest_df = backtest_ma_cross_strategy(daily_df)\n",
    "\n",
    "# 计算性能指标\n",
    "total_return = (backtest_df[\"capital\"].iloc[-1] / initial_capital) - 1\n",
    "annual_return = (1 + total_return) ** (252 / len(backtest_df)) - 1\n",
    "max_drawdown = backtest_df[\"drawdown\"].min()\n",
    "sharpe_ratio = backtest_df[\"returns\"].mean() / backtest_df[\"returns\"].std() * np.sqrt(252)\n",
    "\n",
    "print(f\"总收益率: {total_return:.2%}\")\n",
    "print(f\"年化收益率: {annual_return:.2%}\")\n",
    "print(f\"最大回撤: {max_drawdown:.2%}\")\n",
    "print(f\"夏普比率: {sharpe_ratio:.2f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "# 绘制资金曲线\n",
    "plt.figure(figsize=(12, 8))\n",
    "\n",
    "# 绘制资金曲线\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.plot(backtest_df.index, backtest_df[\"capital\"], label=\"Capital\")\n",
    "plt.title(f\"{symbol} MA Cross Strategy - Capital Curve\")\n",
    "plt.xlabel(\"Date\")\n",
    "plt.ylabel(\"Capital\")\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "\n",
    "# 绘制回撤\n",
    "plt.subplot(2, 1, 2)\n",
    "plt.fill_between(backtest_df.index, 0, backtest_df[\"drawdown\"] * 100, color=\"red\", alpha=0.5)\n",
    "plt.title(\"Drawdown (%)\")\n",
    "plt.xlabel(\"Date\")\n",
    "plt.ylabel(\"Drawdown (%)\")\n",
    "plt.grid(True)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 11. 总结\n",
    "\n",
    "通过这个示例，我们展示了如何使用Jupyter Notebook进行数据分析、技术指标计算、交易信号生成和策略回测。这些技术可以帮助您开发和优化自己的交易策略。"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}

```

### `/simpletrade/notebooks/README.md`
*(统计信息: 171 行, 3834 字符 [~0.55%])*
```markdown
# Jupyter Notebook 使用指南

## 什么是Jupyter Notebook？

Jupyter Notebook是一个开源的Web应用程序，允许您创建和共享包含实时代码、方程式、可视化和叙述性文本的文档。它是数据科学家、量化分析师和策略开发者的重要工具。

## 在SimpleTrade中的用途

在SimpleTrade系统中，Jupyter Notebook主要用于以下场景：

1. **数据分析**：
   - 加载和探索历史行情数据
   - 计算和可视化技术指标
   - 分析交易品种的统计特性
   - 研究市场模式和相关性

2. **策略开发**：
   - 编写和测试交易策略
   - 可视化策略信号和交易结果
   - 优化策略参数
   - 分析策略性能指标

3. **回测结果分析**：
   - 加载和可视化回测结果
   - 分析策略的盈亏分布
   - 计算风险指标
   - 比较不同策略的性能

4. **实时监控**：
   - 连接到实时交易系统
   - 监控策略运行状态
   - 分析实时交易数据
   - 调整策略参数

## 如何使用

1. **访问Jupyter Notebook**：
   - 启动SimpleTrade系统后，访问 http://localhost:8888
   - 无需密码即可登录（在生产环境中应设置密码）

2. **创建新的Notebook**：
   - 点击右上角的"New"按钮，选择"Python 3"
   - 这将创建一个新的Python Notebook

3. **导入常用库**：
   ```python
   import pandas as pd
   import numpy as np
   import matplotlib.pyplot as plt
   import seaborn as sns
   from datetime import datetime, timedelta

   # 设置绘图风格
   plt.style.use('ggplot')
   sns.set_style('whitegrid')
   %matplotlib inline

   # 导入vnpy相关模块
   from vnpy.trader.constant import Interval
   from vnpy.trader.database import database_manager
   from vnpy.trader.utility import BarGenerator, ArrayManager
   ```

4. **加载历史数据**：
   ```python
   # 从数据库加载历史数据
   symbol = "BTCUSDT"
   exchange = "BINANCE"
   interval = Interval.MINUTE
   start = datetime(2023, 1, 1)
   end = datetime(2023, 12, 31)

   bars = database_manager.load_bar_data(
       symbol=symbol,
       exchange=exchange,
       interval=interval,
       start=start,
       end=end
   )

   # 转换为DataFrame
   data = []
   for bar in bars:
       data.append({
           "datetime": bar.datetime,
           "open": bar.open_price,
           "high": bar.high_price,
           "low": bar.low_price,
           "close": bar.close_price,
           "volume": bar.volume
       })

   df = pd.DataFrame(data)
   df.set_index("datetime", inplace=True)

   # 显示数据
   df.head()
   ```

5. **计算技术指标**：
   ```python
   # 计算移动平均线
   df["ma5"] = df["close"].rolling(5).mean()
   df["ma10"] = df["close"].rolling(10).mean()
   df["ma20"] = df["close"].rolling(20).mean()

   # 计算MACD
   def calculate_macd(df, fast=12, slow=26, signal=9):
       df = df.copy()
       df["ema_fast"] = df["close"].ewm(span=fast, adjust=False).mean()
       df["ema_slow"] = df["close"].ewm(span=slow, adjust=False).mean()
       df["macd"] = df["ema_fast"] - df["ema_slow"]
       df["signal"] = df["macd"].ewm(span=signal, adjust=False).mean()
       df["histogram"] = df["macd"] - df["signal"]
       return df

   df = calculate_macd(df)
   ```

6. **可视化数据**：
   ```python
   # 绘制K线图和移动平均线
   plt.figure(figsize=(12, 6))
   plt.plot(df.index, df["close"], label="Close")
   plt.plot(df.index, df["ma5"], label="MA5")
   plt.plot(df.index, df["ma10"], label="MA10")
   plt.plot(df.index, df["ma20"], label="MA20")
   plt.title(f"{symbol} Price and Moving Averages")
   plt.xlabel("Date")
   plt.ylabel("Price")
   plt.legend()
   plt.grid(True)
   plt.show()

   # 绘制MACD
   plt.figure(figsize=(12, 6))
   plt.subplot(2, 1, 1)
   plt.plot(df.index, df["close"], label="Close")
   plt.title(f"{symbol} Price")
   plt.legend()

   plt.subplot(2, 1, 2)
   plt.plot(df.index, df["macd"], label="MACD")
   plt.plot(df.index, df["signal"], label="Signal")
   plt.bar(df.index, df["histogram"], label="Histogram")
   plt.title("MACD")
   plt.legend()
   plt.tight_layout()
   plt.show()
   ```

7. **保存Notebook**：
   - 点击"File" -> "Save"或使用快捷键Ctrl+S
   - Notebook将保存在/app/notebooks目录中

## 示例Notebook

我们提供了一些示例Notebook，帮助您快速上手：

1. **数据分析示例.ipynb**：展示如何加载和分析历史数据
2. **策略开发示例.ipynb**：展示如何开发和测试交易策略
3. **回测分析示例.ipynb**：展示如何分析回测结果
4. **实时监控示例.ipynb**：展示如何监控实时交易数据

## 注意事项

1. Jupyter Notebook服务运行在Docker容器中，数据保存在notebooks数据卷中
2. 重启容器不会丢失Notebook文件，但请定期备份重要的Notebook
3. 在生产环境中，应设置Jupyter Notebook的访问密码
4. 避免在Notebook中运行耗时的计算，这可能会影响其他服务的性能

```

### `/simpletrade/ai_context/README.md`
*(统计信息: 175 行, 2475 字符 [~0.35%])*
```markdown
# AI_CONTEXT目录说明

**最后更新**: 2024-04-17

## 目录用途

AI_CONTEXT目录是SimpleTrade项目的AI协作管理中心，用于存储与AI助手协作相关的所有上下文文件。这个目录的设计目的是减少重复说明上下文的需求，保持项目信息的一致性，并提高AI协作的质量和效率。

## 目录结构

```
ai_context/
├── CURRENT_STATUS.md        # 项目当前状态和进度
├── CONVERSATION_HISTORY.md  # 最近对话的摘要
├── DECISIONS_LOG.md         # 关键决策记录
├── AI_COLLABORATION_GUIDE.md  # AI协作指南
├── README.md               # 本文件
├── REFERENCE/              # 参考资料目录
│   ├── README.md           # 参考资料说明
│   ├── VNPY_KEY_COMPONENTS.md
│   ├── TECHNICAL_INDICATORS.md
│   ├── API_OVERVIEW.md
│   └── ...
└── archive/                # 归档目录
    ├── PROJECT_STATUS.md      # 已归档
    ├── CURRENT_FOCUS.md       # 已归档
    └── SESSION_SUMMARIES/     # 已归档
```

## 核心文件说明

### CURRENT_STATUS.md

**用途**: 提供项目的整体状态和进度概览。

**内容**:
- 项目概述
- 当前阶段
- 技术栈
- 已完成工作
- 进行中工作
- 待开始工作
- 遇到的问题
- 下一步计划
- 最近更新

**更新频率**: 每次会话后

### CONVERSATION_HISTORY.md

**用途**: 记录最近与AI助手对话的摘要。

**内容**:
- 对话日期和主题
- 讨论内容
- 决策
- 行动项
- 下一步计划

**更新频率**: 每次会话后

### DECISIONS_LOG.md

**用途**: 记录所有重要的项目决策。

**内容**:
- 决策日期和名称
- 决策内容
- 决策原因
- 替代方案
- 影响

**更新频率**: 做出新决策时

### AI_COLLABORATION_GUIDE.md

**用途**: 提供AI协作的详细指南。

**内容**:
- 协作流程
- 文件维护指南
- 最佳实践
- 故障排除
- 示例

**更新频率**: 协作方式变化时

## 子目录说明

### SESSION_SUMMARIES/

**用途**: 存储每次与AI助手会话的摘要记录。

**内容**:
- 会话主题
- 主要讨论内容
- 关键决策
- 生成的代码/文档
- 下一步计划

**更新频率**: 每次会话后添加新文件

### REFERENCE/

**用途**: 存储不常变动但重要的技术参考资料。

**内容**:
- 技术规范
- API文档
- 算法说明
- 架构图表

**更新频率**: 低，仅在核心技术变化时更新

## 使用方法

### 开始新会话

只需告诉AI：

```
请查看 ai_context/AI_COLLABORATION_GUIDE.md
```

AI会自动查看以下核心文档：
- CURRENT_STATUS.md - 了解项目当前状态和进度
- CONVERSATION_HISTORY.md - 了解最近对话的内容和决策
- DECISIONS_LOG.md - 了解项目关键决策

然后AI会主动提供项目状态概述，并询问您今天想要完成的具体任务。

### 会话进行中

可以使用以下命令：

| 命令 | 说明 |
|-------|--------|
| `查看项目状态` | 查看CURRENT_STATUS.md文件并提供项目状态概述 |
| `查看对话历史` | 查看CONVERSATION_HISTORY.md文件并提供最近对话的摘要 |
| `查看决策日志` | 查看DECISIONS_LOG.md文件并提供决策日志概述 |
| `记录决策` | 将新的决策添加到DECISIONS_LOG.md文件中 |

### 结束会话

当想要结束会话并更新项目状态时，只需说：

```
更新项目状态
```

AI会自动生成会话摘要，并更新：
1. CURRENT_STATUS.md - 更新项目状态、进度和下一步计划
2. CONVERSATION_HISTORY.md - 添加新的对话摘要
3. 如有新的重要决策，更新DECISIONS_LOG.md

## 维护指南

1. **保持文件更新**:
   - 每次会话后使用“更新项目状态”命令自动更新相关文件
   - 不要积累未记录的变更

2. **定期整理**:
   - 定期审查CURRENT_STATUS.md，移除不再相关的信息
   - 当CONVERSATION_HISTORY.md变得过长时，将旧的对话摘要移动到archive目录

3. **版本控制**:
   - 将ai_context目录纳入版本控制
   - 这样可以追踪项目状态的变化历史

4. **定期回顾**:
   - 每周回顾项目进度和AI协作效果
   - 根据需要调整协作流程和文件结构

通过这个简化的AI上下文管理框架，可以显著提高与AI助手的协作效率，减少重复工作，保持项目信息的一致性，并建立完整的项目知识库。详细的使用指南请参考`AI_COLLABORATION_GUIDE.md`文件。

```

### `/simpletrade/ai_context/archive/SESSION_SUMMARIES/README.md`
*(统计信息: 88 行, 1319 字符 [~0.19%])*
```markdown
# SESSION_SUMMARIES目录说明

**最后更新**: 2023-10-15

## 目录用途

SESSION_SUMMARIES目录用于存储每次与AI助手会话的摘要记录，作为项目进展的历史档案和知识积累。这些摘要记录了每次会话的主要内容、决策和成果，便于回顾和参考。

## 主要功能

1. **记录会话历史**:
   - 保存每次会话的主要讨论内容
   - 记录做出的关键决策
   - 跟踪生成的代码和文档

2. **知识积累**:
   - 构建项目发展的历史记录
   - 避免重复讨论已解决的问题
   - 为新加入的团队成员提供上下文

3. **进度追踪**:
   - 记录每次会话的成果
   - 跟踪下一步计划
   - 确保任务连续性

## 使用方法

1. **创建会话摘要**:
   - 在每次会话结束前，要求AI生成摘要
   - 摘要应包括讨论内容、决策、生成的代码/文档和下一步计划
   - 使用格式：`session_YYYYMMDD_N.md`，其中YYYYMMDD是日期，N是当天的会话序号

2. **参考历史会话**:
   - 在新会话中，可以引用之前的会话摘要以提供上下文
   - 例如：
     ```
     这是我们上次关于[主题]的讨论摘要:

     [从SESSION_SUMMARIES中粘贴相关内容]

     基于这个讨论，我们现在需要...
     ```

3. **回顾项目进展**:
   - 定期回顾会话摘要，了解项目的发展历程
   - 识别可能被遗忘的决策或想法
   - 评估项目进展速度和方向

## 文件命名规范

会话摘要文件应使用以下命名格式：
```
session_YYYYMMDD_N.md
```

其中：
- `YYYYMMDD`: 会话日期，例如20231015
- `N`: 当天的会话序号，从1开始

例如：`session_20231015_1.md`表示2023年10月15日的第一次会话摘要。

## 摘要内容结构

每个会话摘要应包含以下部分：

1. **主题**: 会话的主要主题或目标
2. **主要讨论内容**: 会话中讨论的关键点
3. **关键决策**: 会话中做出的重要决策
4. **生成的代码/文档**: 会话中创建或修改的文件
5. **下一步计划**: 下一步要执行的任务
6. **备注**: 其他需要记录的信息

## 维护指南

1. **定期归档**:
   - 当摘要数量变多时，考虑按月或按季度归档
   - 可以创建子目录，如`2023-Q4/`

2. **保持简洁**:
   - 摘要应该简明扼要，突出关键信息
   - 避免过多的细节，专注于重要的讨论和决策

3. **确保完整性**:
   - 每次会话都应创建摘要
   - 确保摘要包含所有关键信息

通过维护这些会话摘要，可以建立项目的"机构记忆"，减少信息丢失，提高团队协作效率，并为AI助手提供丰富的上下文信息，使其能够更好地理解项目的历史和当前状态。

```

### `/simpletrade/ai_context/REFERENCE/README.md`
*(统计信息: 66 行, 1098 字符 [~0.16%])*
```markdown
# REFERENCE目录说明

**最后更新**: 2023-10-15

## 目录用途

REFERENCE目录用于存储不常变动但重要的技术参考资料，作为项目的"知识库"或"参考手册"。与主要的状态文件(如PROJECT_STATUS.md)不同，这些文档通常不需要频繁更新，而是提供稳定的技术细节和实现指南。

## 主要功能

1. **存储技术参考文档**:
   - API接口定义和规范
   - 数据库模式设计
   - 第三方服务集成指南
   - 技术架构图表

2. **保存不常变动但重要的信息**:
   - 与vnpy相关的关键API参考
   - 交易接口规范
   - 数据格式定义
   - 算法和模型说明

3. **提供专业领域知识**:
   - 量化交易相关概念解释
   - 技术指标计算方法
   - 交易策略模式说明
   - 风控规则说明

## 使用方法

在与AI讨论特定技术细节时，可以参考这些文档，或者让AI查看这些文档以获取更详细的背景信息，确保AI理解项目中特定的技术实现要求。

例如，如果您正在讨论如何实现某个技术指标，可以这样引用：
```
我们需要实现RSI指标，这是相关的技术说明：

[从REFERENCE/TECHNICAL_INDICATORS.md中粘贴RSI部分]

请基于这个说明实现RSI计算函数。
```

## 文件列表

| 文件名 | 描述 | 更新频率 |
|-------|------|---------|
| `VNPY_KEY_COMPONENTS.md` | vnpy核心组件概览和使用指南 | 低 |
| `TECHNICAL_INDICATORS.md` | 技术指标计算方法和实现指南 | 低 |
| `API_OVERVIEW.md` | SimpleTrade API架构和端点说明 | 中 |

## 维护指南

1. **保持内容准确性**:
   - 确保文档内容与实际实现一致
   - 当核心技术发生变化时更新相关文档

2. **添加新文档**:
   - 随着项目的进展，可以添加更多参考文档
   - 建议添加的文档包括：数据库模式设计、微信小程序集成指南等

3. **文档格式**:
   - 使用Markdown格式
   - 包含代码示例和图表
   - 保持结构清晰，便于查找信息

这些参考文档将作为项目开发过程中的重要技术资料，帮助开发团队和AI助手理解系统的技术细节和实现方式。它们提供了详细的代码示例和最佳实践，可以直接用于指导实际开发工作。

```

### `/simpletrade/docker_scripts/run_api.py`
*(统计信息: 119 行, 4239 字符 [~0.61%])*
```python
#!/usr/bin/env python
import os
# Set environment variables for VnPy database settings BEFORE importing vnpy
# Use the VNPY_SETTING_{SECTION}__{KEY} format
# (数据库环境变量设置保持不变)
os.environ['VNPY_SETTING_DATABASE__DRIVER'] = 'mysql'
os.environ['VNPY_SETTING_DATABASE__HOST'] = 'mysql'
os.environ['VNPY_SETTING_DATABASE__PORT'] = '3306'
os.environ['VNPY_SETTING_DATABASE__USER'] = 'simpletrade'
os.environ['VNPY_SETTING_DATABASE__PASSWORD'] = 'password'
os.environ['VNPY_SETTING_DATABASE__DATABASE'] = 'simpletrade'

import uvicorn
import logging
import sys # sys 仍然需要用于日志配置
# from pathlib import Path # 不再需要 Path
import argparse
import threading
import asyncio

# 导入将在 simpletrade 包中定义的应用和配置函数
from simpletrade.services.data_sync_service import run_initial_data_sync
from simpletrade.core.server import configure_server # 导入服务器配置函数
# +++ 导入新的核心初始化函数 +++
from simpletrade.core.initialization import initialize_core_components

# (全局日志配置保持不变)
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)

# (VnPy 数据库设置保持不变，包括手动覆盖 SETTINGS)
try:
    from vnpy.trader.setting import SETTINGS
    import vnpy.trader.database as database_module
    SETTINGS["database.driver"] = "mysql"
    SETTINGS["database.host"] = "mysql"
    SETTINGS["database.port"] = 3306
    SETTINGS["database.user"] = "simpletrade"
    SETTINGS["database.password"] = "password"
    SETTINGS["database.database"] = "simpletrade"
    # 尝试 init (保持不变)
    try:
        database_module.init()
    except Exception as init_exc:
        pass # Ignore init error
    logging.info(f"VnPy database SETTINGS check in run_api: driver={SETTINGS.get('database.driver', 'N/A')}, host={SETTINGS.get('database.host', 'N/A')}") # ...
except Exception as e:
    logging.error(f"Error configuring VnPy database settings in run_api: {e}", exc_info=True)


# --- 不再需要修改 sys.path ---
# project_root = Path(__file__).parent.parent
# sys.path.insert(0, str(project_root))

# --- FastAPI 应用实例现在将在 simpletrade.api.server 中创建 ---
# app = FastAPI(title="SimpleTrade API", version="0.1.0") # 移动到 server.py

# --- 初始化引擎 & 配置服务器 (使用新的初始化函数) ---
main_engine = None
event_engine = None
try:
    # +++ 调用核心初始化函数 +++
    logging.info("Initializing core components via initialize_core_components...")
    main_engine, event_engine = initialize_core_components()
    logging.info("Core components initialized successfully.")

    # --- 配置 FastAPI 应用 (传入初始化好的引擎) ---
    logging.info("Configuring FastAPI server via configure_server...")
    configure_server(main_engine=main_engine, event_engine=event_engine)
    logging.info("FastAPI server instance configured.")

except Exception as e:
    logging.error(f"FATAL ERROR during setup in run_api: {e}", exc_info=True)
    sys.exit(1)

# --- 后台数据同步线程 (保持不变) ---
def start_background_sync():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        logging.info("Background thread: Running run_initial_data_sync...")
        loop.run_until_complete(run_initial_data_sync())
        logging.info("Background thread: run_initial_data_sync completed.")
    except Exception as e:
        logging.error(f"EXCEPTION in background sync thread: {e}", exc_info=True)
    finally:
        logging.info("Background thread: Closing event loop.")
        loop.close()

logging.info("Creating and starting background data sync thread...")
try:
    sync_thread = threading.Thread(target=start_background_sync, daemon=True)
    sync_thread.start()
    logging.info("Background data sync thread started.")
except Exception as thread_e:
    logging.error(f"FAILED to start background data sync thread: {thread_e}", exc_info=True)

# --- 启动 Uvicorn (保持不变) ---
if __name__ == "__main__":
    logging.info("Starting Uvicorn server...")
    # 从配置或环境变量获取 host 和 port 可能更好，但暂时保持硬编码
    host = "0.0.0.0"
    port = 8003
    log_level = "info"
    reload = False # 通常在生产或 Docker 中禁用 reload

    logging.info(f"Running Uvicorn on {host}:{port}")

    # 更新指向core.server中的app实例
    uvicorn.run(
        "simpletrade.core.server:app", # 指向 core/server.py 中的 app
        host=host,
        port=port,
        log_level=log_level,
        reload=reload
    )
```

### `/simpletrade/docker_scripts/check_system.sh`
*(统计信息: 39 行, 513 字符 [~0.07%])*
```bash
#!/bin/bash

# 检查系统状态
echo "=== 系统信息 ==="
uname -a
echo

echo "=== CPU信息 ==="
cat /proc/cpuinfo | grep "model name" | head -1
echo "CPU核心数: $(nproc)"
echo

echo "=== 内存信息 ==="
free -h
echo

echo "=== 磁盘信息 ==="
df -h
echo

echo "=== Python信息 ==="
python --version
pip --version
echo

echo "=== vnpy信息 ==="
python -c "import vnpy; print(f'vnpy版本: {vnpy.__version__}')"
echo

echo "=== 网络信息 ==="
ip addr | grep inet
echo

echo "=== 进程信息 ==="
ps aux | grep -E 'python|vnpy' | grep -v grep
echo

echo "=== 系统检查完成 ==="

```

### `/simpletrade/docker_scripts/run_backtest.sh`
*(统计信息: 34 行, 629 字符 [~0.09%])*
```bash
#!/bin/bash

# 运行回测脚本
# 用法: ./run_backtest.sh <策略名称> <开始日期> <结束日期> <交易品种> <交易所>

# 检查参数
if [ $# -lt 5 ]; then
    echo "用法: $0 <策略名称> <开始日期> <结束日期> <交易品种> <交易所>"
    echo "示例: $0 MovingAverageStrategy 20200101 20201231 BTCUSDT BINANCE"
    exit 1
fi

STRATEGY=$1
START_DATE=$2
END_DATE=$3
SYMBOL=$4
EXCHANGE=$5

echo "开始回测..."
echo "策略: $STRATEGY"
echo "时间范围: $START_DATE - $END_DATE"
echo "交易品种: $SYMBOL"
echo "交易所: $EXCHANGE"

# 运行回测
python -m simpletrade.backtest.run_backtest \
    --strategy $STRATEGY \
    --start_date $START_DATE \
    --end_date $END_DATE \
    --symbol $SYMBOL \
    --exchange $EXCHANGE

echo "回测完成!"

```

### `/simpletrade/docker_scripts/backup_data.sh`
*(统计信息: 29 行, 516 字符 [~0.07%])*
```bash
#!/bin/bash

# 备份数据
BACKUP_DIR="/app/backups"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
BACKUP_FILE="${BACKUP_DIR}/backup_${TIMESTAMP}.tar.gz"

# 创建备份目录
mkdir -p ${BACKUP_DIR}

# 备份数据
echo "开始备份数据..."
tar -czf ${BACKUP_FILE} /app/data /app/configs /app/logs

# 检查备份是否成功
if [ $? -eq 0 ]; then
    echo "备份成功: ${BACKUP_FILE}"
    echo "备份大小: $(du -h ${BACKUP_FILE} | cut -f1)"
else
    echo "备份失败!"
    exit 1
fi

# 清理旧备份（保留最近10个）
echo "清理旧备份..."
ls -t ${BACKUP_DIR}/backup_*.tar.gz | tail -n +11 | xargs -r rm

echo "备份完成!"

```

### `/simpletrade/docker_scripts/start_jupyter.sh`
*(统计信息: 5 行, 153 字符 [~0.02%])*
```bash
#!/bin/bash

# 启动Jupyter Notebook服务
jupyter notebook --ip=0.0.0.0 --port=8888 --no-browser --allow-root --NotebookApp.token='' --NotebookApp.password=''

```

### `/simpletrade/examples/data_management_example.py`
*(统计信息: 107 行, 2671 字符 [~0.38%])*
```python
#!/usr/bin/env python
"""
数据管理示例

展示如何使用SimpleTrade的数据管理功能。
"""

import sys
import os
from pathlib import Path
from datetime import datetime, timedelta
import random

# 添加项目根目录到Python路径
ROOT_DIR = Path(__file__).parent.parent.absolute()
sys.path.append(str(ROOT_DIR))

# 导入vnpy的数据模型和数据管理功能
from vnpy.trader.object import BarData, TickData
from vnpy.trader.constant import Exchange, Interval

# 导入我们的数据管理器
from simpletrade.core.data import DataManager

def main():
    """主函数"""
    print("SimpleTrade数据管理示例")

    # 创建数据管理器
    manager = DataManager()

    # 生成测试数据
    bars = []

    # 使用当前时间作为基准
    now = datetime.now()

    # 生成过去30天的日线数据
    for i in range(30):
        dt = now - timedelta(days=i)

        # 生成随机价格
        close_price = random.uniform(100, 200)
        open_price = close_price * random.uniform(0.98, 1.02)
        high_price = max(open_price, close_price) * random.uniform(1.0, 1.05)
        low_price = min(open_price, close_price) * random.uniform(0.95, 1.0)

        # 生成随机成交量
        volume = random.uniform(1000, 10000)

        # 创建K线数据
        bar = BarData(
            symbol="AAPL",
            exchange=Exchange.NASDAQ,
            datetime=dt,
            interval=Interval.DAILY,
            open_price=open_price,
            high_price=high_price,
            low_price=low_price,
            close_price=close_price,
            volume=volume,
            open_interest=0
        )

        bars.append(bar)

    # 保存数据
    count = manager.save_bar_data(bars)
    print(f"保存了 {count} 条K线数据")

    # 查询数据
    start = now - timedelta(days=30)
    end = now

    loaded_bars = manager.load_bar_data(
        symbol="AAPL",
        exchange=Exchange.NASDAQ,
        interval=Interval.DAILY,
        start=start,
        end=end
    )

    print(f"查询到 {len(loaded_bars)} 条K线数据")

    # 打印前5条数据
    for i, bar in enumerate(loaded_bars[:5]):
        print(f"{i+1}. {bar.datetime.strftime('%Y-%m-%d')}: 开{bar.open_price:.2f} 高{bar.high_price:.2f} 低{bar.low_price:.2f} 收{bar.close_price:.2f} 量{bar.volume:.2f}")

    # 获取数据概览
    overviews = manager.get_bar_overview()

    print("\n数据概览:")
    for i, overview in enumerate(overviews):
        print(f"{i+1}. {overview['symbol']}.{overview['exchange']} - {overview['interval']} - {overview['count']}条 ({overview['start'].strftime('%Y-%m-%d')} 至 {overview['end'].strftime('%Y-%m-%d')})")

    # 删除数据
    count = manager.delete_bar_data(
        symbol="AAPL",
        exchange=Exchange.NASDAQ,
        interval=Interval.DAILY
    )

    print(f"\n删除了 {count} 条K线数据")

if __name__ == "__main__":
    main()

```

### `/simpletrade/examples/api_example.py`
*(统计信息: 39 行, 760 字符 [~0.11%])*
```python
#!/usr/bin/env python
"""
API服务示例

展示如何启动和使用SimpleTrade的API服务。
"""

import sys
import os
from pathlib import Path

# 添加项目根目录到Python路径
ROOT_DIR = Path(__file__).parent.parent.absolute()
sys.path.append(str(ROOT_DIR))

from fastapi import FastAPI
import uvicorn

from simpletrade.api.data import router as data_router
from simpletrade.api.analysis import router as analysis_router

def main():
    """主函数"""
    print("SimpleTrade API服务示例")

    # 创建FastAPI应用
    app = FastAPI(title="SimpleTrade API")

    # 添加路由
    app.include_router(data_router)
    app.include_router(analysis_router)

    # 启动服务
    print("API服务已启动，访问 http://localhost:8000/docs 查看API文档")
    uvicorn.run(app, host="0.0.0.0", port=8000)

if __name__ == "__main__":
    main()

```

### `/simpletrade/simpletrade.egg-info/SOURCES.txt`
*(统计信息: 64 行, 2131 字符 [~0.31%])*
```
README.md
setup.py
scripts/__init__.py
scripts/download_tiger_data.py
scripts/import_csv_to_database.py
scripts/import_csv_to_sqlite.py
scripts/import_qlib_to_csv.py
scripts/import_qlib_to_database.py
scripts/import_qlib_to_database_direct.py
scripts/import_qlib_via_api.py
scripts/simple_api_test.py
scripts/start_simple_web.py
scripts/start_web_frontend.py
scripts/subscribe_tiger_data.py
scripts/test_api_server.py
scripts/upload_qlib_data_via_api.py
simpletrade/__init__.py
simpletrade/main.py
simpletrade.egg-info/PKG-INFO
simpletrade.egg-info/SOURCES.txt
simpletrade.egg-info/dependency_links.txt
simpletrade.egg-info/requires.txt
simpletrade.egg-info/top_level.txt
simpletrade/api/__init__.py
simpletrade/api/analysis.py
simpletrade/api/server.py
simpletrade/api/wechat/__init__.py
simpletrade/api/wechat/auth.py
simpletrade/api/wechat/data.py
simpletrade/apps/__init__.py
simpletrade/apps/st_datamanager/__init__.py
simpletrade/apps/st_datamanager/engine.py
simpletrade/apps/st_datamanager/api/__init__.py
simpletrade/apps/st_datamanager/api/routes.py
simpletrade/apps/st_datamanager/commands/__init__.py
simpletrade/apps/st_datamanager/commands/processor.py
simpletrade/apps/st_datamanager/importers/__init__.py
simpletrade/apps/st_datamanager/importers/qlib_importer.py
simpletrade/apps/st_message/__init__.py
simpletrade/apps/st_message/engine.py
simpletrade/apps/st_message/test.py
simpletrade/apps/st_trader/__init__.py
simpletrade/apps/st_trader/engine.py
simpletrade/apps/st_trader/widget.py
simpletrade/core/__init__.py
simpletrade/core/app.py
simpletrade/core/engine.py
simpletrade/core/analysis/__init__.py
simpletrade/core/analysis/backtest.py
simpletrade/core/analysis/indicators.py
simpletrade/core/data/__init__.py
simpletrade/core/message/__init__.py
simpletrade/core/message/data_processor.py
simpletrade/core/message/processor.py
simpletrade/models/__init__.py
simpletrade/utils/__init__.py
tests/test_analysis.py
tests/test_data_api.py
tests/test_data_manager.py
tests/test_datamanager.py
tests/test_datamanager_simple.py
tests/test_tiger_gateway.py
tests/test_vnpy_integration.py
tests/test_wechat_api.py
```

### `/simpletrade/simpletrade.egg-info/PKG-INFO`
*(统计信息: 14 行, 288 字符 [~0.04%])*
```
Metadata-Version: 2.1
Name: simpletrade
Version: 0.1.0
Summary: 简单易用的个人量化交易平台
Author: SimpleTrade Team
Requires-Python: >=3.7
Requires-Dist: numpy
Requires-Dist: pandas
Requires-Dist: matplotlib
Requires-Dist: fastapi
Requires-Dist: uvicorn
Requires-Dist: sqlalchemy
Requires-Dist: pyqt5

```

### `/simpletrade/simpletrade.egg-info/requires.txt`
*(统计信息: 8 行, 57 字符 [~0.01%])*
```
numpy
pandas
matplotlib
fastapi
uvicorn
sqlalchemy
pyqt5

```

### `/simpletrade/simpletrade.egg-info/top_level.txt`
*(统计信息: 3 行, 20 字符 [~0.00%])*
```
scripts
simpletrade

```

### `/simpletrade/simpletrade.egg-info/dependency_links.txt`
*(统计信息: 2 行, 1 字符 [~0.00%])*
```


```

### `/simpletrade/ui/js/load_sidebar.js`
*(统计信息: 58 行, 2909 字符 [~0.42%])*
```javascript
document.addEventListener('DOMContentLoaded', function() {
    const sidebarPlaceholder = document.getElementById('sidebar-placeholder');
    const sidebarPath = '../common/sidebar.html'; // Adjusted path relative to files in subdirectories

    if (sidebarPlaceholder) {
        fetch(sidebarPath)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.text();
            })
            .then(data => {
                sidebarPlaceholder.innerHTML = data;
                highlightCurrentLink();
            })
            .catch(error => {
                console.error('Error loading sidebar:', error);
                sidebarPlaceholder.innerHTML = '<p class="text-red-500 p-4">Error loading sidebar.</p>';
            });
    }
});

function highlightCurrentLink() {
    const currentPath = window.location.pathname;
    const sidebarLinks = document.querySelectorAll('#sidebar-placeholder .sidebar-link');

    sidebarLinks.forEach(link => {
        const linkPath = link.getAttribute('href');

        // Normalize paths for comparison (remove ../ and ensure consistency)
        // This basic normalization works for the current structure.
        // More complex routing might need a more robust solution.
        const cleanLinkPath = linkPath.startsWith('../') ? linkPath.substring(2) : linkPath;
        const cleanCurrentPath = currentPath.substring(currentPath.indexOf('/web/') + 4); // Get path relative to /web/

        // Check if the cleaned current path ends with the cleaned link path
        if (cleanCurrentPath.endsWith(cleanLinkPath)) {
            link.classList.add('active');
        }
         // Special case for strategy detail page highlighting the parent '选股策略' link
        else if (cleanCurrentPath.includes('/strategies/strategy_detail.html') && cleanLinkPath.endsWith('/strategies/stock_selection_strategies.html')) {
             link.classList.add('active');
        }
        // Special case for edit model page highlighting the parent '选股策略' link (assuming models relate to strategies for now)
        else if (cleanCurrentPath.includes('/models/edit_model.html') && cleanLinkPath.endsWith('/strategies/stock_selection_strategies.html')) {
             link.classList.add('active');
        }
         // Add more special cases if needed (e.g., settings, login)
         else if (cleanCurrentPath.includes('/common/settings.html') && cleanLinkPath.endsWith('/common/settings.html')) {
              link.classList.add('active');
         }
         else if (cleanCurrentPath.includes('/common/login.html') && cleanLinkPath.endsWith('/common/login.html')) {
              // Technically login might not have the sidebar, but included for completeness if it did
              link.classList.add('active');
         }
    });
}
```

### `/simpletrade/ui/backtest/.gitkeep`
*(统计信息: 2 行, 1 字符 [~0.00%])*
```


```

### `/simpletrade/ui/common/.gitkeep`
*(统计信息: 2 行, 1 字符 [~0.00%])*
```


```

### `/simpletrade/ui/dashboard/.gitkeep`
*(统计信息: 2 行, 1 字符 [~0.00%])*
```


```

### `/simpletrade/ui/data/.gitkeep`
*(统计信息: 2 行, 1 字符 [~0.00%])*
```


```

### `/simpletrade/ui/strategies/.gitkeep`
*(统计信息: 2 行, 1 字符 [~0.00%])*
```


```

### `/simpletrade/ui/trading/.gitkeep`
*(统计信息: 2 行, 1 字符 [~0.00%])*
```


```

### `/simpletrade/mysql-init/01-init.sql`
*(统计信息: 26 行, 895 字符 [~0.13%])*
```sql
-- 初始化数据库
-- 这个脚本会在MySQL容器首次启动时执行

-- 创建用户表（如果不存在）
CREATE TABLE IF NOT EXISTS `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL,
  `email` varchar(100) NOT NULL,
  `password_hash` varchar(255) NOT NULL,
  `is_active` tinyint(1) NOT NULL DEFAULT '1',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 创建默认管理员用户（如果不存在）
INSERT INTO `users` (`username`, `email`, `password_hash`, `is_active`)
SELECT 'admin', 'admin@example.com', '$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW', 1
FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM `users` WHERE `username` = 'admin');

-- 注意: 上面的密码哈希对应的明文密码是 'password'
-- 在生产环境中应该使用更强的密码

```

### `/simpletrade/src/components/MainLayout.vue`
*(统计信息: 24 行, 454 字符 [~0.06%])*
```
<template>
  <!-- No changes to template section -->
</template>

<script>
export default {
  computed: {
    pageTitle() {
      const routeMap = {
        '/strategy-center': '策略中心',
        '/trading-center': '交易中心',
        '/ai-analysis': 'AI分析',
        '/user-center': '用户中心'
      };
      // 如果当前路径不在 routeMap 中，就返回空字符串
      return routeMap[this.$route.path] || '';
    }
  },
};
</script>

<style>
  /* No changes to style section */
</style>
```